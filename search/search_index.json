{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to geemap A Python package for interactive mapping with Google Earth Engine, ipyleaflet, and ipywidgets. GitHub repo: https://github.com/giswqs/geemap Documentation: https://giswqs.github.io/geemap PyPI: https://pypi.org/project/geemap Conda-forge: https://anaconda.org/conda-forge/geemap 360+ GEE notebook examples: https://github.com/giswqs/earthengine-py-notebooks GEE Tutorials on YouTube: https://www.youtube.com/c/QiushengWu Free software: MIT license Introduction geemap is a Python package for interactive mapping with Google Earth Engine (GEE), which is a cloud computing platform with a multi-petabyte catalog of satellite imagery and geospatial datasets. During the past few years, GEE has become very popular in the geospatial community and it has empowered numerous environmental applications at local, regional, and global scales. GEE provides both JavaScript and Python APIs for making computational requests to the Earth Engine servers. Compared with the comprehensive documentation and interactive IDE (i.e., GEE JavaScript Code Editor ) of the GEE JavaScript API, the GEE Python API has relatively little documentation and limited functionality for visualizing results interactively. The geemap Python package was created to fill this gap. It is built upon ipyleaflet and ipywidgets , and enables users to analyze and visualize Earth Engine datasets interactively within a Jupyter-based environment. geemap is intended for students and researchers, who would like to utilize the Python ecosystem of diverse libraries and tools to explore Google Earth Engine. It is also designed for existing GEE users who would like to transition from the GEE JavaScript API to Python API. The automated JavaScript-to-Python conversion module of the geemap package can greatly reduce the time needed to convert existing GEE JavaScripts to Python scripts and Jupyter notebooks. For video tutorials and notebook examples, please visit the examples page . For complete documentation on geemap modules and methods, please visit the API Reference . If you find geemap useful in your research, please consider citing the following papers to support my work. Thank you for your support. Wu, Q., (2020). geemap: A Python package for interactive mapping with Google Earth Engine. The Journal of Open Source Software, 5(51), 2305. https://doi.org/10.21105/joss.02305 Wu, Q., Lane, C. R., Li, X., Zhao, K., Zhou, Y., Clinton, N., DeVries, B., Golden, H. E., & Lang, M. W. (2019). Integrating LiDAR data and multi-temporal aerial imagery to map wetland inundation dynamics using Google Earth Engine. Remote Sensing of Environment, 228, 1-13. https://doi.org/10.1016/j.rse.2019.04.015 ( pdf | source code ) Key Features Below is a partial list of features available for the geemap package. Please check the examples page for notebook examples, GIF animations, and video tutorials. Convert Earth Engine JavaScripts to Python scripts and Jupyter notebooks. Display Earth Engine data layers for interactive mapping. Support Earth Engine JavaScript API-styled functions in Python, such as Map.addLayer() , Map.setCenter() , Map.centerObject() , Map.setOptions() . Create split-panel maps with Earth Engine data. Retrieve Earth Engine data interactively using the Inspector Tool. Interactive plotting of Earth Engine data by simply clicking on the map. Convert data format between GeoJSON and Earth Engine. Use drawing tools to interact with Earth Engine data. Use shapefiles with Earth Engine without having to upload data to one's GEE account. Export Earth Engine FeatureCollection to other formats (i.e., shp, csv, json, kml, kmz). Export Earth Engine Image and ImageCollection as GeoTIFF. Extract pixels from an Earth Engine Image into a 3D numpy array. Calculate zonal statistics by group. Add a customized legend for Earth Engine data. Convert Earth Engine JavaScripts to Python code directly within Jupyter notebook. Add animated text to GIF images generated from Earth Engine data. Add colorbar and images to GIF animations generated from Earth Engine data. Create Landsat timelapse animations with animated text using Earth Engine. Search places and datasets from Earth Engine Data Catalog. Use timeseries inspector to visualize landscape changes over time. Export Earth Engine maps as HTML files and PNG images. Search Earth Engine API documentation within Jupyter notebooks. Import Earth Engine assets from personal account. Publish interactive GEE maps directly within Jupyter notebook. Add local raster datasets (e.g., GeoTIFF) to the map. Perform image classification and accuracy assessment. Extract pixel values interactively and export as shapefile and csv. YouTube Channel I have created a YouTube Channel for sharing geemap tutorials. You can subscribe to my channel for regular updates. If there is any specific tutorial you would like to see, please submit a feature request here .","title":"Home"},{"location":"#welcome-to-geemap","text":"A Python package for interactive mapping with Google Earth Engine, ipyleaflet, and ipywidgets. GitHub repo: https://github.com/giswqs/geemap Documentation: https://giswqs.github.io/geemap PyPI: https://pypi.org/project/geemap Conda-forge: https://anaconda.org/conda-forge/geemap 360+ GEE notebook examples: https://github.com/giswqs/earthengine-py-notebooks GEE Tutorials on YouTube: https://www.youtube.com/c/QiushengWu Free software: MIT license","title":"Welcome to geemap"},{"location":"#introduction","text":"geemap is a Python package for interactive mapping with Google Earth Engine (GEE), which is a cloud computing platform with a multi-petabyte catalog of satellite imagery and geospatial datasets. During the past few years, GEE has become very popular in the geospatial community and it has empowered numerous environmental applications at local, regional, and global scales. GEE provides both JavaScript and Python APIs for making computational requests to the Earth Engine servers. Compared with the comprehensive documentation and interactive IDE (i.e., GEE JavaScript Code Editor ) of the GEE JavaScript API, the GEE Python API has relatively little documentation and limited functionality for visualizing results interactively. The geemap Python package was created to fill this gap. It is built upon ipyleaflet and ipywidgets , and enables users to analyze and visualize Earth Engine datasets interactively within a Jupyter-based environment. geemap is intended for students and researchers, who would like to utilize the Python ecosystem of diverse libraries and tools to explore Google Earth Engine. It is also designed for existing GEE users who would like to transition from the GEE JavaScript API to Python API. The automated JavaScript-to-Python conversion module of the geemap package can greatly reduce the time needed to convert existing GEE JavaScripts to Python scripts and Jupyter notebooks. For video tutorials and notebook examples, please visit the examples page . For complete documentation on geemap modules and methods, please visit the API Reference . If you find geemap useful in your research, please consider citing the following papers to support my work. Thank you for your support. Wu, Q., (2020). geemap: A Python package for interactive mapping with Google Earth Engine. The Journal of Open Source Software, 5(51), 2305. https://doi.org/10.21105/joss.02305 Wu, Q., Lane, C. R., Li, X., Zhao, K., Zhou, Y., Clinton, N., DeVries, B., Golden, H. E., & Lang, M. W. (2019). Integrating LiDAR data and multi-temporal aerial imagery to map wetland inundation dynamics using Google Earth Engine. Remote Sensing of Environment, 228, 1-13. https://doi.org/10.1016/j.rse.2019.04.015 ( pdf | source code )","title":"Introduction"},{"location":"#key-features","text":"Below is a partial list of features available for the geemap package. Please check the examples page for notebook examples, GIF animations, and video tutorials. Convert Earth Engine JavaScripts to Python scripts and Jupyter notebooks. Display Earth Engine data layers for interactive mapping. Support Earth Engine JavaScript API-styled functions in Python, such as Map.addLayer() , Map.setCenter() , Map.centerObject() , Map.setOptions() . Create split-panel maps with Earth Engine data. Retrieve Earth Engine data interactively using the Inspector Tool. Interactive plotting of Earth Engine data by simply clicking on the map. Convert data format between GeoJSON and Earth Engine. Use drawing tools to interact with Earth Engine data. Use shapefiles with Earth Engine without having to upload data to one's GEE account. Export Earth Engine FeatureCollection to other formats (i.e., shp, csv, json, kml, kmz). Export Earth Engine Image and ImageCollection as GeoTIFF. Extract pixels from an Earth Engine Image into a 3D numpy array. Calculate zonal statistics by group. Add a customized legend for Earth Engine data. Convert Earth Engine JavaScripts to Python code directly within Jupyter notebook. Add animated text to GIF images generated from Earth Engine data. Add colorbar and images to GIF animations generated from Earth Engine data. Create Landsat timelapse animations with animated text using Earth Engine. Search places and datasets from Earth Engine Data Catalog. Use timeseries inspector to visualize landscape changes over time. Export Earth Engine maps as HTML files and PNG images. Search Earth Engine API documentation within Jupyter notebooks. Import Earth Engine assets from personal account. Publish interactive GEE maps directly within Jupyter notebook. Add local raster datasets (e.g., GeoTIFF) to the map. Perform image classification and accuracy assessment. Extract pixel values interactively and export as shapefile and csv.","title":"Key Features"},{"location":"#youtube-channel","text":"I have created a YouTube Channel for sharing geemap tutorials. You can subscribe to my channel for regular updates. If there is any specific tutorial you would like to see, please submit a feature request here .","title":"YouTube Channel"},{"location":"basemaps/","text":"basemaps module Module for basemaps. Each basemap is defined as item in the ee_basemaps dictionary. For example, to access Google basemaps, use the following: ee_basemaps['ROADMAP'], ee_basemaps['SATELLITE'], ee_basemaps['HYBRID']. More WMS basemaps can be found at the following websites: USGS National Map: https://viewer.nationalmap.gov/services/ MRLC NLCD Land Cover data: https://viewer.nationalmap.gov/services/ FWS NWI Wetlands data: https://www.fws.gov/wetlands/Data/Web-Map-Services.html","title":"basemaps module"},{"location":"basemaps/#basemaps-module","text":"","title":"basemaps module"},{"location":"basemaps/#geemap.basemaps","text":"Module for basemaps. Each basemap is defined as item in the ee_basemaps dictionary. For example, to access Google basemaps, use the following: ee_basemaps['ROADMAP'], ee_basemaps['SATELLITE'], ee_basemaps['HYBRID']. More WMS basemaps can be found at the following websites: USGS National Map: https://viewer.nationalmap.gov/services/ MRLC NLCD Land Cover data: https://viewer.nationalmap.gov/services/ FWS NWI Wetlands data: https://www.fws.gov/wetlands/Data/Web-Map-Services.html","title":"geemap.basemaps"},{"location":"cartoee/","text":"cartoee module add_colorbar ( ax , vis_params , loc = None , cmap = 'gray' , discrete = False , label = None , ** kwargs ) Add a colorbar tp the map based on visualization parameters provided Parameters: Name Type Description Default ax cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes required cartopy GeoAxesSubplot object to add image overlay to required loc str string specifying the position None vis_params dict visualization parameters as a dictionary. See https://developers.google.com/earth-engine/image_visualization for options required **kwargs remaining keyword arguments are passed to colorbar() {} Exceptions: Type Description Warning If 'discrete' is true when \"palette\" key is not in visParams ValueError If ax is not of type cartopy.mpl.geoaxes.GeoAxesSubplot ValueError If 'cmap' or \"palette\" key in visParams is not provided ValueError If \"min\" in visParams is not of type scalar ValueError If \"max\" in visParams is not of type scalar ValueError If 'loc' or 'cax' keywords are not provided ValueError If 'loc' is not of type str or does not equal available options Source code in geemap/cartoee.py def add_colorbar ( ax , vis_params , loc = None , cmap = \"gray\" , discrete = False , label = None , ** kwargs ): \"\"\" Add a colorbar tp the map based on visualization parameters provided args: ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to add image overlay to loc (str, optional): string specifying the position vis_params (dict, optional): visualization parameters as a dictionary. See https://developers.google.com/earth-engine/image_visualization for options **kwargs: remaining keyword arguments are passed to colorbar() raises: Warning: If 'discrete' is true when \"palette\" key is not in visParams ValueError: If `ax` is not of type cartopy.mpl.geoaxes.GeoAxesSubplot ValueError: If 'cmap' or \"palette\" key in visParams is not provided ValueError: If \"min\" in visParams is not of type scalar ValueError: If \"max\" in visParams is not of type scalar ValueError: If 'loc' or 'cax' keywords are not provided ValueError: If 'loc' is not of type str or does not equal available options \"\"\" if type ( ax ) not in [ GeoAxes , GeoAxesSubplot ]: raise ValueError ( \"provided axes not of type cartopy.mpl.geoaxes.GeoAxes \" \"or cartopy.mpl.geoaxes.GeoAxesSubplot\" ) if loc : if ( type ( loc ) == str ) and ( loc in [ \"left\" , \"right\" , \"bottom\" , \"top\" ]): posOpts = { \"left\" : [ 0.01 , 0.25 , 0.02 , 0.5 ], \"right\" : [ 0.88 , 0.25 , 0.02 , 0.5 ], \"bottom\" : [ 0.25 , 0.15 , 0.5 , 0.02 ], \"top\" : [ 0.25 , 0.88 , 0.5 , 0.02 ], } cax = ax . figure . add_axes ( posOpts [ loc ]) if loc == \"left\" : mpl . pyplot . subplots_adjust ( left = 0.18 ) elif loc == \"right\" : mpl . pyplot . subplots_adjust ( right = 0.85 ) else : pass else : raise ValueError ( 'provided loc not of type str. options are \"left\", ' '\"top\", \"right\", or \"bottom\"' ) elif \"cax\" in kwargs : cax = kwargs [ \"cax\" ] kwargs = { key : kwargs [ key ] for key in kwargs . keys () if key != \"cax\" } else : raise ValueError ( \"loc or cax keywords must be specified\" ) vis_keys = list ( vis_params . keys ()) if vis_params : if \"min\" in vis_params : vmin = vis_params [ \"min\" ] if type ( vmin ) not in ( int , float ): raise ValueError ( \"provided min value not of scalar type\" ) else : vmin = 0 if \"max\" in vis_params : vmax = vis_params [ \"max\" ] if type ( vmax ) not in ( int , float ): raise ValueError ( \"provided max value not of scalar type\" ) else : vmax = 1 if \"opacity\" in vis_params : alpha = vis_params [ \"opacity\" ] if type ( alpha ) not in ( int , float ): raise ValueError ( \"provided opacity value of not type scalar\" ) elif \"alpha\" in kwargs : alpha = kwargs [ \"alpha\" ] else : alpha = 1 if cmap is not None : if discrete : warnings . warn ( 'discrete keyword used when \"palette\" key is ' \"supplied with visParams, creating a continuous \" \"colorbar...\" ) cmap = mpl . pyplot . get_cmap ( cmap ) norm = mpl . colors . Normalize ( vmin = vmin , vmax = vmax ) if \"palette\" in vis_keys : hexcodes = vis_params [ \"palette\" ] . split ( \",\" ) hexcodes = [ i if i [ 0 ] == \"#\" else \"#\" + i for i in hexcodes ] if discrete : cmap = mpl . colors . ListedColormap ( hexcodes ) vals = np . linspace ( vmin , vmax , cmap . N + 1 ) norm = mpl . colors . BoundaryNorm ( vals , cmap . N ) else : cmap = mpl . colors . LinearSegmentedColormap . from_list ( \"custom\" , hexcodes , N = 256 ) norm = mpl . colors . Normalize ( vmin = vmin , vmax = vmax ) cmap = cmap elif cmap is not None : if discrete : warnings . warn ( 'discrete keyword used when \"palette\" key is ' \"supplied with visParams, creating a continuous \" \"colorbar...\" ) cmap = mpl . pyplot . get_cmap ( cmap ) norm = mpl . colors . Normalize ( vmin = vmin , vmax = vmax ) else : raise ValueError ( 'cmap keyword or \"palette\" key in visParams must be provided' ) cb = mpl . colorbar . ColorbarBase ( cax , norm = norm , alpha = alpha , cmap = cmap , ** kwargs ) if \"bands\" in vis_keys : cb . set_label ( vis_params [ \"bands\" ]) elif label is not None : cb . set_label ( label ) return add_gridlines ( ax , interval = None , n_ticks = None , xs = None , ys = None , buffer_out = True , xtick_rotation = 'horizontal' , ytick_rotation = 'horizontal' , ** kwargs ) Helper function to add gridlines and format ticks to map Parameters: Name Type Description Default ax cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes required cartopy GeoAxesSubplot object to add the gridlines to required interval float | list[float] float specifying an interval at which to create gridlines, units are decimal degrees. lists will be interpreted a [x_interval, y_interval]. default = None None n_ticks int | list[int] integer specifying number gridlines to create within map extent. lists will be interpreted a [nx, ny]. default = None None xs list list of x coordinates to create gridlines. default = None None ys list list of y coordinates to create gridlines. default = None None buffer_out boolean boolean option to buffer out the extent to insure coordinates created cover map extent. default=true True xtick_rotation str | float 'horizontal' ytick_rotation str | float 'horizontal' **kwargs remaining keyword arguments are passed to gridlines() {} Exceptions: Type Description ValueError if all interval, n_ticks, or (xs,ys) are set to None Source code in geemap/cartoee.py def add_gridlines ( ax , interval = None , n_ticks = None , xs = None , ys = None , buffer_out = True , xtick_rotation = \"horizontal\" , ytick_rotation = \"horizontal\" , ** kwargs , ): \"\"\"Helper function to add gridlines and format ticks to map args: ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to add the gridlines to interval (float | list[float], optional): float specifying an interval at which to create gridlines, units are decimal degrees. lists will be interpreted a [x_interval, y_interval]. default = None n_ticks (int | list[int], optional): integer specifying number gridlines to create within map extent. lists will be interpreted a [nx, ny]. default = None xs (list, optional): list of x coordinates to create gridlines. default = None ys (list, optional): list of y coordinates to create gridlines. default = None buffer_out (boolean, optional): boolean option to buffer out the extent to insure coordinates created cover map extent. default=true xtick_rotation (str | float, optional): ytick_rotation (str | float, optional): **kwargs: remaining keyword arguments are passed to gridlines() raises: ValueError: if all interval, n_ticks, or (xs,ys) are set to None \"\"\" view_extent = ax . get_extent () extent = view_extent if xs is not None : xmain = xs elif interval is not None : if isinstance ( interval , Iterable ): xspace = interval [ 0 ] else : xspace = interval if buffer_out : extent = _buffer_box ( extent , xspace ) xmain = np . arange ( extent [ 0 ], extent [ 1 ] + xspace , xspace ) elif n_ticks is not None : if isinstance ( n_ticks , Iterable ): n_x = n_ticks [ 0 ] else : n_x = n_ticks xmain = np . linspace ( extent [ 0 ], extent [ 1 ], n_x ) else : raise ValueError ( \"one of variables interval, n_ticks, or xs must be defined. If you would like default gridlines, please use `ax.gridlines()`\" ) if ys is not None : ymain = ys elif interval is not None : if isinstance ( interval , Iterable ): yspace = interval [ 1 ] else : yspace = interval if buffer_out : extent = _buffer_box ( extent , yspace ) ymain = np . arange ( extent [ 2 ], extent [ 3 ] + yspace , yspace ) elif n_ticks is not None : if isinstance ( n_ticks , Iterable ): n_y = n_ticks [ 1 ] else : n_y = n_ticks ymain = np . linspace ( extent [ 2 ], extent [ 3 ], n_y ) else : raise ValueError ( \"one of variables interval, n_ticks, or ys must be defined. If you would like default gridlines, please use `ax.gridlines()`\" ) gl = ax . gridlines ( xlocs = xmain , ylocs = ymain , ** kwargs ) xin = xmain [( xmain >= view_extent [ 0 ]) & ( xmain <= view_extent [ 1 ])] yin = ymain [( ymain >= view_extent [ 2 ]) & ( ymain <= view_extent [ 3 ])] # set tick labels ax . set_xticks ( xin , crs = ccrs . PlateCarree ()) ax . set_yticks ( yin , crs = ccrs . PlateCarree ()) ax . set_xticklabels ( xin , rotation = xtick_rotation , ha = \"center\" ) ax . set_yticklabels ( yin , rotation = ytick_rotation , va = \"center\" ) ax . xaxis . set_major_formatter ( LONGITUDE_FORMATTER ) ax . yaxis . set_major_formatter ( LATITUDE_FORMATTER ) return add_layer ( ax , img_obj , dims = 1000 , region = None , cmap = None , vis_params = None ) Add an Earth Engine image to a cartopy plot. Parameters: Name Type Description Default img_obj ee.image.Image Earth Engine image result to plot. required ax cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes required cartopy GeoAxesSubplot object to add image overlay to required dims list | tuple | int dimensions to request earth engine result as [WIDTH,HEIGHT]. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Default None and infers dimesions 1000 region list | tuple geospatial region of the image to render in format [E,S,W,N]. By default, the whole image None cmap str string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key None vis_params dict visualization parameters as a dictionary. See https://developers.google.com/earth-engine/image_visualization for options None Returns: Type Description ax (cartopy.mpl.geoaxes.GeoAxesSubplot) cartopy GeoAxesSubplot object with Earth Engine results displayed Exceptions: Type Description ValueError If dims is not of type list, tuple, or int ValueError If imgObj is not of type ee.image.Image ValueError If ax if not of type cartopy.mpl.geoaxes.GeoAxesSubplot ' Source code in geemap/cartoee.py def add_layer ( ax , img_obj , dims = 1000 , region = None , cmap = None , vis_params = None ): \"\"\"Add an Earth Engine image to a cartopy plot. args: img_obj (ee.image.Image): Earth Engine image result to plot. ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to add image overlay to dims (list | tuple | int, optional): dimensions to request earth engine result as [WIDTH,HEIGHT]. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Default None and infers dimesions region (list | tuple, optional): geospatial region of the image to render in format [E,S,W,N]. By default, the whole image cmap (str, optional): string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key vis_params (dict, optional): visualization parameters as a dictionary. See https://developers.google.com/earth-engine/image_visualization for options returns: ax (cartopy.mpl.geoaxes.GeoAxesSubplot): cartopy GeoAxesSubplot object with Earth Engine results displayed raises: ValueError: If `dims` is not of type list, tuple, or int ValueError: If `imgObj` is not of type ee.image.Image ValueError: If `ax` if not of type cartopy.mpl.geoaxes.GeoAxesSubplot ' \"\"\" if type ( img_obj ) is not ee . image . Image : raise ValueError ( \"provided `img_obj` is not of type ee.Image\" ) if region is not None : map_region = ee . Geometry . Rectangle ( region ) . getInfo ()[ \"coordinates\" ] view_extent = ( region [ 0 ], region [ 2 ], region [ 1 ], region [ 3 ]) else : map_region = img_obj . geometry ( 100 ) . bounds () . getInfo ()[ \"coordinates\" ] # get the image bounds x , y = list ( zip ( * map_region [ 0 ])) view_extent = [ min ( x ), max ( x ), min ( y ), max ( y )] if type ( dims ) not in [ list , tuple , int ]: raise ValueError ( \"provided dims not of type list, tuple, or int\" ) if type ( ax ) not in [ GeoAxes , GeoAxesSubplot ]: raise ValueError ( \"provided axes not of type cartopy.mpl.geoaxes.GeoAxes \" \"or cartopy.mpl.geoaxes.GeoAxesSubplot\" ) args = { \"format\" : \"png\" } if region : args [ \"region\" ] = map_region if dims : args [ \"dimensions\" ] = dims if vis_params : keys = list ( vis_params . keys ()) if cmap and ( \"palette\" in keys ): raise KeyError ( \"cannot provide `palette` in vis_params if `cmap` is specified\" ) elif cmap : args [ \"palette\" ] = \",\" . join ( build_palette ( cmap )) else : pass args = { ** args , ** vis_params } url = img_obj . getThumbUrl ( args ) response = requests . get ( url ) if response . status_code != 200 : error = eval ( response . content )[ \"error\" ] raise requests . exceptions . HTTPError ( f \" { error } \" ) image = np . array ( Image . open ( BytesIO ( response . content ))) if image . shape [ - 1 ] == 2 : image = np . concatenate ( [ np . repeat ( image [:, :, 0 : 1 ], 3 , axis = 2 ), image [:, :, - 1 :]], axis = 2 ) ax . imshow ( np . squeeze ( image ), extent = view_extent , origin = \"upper\" , transform = ccrs . PlateCarree (), ) return bbox_to_extent ( bbox ) Helper function to reorder a list of coordinates from [W,S,E,N] to [W,E,S,N] Parameters: Name Type Description Default bbox list[float] list (or tuple) or coordinates in the order of [W,S,E,N] required Returns: Type Description extent (tuple[float]) tuple of coordinates in the order of [W,E,S,N] Source code in geemap/cartoee.py def bbox_to_extent ( bbox ): \"\"\"Helper function to reorder a list of coordinates from [W,S,E,N] to [W,E,S,N] args: bbox (list[float]): list (or tuple) or coordinates in the order of [W,S,E,N] returns: extent (tuple[float]): tuple of coordinates in the order of [W,E,S,N] \"\"\" return ( bbox [ 0 ], bbox [ 2 ], bbox [ 1 ], bbox [ 3 ]) build_palette ( cmap , n = 256 ) Creates hex color code palette from a matplotlib colormap Parameters: Name Type Description Default cmap str string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key required n int Number of hex color codes to create from colormap. Default is 256 256 Returns: Type Description palette (list[str]) list of hex color codes from matplotlib colormap for n intervals Source code in geemap/cartoee.py def build_palette ( cmap , n = 256 ): \"\"\"Creates hex color code palette from a matplotlib colormap args: cmap (str): string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key n (int, optional): Number of hex color codes to create from colormap. Default is 256 returns: palette (list[str]): list of hex color codes from matplotlib colormap for n intervals \"\"\" colormap = cm . get_cmap ( cmap , n ) vals = np . linspace ( 0 , 1 , n ) palette = list ( map ( lambda x : colors . rgb2hex ( colormap ( x )[: 3 ]), vals )) return palette check_dependencies () Helper function to check dependencies used for cartoee Dependencies not included in main geemap are: cartopy, PIL, and scipys Exceptions: Type Description Exception when conda is not found in path Exception when auto install fails to install/import packages Source code in geemap/cartoee.py def check_dependencies (): \"\"\"Helper function to check dependencies used for cartoee Dependencies not included in main geemap are: cartopy, PIL, and scipys raises: Exception: when conda is not found in path Exception: when auto install fails to install/import packages \"\"\" import importlib # check if conda in in path and available to use is_conda = os . path . exists ( os . path . join ( sys . prefix , \"conda-meta\" )) # raise error if conda not found if not is_conda : raise Exception ( \"Auto installation requires `conda`. Please install conda using the following instructions before use: https://docs.conda.io/projects/conda/en/latest/user-guide/install/\" ) # list of dependencies to check, ordered in decreasing complexity # i.e. cartopy install should install PIL dependencies = [ \"cartopy\" , \"pillow\" , \"scipy\" ] # loop through dependency list and check if we can import module # if not try to install # install fail will be silent to continue through others if there is a failure # correct install will be checked later for dependency in dependencies : try : # see if we can import mod = importlib . import_module ( dependency ) except ImportError : # change the dependency name if it is PIL # import vs install names are different for PIL... # dependency = dependency if dependency is not \"PIL\" else \"pillow\" # print info if not installed logging . info ( f \"The { dependency } package is not installed. Trying install...\" ) logging . info ( f \"Installing { dependency } ...\" ) # run the command cmd = f \"conda install -c conda-forge { dependency } -y\" proc = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) # send command out , err = proc . communicate () logging . info ( out . decode ()) # second pass through dependencies to check if everything was installed correctly failed = [] for dependency in dependencies : try : mod = importlib . import_module ( dependency ) except ImportError : # append failed imports failed . append ( dependency ) # check if there were any failed imports after trying install if len ( failed ) > 0 : failed_str = \",\" . join ( failed ) raise Exception ( f \"Auto installation failed...the following dependencies were not installed ' { failed_str } '\" ) else : logging . info ( \"All dependencies are successfully imported/installed!\" ) return get_map ( img_obj , proj = None , ** kwargs ) Wrapper function to create a new cartopy plot with project and adds Earth Engine image results Parameters: Name Type Description Default img_obj ee.Image Earth Engine image result to plot required proj cartopy.crs Cartopy projection that determines the projection of the resulting plot. By default uses an equirectangular projection, PlateCarree None **kwargs remaining keyword arguments are passed to addLayer() {} Returns: Type Description ax (cartopy.mpl.geoaxes.GeoAxesSubplot) cartopy GeoAxesSubplot object with Earth Engine results displayed Source code in geemap/cartoee.py def get_map ( img_obj , proj = None , ** kwargs ): \"\"\" Wrapper function to create a new cartopy plot with project and adds Earth Engine image results Args: img_obj (ee.Image): Earth Engine image result to plot proj (cartopy.crs, optional): Cartopy projection that determines the projection of the resulting plot. By default uses an equirectangular projection, PlateCarree **kwargs: remaining keyword arguments are passed to addLayer() Returns: ax (cartopy.mpl.geoaxes.GeoAxesSubplot): cartopy GeoAxesSubplot object with Earth Engine results displayed \"\"\" if proj is None : proj = ccrs . PlateCarree () ax = mpl . pyplot . axes ( projection = proj ) add_layer ( ax , img_obj , ** kwargs ) return ax pad_view ( ax , factor = 0.05 ) Function to pad area around the view extent of a map, used for visual appeal Parameters: Name Type Description Default ax cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes required cartopy GeoAxesSubplot object to pad view extent required factor float | list[float] factor to pad view extent accepts float [0-1] of a list of floats which will be interpreted at [xfactor, yfactor] 0.05 Source code in geemap/cartoee.py def pad_view ( ax , factor = 0.05 ): \"\"\"Function to pad area around the view extent of a map, used for visual appeal args: ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to pad view extent factor (float | list[float], optional): factor to pad view extent accepts float [0-1] of a list of floats which will be interpreted at [xfactor, yfactor] \"\"\" view_extent = ax . get_extent () if isinstance ( factor , Iterable ): xfactor , yfactor = factor else : xfactor , yfactor = factor , factor x_diff = view_extent [ 1 ] - view_extent [ 0 ] y_diff = view_extent [ 3 ] - view_extent [ 2 ] xmin = view_extent [ 0 ] - ( x_diff * xfactor ) xmax = view_extent [ 1 ] + ( x_diff * xfactor ) ymin = view_extent [ 2 ] - ( y_diff * yfactor ) ymax = view_extent [ 3 ] + ( y_diff * yfactor ) ax . set_ylim ( ymin , ymax ) ax . set_xlim ( xmin , xmax ) return","title":"cartoee module"},{"location":"cartoee/#cartoee-module","text":"","title":"cartoee module"},{"location":"cartoee/#geemap.cartoee","text":"","title":"geemap.cartoee"},{"location":"cartoee/#geemap.cartoee.add_colorbar","text":"Add a colorbar tp the map based on visualization parameters provided Parameters: Name Type Description Default ax cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes required cartopy GeoAxesSubplot object to add image overlay to required loc str string specifying the position None vis_params dict visualization parameters as a dictionary. See https://developers.google.com/earth-engine/image_visualization for options required **kwargs remaining keyword arguments are passed to colorbar() {} Exceptions: Type Description Warning If 'discrete' is true when \"palette\" key is not in visParams ValueError If ax is not of type cartopy.mpl.geoaxes.GeoAxesSubplot ValueError If 'cmap' or \"palette\" key in visParams is not provided ValueError If \"min\" in visParams is not of type scalar ValueError If \"max\" in visParams is not of type scalar ValueError If 'loc' or 'cax' keywords are not provided ValueError If 'loc' is not of type str or does not equal available options Source code in geemap/cartoee.py def add_colorbar ( ax , vis_params , loc = None , cmap = \"gray\" , discrete = False , label = None , ** kwargs ): \"\"\" Add a colorbar tp the map based on visualization parameters provided args: ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to add image overlay to loc (str, optional): string specifying the position vis_params (dict, optional): visualization parameters as a dictionary. See https://developers.google.com/earth-engine/image_visualization for options **kwargs: remaining keyword arguments are passed to colorbar() raises: Warning: If 'discrete' is true when \"palette\" key is not in visParams ValueError: If `ax` is not of type cartopy.mpl.geoaxes.GeoAxesSubplot ValueError: If 'cmap' or \"palette\" key in visParams is not provided ValueError: If \"min\" in visParams is not of type scalar ValueError: If \"max\" in visParams is not of type scalar ValueError: If 'loc' or 'cax' keywords are not provided ValueError: If 'loc' is not of type str or does not equal available options \"\"\" if type ( ax ) not in [ GeoAxes , GeoAxesSubplot ]: raise ValueError ( \"provided axes not of type cartopy.mpl.geoaxes.GeoAxes \" \"or cartopy.mpl.geoaxes.GeoAxesSubplot\" ) if loc : if ( type ( loc ) == str ) and ( loc in [ \"left\" , \"right\" , \"bottom\" , \"top\" ]): posOpts = { \"left\" : [ 0.01 , 0.25 , 0.02 , 0.5 ], \"right\" : [ 0.88 , 0.25 , 0.02 , 0.5 ], \"bottom\" : [ 0.25 , 0.15 , 0.5 , 0.02 ], \"top\" : [ 0.25 , 0.88 , 0.5 , 0.02 ], } cax = ax . figure . add_axes ( posOpts [ loc ]) if loc == \"left\" : mpl . pyplot . subplots_adjust ( left = 0.18 ) elif loc == \"right\" : mpl . pyplot . subplots_adjust ( right = 0.85 ) else : pass else : raise ValueError ( 'provided loc not of type str. options are \"left\", ' '\"top\", \"right\", or \"bottom\"' ) elif \"cax\" in kwargs : cax = kwargs [ \"cax\" ] kwargs = { key : kwargs [ key ] for key in kwargs . keys () if key != \"cax\" } else : raise ValueError ( \"loc or cax keywords must be specified\" ) vis_keys = list ( vis_params . keys ()) if vis_params : if \"min\" in vis_params : vmin = vis_params [ \"min\" ] if type ( vmin ) not in ( int , float ): raise ValueError ( \"provided min value not of scalar type\" ) else : vmin = 0 if \"max\" in vis_params : vmax = vis_params [ \"max\" ] if type ( vmax ) not in ( int , float ): raise ValueError ( \"provided max value not of scalar type\" ) else : vmax = 1 if \"opacity\" in vis_params : alpha = vis_params [ \"opacity\" ] if type ( alpha ) not in ( int , float ): raise ValueError ( \"provided opacity value of not type scalar\" ) elif \"alpha\" in kwargs : alpha = kwargs [ \"alpha\" ] else : alpha = 1 if cmap is not None : if discrete : warnings . warn ( 'discrete keyword used when \"palette\" key is ' \"supplied with visParams, creating a continuous \" \"colorbar...\" ) cmap = mpl . pyplot . get_cmap ( cmap ) norm = mpl . colors . Normalize ( vmin = vmin , vmax = vmax ) if \"palette\" in vis_keys : hexcodes = vis_params [ \"palette\" ] . split ( \",\" ) hexcodes = [ i if i [ 0 ] == \"#\" else \"#\" + i for i in hexcodes ] if discrete : cmap = mpl . colors . ListedColormap ( hexcodes ) vals = np . linspace ( vmin , vmax , cmap . N + 1 ) norm = mpl . colors . BoundaryNorm ( vals , cmap . N ) else : cmap = mpl . colors . LinearSegmentedColormap . from_list ( \"custom\" , hexcodes , N = 256 ) norm = mpl . colors . Normalize ( vmin = vmin , vmax = vmax ) cmap = cmap elif cmap is not None : if discrete : warnings . warn ( 'discrete keyword used when \"palette\" key is ' \"supplied with visParams, creating a continuous \" \"colorbar...\" ) cmap = mpl . pyplot . get_cmap ( cmap ) norm = mpl . colors . Normalize ( vmin = vmin , vmax = vmax ) else : raise ValueError ( 'cmap keyword or \"palette\" key in visParams must be provided' ) cb = mpl . colorbar . ColorbarBase ( cax , norm = norm , alpha = alpha , cmap = cmap , ** kwargs ) if \"bands\" in vis_keys : cb . set_label ( vis_params [ \"bands\" ]) elif label is not None : cb . set_label ( label ) return","title":"add_colorbar()"},{"location":"cartoee/#geemap.cartoee.add_gridlines","text":"Helper function to add gridlines and format ticks to map Parameters: Name Type Description Default ax cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes required cartopy GeoAxesSubplot object to add the gridlines to required interval float | list[float] float specifying an interval at which to create gridlines, units are decimal degrees. lists will be interpreted a [x_interval, y_interval]. default = None None n_ticks int | list[int] integer specifying number gridlines to create within map extent. lists will be interpreted a [nx, ny]. default = None None xs list list of x coordinates to create gridlines. default = None None ys list list of y coordinates to create gridlines. default = None None buffer_out boolean boolean option to buffer out the extent to insure coordinates created cover map extent. default=true True xtick_rotation str | float 'horizontal' ytick_rotation str | float 'horizontal' **kwargs remaining keyword arguments are passed to gridlines() {} Exceptions: Type Description ValueError if all interval, n_ticks, or (xs,ys) are set to None Source code in geemap/cartoee.py def add_gridlines ( ax , interval = None , n_ticks = None , xs = None , ys = None , buffer_out = True , xtick_rotation = \"horizontal\" , ytick_rotation = \"horizontal\" , ** kwargs , ): \"\"\"Helper function to add gridlines and format ticks to map args: ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to add the gridlines to interval (float | list[float], optional): float specifying an interval at which to create gridlines, units are decimal degrees. lists will be interpreted a [x_interval, y_interval]. default = None n_ticks (int | list[int], optional): integer specifying number gridlines to create within map extent. lists will be interpreted a [nx, ny]. default = None xs (list, optional): list of x coordinates to create gridlines. default = None ys (list, optional): list of y coordinates to create gridlines. default = None buffer_out (boolean, optional): boolean option to buffer out the extent to insure coordinates created cover map extent. default=true xtick_rotation (str | float, optional): ytick_rotation (str | float, optional): **kwargs: remaining keyword arguments are passed to gridlines() raises: ValueError: if all interval, n_ticks, or (xs,ys) are set to None \"\"\" view_extent = ax . get_extent () extent = view_extent if xs is not None : xmain = xs elif interval is not None : if isinstance ( interval , Iterable ): xspace = interval [ 0 ] else : xspace = interval if buffer_out : extent = _buffer_box ( extent , xspace ) xmain = np . arange ( extent [ 0 ], extent [ 1 ] + xspace , xspace ) elif n_ticks is not None : if isinstance ( n_ticks , Iterable ): n_x = n_ticks [ 0 ] else : n_x = n_ticks xmain = np . linspace ( extent [ 0 ], extent [ 1 ], n_x ) else : raise ValueError ( \"one of variables interval, n_ticks, or xs must be defined. If you would like default gridlines, please use `ax.gridlines()`\" ) if ys is not None : ymain = ys elif interval is not None : if isinstance ( interval , Iterable ): yspace = interval [ 1 ] else : yspace = interval if buffer_out : extent = _buffer_box ( extent , yspace ) ymain = np . arange ( extent [ 2 ], extent [ 3 ] + yspace , yspace ) elif n_ticks is not None : if isinstance ( n_ticks , Iterable ): n_y = n_ticks [ 1 ] else : n_y = n_ticks ymain = np . linspace ( extent [ 2 ], extent [ 3 ], n_y ) else : raise ValueError ( \"one of variables interval, n_ticks, or ys must be defined. If you would like default gridlines, please use `ax.gridlines()`\" ) gl = ax . gridlines ( xlocs = xmain , ylocs = ymain , ** kwargs ) xin = xmain [( xmain >= view_extent [ 0 ]) & ( xmain <= view_extent [ 1 ])] yin = ymain [( ymain >= view_extent [ 2 ]) & ( ymain <= view_extent [ 3 ])] # set tick labels ax . set_xticks ( xin , crs = ccrs . PlateCarree ()) ax . set_yticks ( yin , crs = ccrs . PlateCarree ()) ax . set_xticklabels ( xin , rotation = xtick_rotation , ha = \"center\" ) ax . set_yticklabels ( yin , rotation = ytick_rotation , va = \"center\" ) ax . xaxis . set_major_formatter ( LONGITUDE_FORMATTER ) ax . yaxis . set_major_formatter ( LATITUDE_FORMATTER ) return","title":"add_gridlines()"},{"location":"cartoee/#geemap.cartoee.add_layer","text":"Add an Earth Engine image to a cartopy plot. Parameters: Name Type Description Default img_obj ee.image.Image Earth Engine image result to plot. required ax cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes required cartopy GeoAxesSubplot object to add image overlay to required dims list | tuple | int dimensions to request earth engine result as [WIDTH,HEIGHT]. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Default None and infers dimesions 1000 region list | tuple geospatial region of the image to render in format [E,S,W,N]. By default, the whole image None cmap str string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key None vis_params dict visualization parameters as a dictionary. See https://developers.google.com/earth-engine/image_visualization for options None Returns: Type Description ax (cartopy.mpl.geoaxes.GeoAxesSubplot) cartopy GeoAxesSubplot object with Earth Engine results displayed Exceptions: Type Description ValueError If dims is not of type list, tuple, or int ValueError If imgObj is not of type ee.image.Image ValueError If ax if not of type cartopy.mpl.geoaxes.GeoAxesSubplot ' Source code in geemap/cartoee.py def add_layer ( ax , img_obj , dims = 1000 , region = None , cmap = None , vis_params = None ): \"\"\"Add an Earth Engine image to a cartopy plot. args: img_obj (ee.image.Image): Earth Engine image result to plot. ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to add image overlay to dims (list | tuple | int, optional): dimensions to request earth engine result as [WIDTH,HEIGHT]. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Default None and infers dimesions region (list | tuple, optional): geospatial region of the image to render in format [E,S,W,N]. By default, the whole image cmap (str, optional): string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key vis_params (dict, optional): visualization parameters as a dictionary. See https://developers.google.com/earth-engine/image_visualization for options returns: ax (cartopy.mpl.geoaxes.GeoAxesSubplot): cartopy GeoAxesSubplot object with Earth Engine results displayed raises: ValueError: If `dims` is not of type list, tuple, or int ValueError: If `imgObj` is not of type ee.image.Image ValueError: If `ax` if not of type cartopy.mpl.geoaxes.GeoAxesSubplot ' \"\"\" if type ( img_obj ) is not ee . image . Image : raise ValueError ( \"provided `img_obj` is not of type ee.Image\" ) if region is not None : map_region = ee . Geometry . Rectangle ( region ) . getInfo ()[ \"coordinates\" ] view_extent = ( region [ 0 ], region [ 2 ], region [ 1 ], region [ 3 ]) else : map_region = img_obj . geometry ( 100 ) . bounds () . getInfo ()[ \"coordinates\" ] # get the image bounds x , y = list ( zip ( * map_region [ 0 ])) view_extent = [ min ( x ), max ( x ), min ( y ), max ( y )] if type ( dims ) not in [ list , tuple , int ]: raise ValueError ( \"provided dims not of type list, tuple, or int\" ) if type ( ax ) not in [ GeoAxes , GeoAxesSubplot ]: raise ValueError ( \"provided axes not of type cartopy.mpl.geoaxes.GeoAxes \" \"or cartopy.mpl.geoaxes.GeoAxesSubplot\" ) args = { \"format\" : \"png\" } if region : args [ \"region\" ] = map_region if dims : args [ \"dimensions\" ] = dims if vis_params : keys = list ( vis_params . keys ()) if cmap and ( \"palette\" in keys ): raise KeyError ( \"cannot provide `palette` in vis_params if `cmap` is specified\" ) elif cmap : args [ \"palette\" ] = \",\" . join ( build_palette ( cmap )) else : pass args = { ** args , ** vis_params } url = img_obj . getThumbUrl ( args ) response = requests . get ( url ) if response . status_code != 200 : error = eval ( response . content )[ \"error\" ] raise requests . exceptions . HTTPError ( f \" { error } \" ) image = np . array ( Image . open ( BytesIO ( response . content ))) if image . shape [ - 1 ] == 2 : image = np . concatenate ( [ np . repeat ( image [:, :, 0 : 1 ], 3 , axis = 2 ), image [:, :, - 1 :]], axis = 2 ) ax . imshow ( np . squeeze ( image ), extent = view_extent , origin = \"upper\" , transform = ccrs . PlateCarree (), ) return","title":"add_layer()"},{"location":"cartoee/#geemap.cartoee.bbox_to_extent","text":"Helper function to reorder a list of coordinates from [W,S,E,N] to [W,E,S,N] Parameters: Name Type Description Default bbox list[float] list (or tuple) or coordinates in the order of [W,S,E,N] required Returns: Type Description extent (tuple[float]) tuple of coordinates in the order of [W,E,S,N] Source code in geemap/cartoee.py def bbox_to_extent ( bbox ): \"\"\"Helper function to reorder a list of coordinates from [W,S,E,N] to [W,E,S,N] args: bbox (list[float]): list (or tuple) or coordinates in the order of [W,S,E,N] returns: extent (tuple[float]): tuple of coordinates in the order of [W,E,S,N] \"\"\" return ( bbox [ 0 ], bbox [ 2 ], bbox [ 1 ], bbox [ 3 ])","title":"bbox_to_extent()"},{"location":"cartoee/#geemap.cartoee.build_palette","text":"Creates hex color code palette from a matplotlib colormap Parameters: Name Type Description Default cmap str string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key required n int Number of hex color codes to create from colormap. Default is 256 256 Returns: Type Description palette (list[str]) list of hex color codes from matplotlib colormap for n intervals Source code in geemap/cartoee.py def build_palette ( cmap , n = 256 ): \"\"\"Creates hex color code palette from a matplotlib colormap args: cmap (str): string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key n (int, optional): Number of hex color codes to create from colormap. Default is 256 returns: palette (list[str]): list of hex color codes from matplotlib colormap for n intervals \"\"\" colormap = cm . get_cmap ( cmap , n ) vals = np . linspace ( 0 , 1 , n ) palette = list ( map ( lambda x : colors . rgb2hex ( colormap ( x )[: 3 ]), vals )) return palette","title":"build_palette()"},{"location":"cartoee/#geemap.cartoee.check_dependencies","text":"Helper function to check dependencies used for cartoee Dependencies not included in main geemap are: cartopy, PIL, and scipys Exceptions: Type Description Exception when conda is not found in path Exception when auto install fails to install/import packages Source code in geemap/cartoee.py def check_dependencies (): \"\"\"Helper function to check dependencies used for cartoee Dependencies not included in main geemap are: cartopy, PIL, and scipys raises: Exception: when conda is not found in path Exception: when auto install fails to install/import packages \"\"\" import importlib # check if conda in in path and available to use is_conda = os . path . exists ( os . path . join ( sys . prefix , \"conda-meta\" )) # raise error if conda not found if not is_conda : raise Exception ( \"Auto installation requires `conda`. Please install conda using the following instructions before use: https://docs.conda.io/projects/conda/en/latest/user-guide/install/\" ) # list of dependencies to check, ordered in decreasing complexity # i.e. cartopy install should install PIL dependencies = [ \"cartopy\" , \"pillow\" , \"scipy\" ] # loop through dependency list and check if we can import module # if not try to install # install fail will be silent to continue through others if there is a failure # correct install will be checked later for dependency in dependencies : try : # see if we can import mod = importlib . import_module ( dependency ) except ImportError : # change the dependency name if it is PIL # import vs install names are different for PIL... # dependency = dependency if dependency is not \"PIL\" else \"pillow\" # print info if not installed logging . info ( f \"The { dependency } package is not installed. Trying install...\" ) logging . info ( f \"Installing { dependency } ...\" ) # run the command cmd = f \"conda install -c conda-forge { dependency } -y\" proc = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) # send command out , err = proc . communicate () logging . info ( out . decode ()) # second pass through dependencies to check if everything was installed correctly failed = [] for dependency in dependencies : try : mod = importlib . import_module ( dependency ) except ImportError : # append failed imports failed . append ( dependency ) # check if there were any failed imports after trying install if len ( failed ) > 0 : failed_str = \",\" . join ( failed ) raise Exception ( f \"Auto installation failed...the following dependencies were not installed ' { failed_str } '\" ) else : logging . info ( \"All dependencies are successfully imported/installed!\" ) return","title":"check_dependencies()"},{"location":"cartoee/#geemap.cartoee.get_map","text":"Wrapper function to create a new cartopy plot with project and adds Earth Engine image results Parameters: Name Type Description Default img_obj ee.Image Earth Engine image result to plot required proj cartopy.crs Cartopy projection that determines the projection of the resulting plot. By default uses an equirectangular projection, PlateCarree None **kwargs remaining keyword arguments are passed to addLayer() {} Returns: Type Description ax (cartopy.mpl.geoaxes.GeoAxesSubplot) cartopy GeoAxesSubplot object with Earth Engine results displayed Source code in geemap/cartoee.py def get_map ( img_obj , proj = None , ** kwargs ): \"\"\" Wrapper function to create a new cartopy plot with project and adds Earth Engine image results Args: img_obj (ee.Image): Earth Engine image result to plot proj (cartopy.crs, optional): Cartopy projection that determines the projection of the resulting plot. By default uses an equirectangular projection, PlateCarree **kwargs: remaining keyword arguments are passed to addLayer() Returns: ax (cartopy.mpl.geoaxes.GeoAxesSubplot): cartopy GeoAxesSubplot object with Earth Engine results displayed \"\"\" if proj is None : proj = ccrs . PlateCarree () ax = mpl . pyplot . axes ( projection = proj ) add_layer ( ax , img_obj , ** kwargs ) return ax","title":"get_map()"},{"location":"cartoee/#geemap.cartoee.pad_view","text":"Function to pad area around the view extent of a map, used for visual appeal Parameters: Name Type Description Default ax cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes required cartopy GeoAxesSubplot object to pad view extent required factor float | list[float] factor to pad view extent accepts float [0-1] of a list of floats which will be interpreted at [xfactor, yfactor] 0.05 Source code in geemap/cartoee.py def pad_view ( ax , factor = 0.05 ): \"\"\"Function to pad area around the view extent of a map, used for visual appeal args: ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to pad view extent factor (float | list[float], optional): factor to pad view extent accepts float [0-1] of a list of floats which will be interpreted at [xfactor, yfactor] \"\"\" view_extent = ax . get_extent () if isinstance ( factor , Iterable ): xfactor , yfactor = factor else : xfactor , yfactor = factor , factor x_diff = view_extent [ 1 ] - view_extent [ 0 ] y_diff = view_extent [ 3 ] - view_extent [ 2 ] xmin = view_extent [ 0 ] - ( x_diff * xfactor ) xmax = view_extent [ 1 ] + ( x_diff * xfactor ) ymin = view_extent [ 2 ] - ( y_diff * yfactor ) ymax = view_extent [ 3 ] + ( y_diff * yfactor ) ax . set_ylim ( ymin , ymax ) ax . set_xlim ( xmin , xmax ) return","title":"pad_view()"},{"location":"citations/","text":"Citations If you find geemap useful in your research, please consider citing the following papers to support my work. Thank you for your support. Wu, Q., (2020). geemap: A Python package for interactive mapping with Google Earth Engine. The Journal of Open Source Software, 5(51), 2305. https://doi.org/10.21105/joss.02305 Wu, Q., Lane, C. R., Li, X., Zhao, K., Zhou, Y., Clinton, N., DeVries, B., Golden, H. E., & Lang, M. W. (2019). Integrating LiDAR data and multi-temporal aerial imagery to map wetland inundation dynamics using Google Earth Engine. Remote Sensing of Environment, 228, 1-13. https://doi.org/10.1016/j.rse.2019.04.015 ( pdf | source code )","title":"Citations"},{"location":"citations/#citations","text":"If you find geemap useful in your research, please consider citing the following papers to support my work. Thank you for your support. Wu, Q., (2020). geemap: A Python package for interactive mapping with Google Earth Engine. The Journal of Open Source Software, 5(51), 2305. https://doi.org/10.21105/joss.02305 Wu, Q., Lane, C. R., Li, X., Zhao, K., Zhou, Y., Clinton, N., DeVries, B., Golden, H. E., & Lang, M. W. (2019). Integrating LiDAR data and multi-temporal aerial imagery to map wetland inundation dynamics using Google Earth Engine. Remote Sensing of Environment, 228, 1-13. https://doi.org/10.1016/j.rse.2019.04.015 ( pdf | source code )","title":"Citations"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs Report bugs at https://github.com/giswqs/geemap/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation geemap could always use more documentation, whether as part of the official geemap docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback The best way to send feedback is to file an issue at https://github.com/giswqs/geemap/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started Ready to contribute? Here's how to set up geemap for local development. Fork the geemap repo on GitHub. Clone your fork locally: git clone git@github.com:your_name_here/geemap.git Install your local copy into a conda env. Assuming you have conda installed, this is how you set up your fork for local development: conda create -n geemap-test python conda activate geemap-test cd geemap/ pip install -e . Create a branch for local development: git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox: flake8 geemap tests python setup.py test or pytest To get flake8 and tox, just pip install them into your conda env. Commit your changes and push your branch to GitHub: git add . git commit -m \"Your detailed description of your changes.\" git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6, 3.7 and 3.8, and for PyPy. Check https://github.com/giswqs/geemap/actions and make sure that the tests pass for all supported Python versions.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/giswqs/geemap/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"geemap could always use more documentation, whether as part of the official geemap docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/giswqs/geemap/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up geemap for local development. Fork the geemap repo on GitHub. Clone your fork locally: git clone git@github.com:your_name_here/geemap.git Install your local copy into a conda env. Assuming you have conda installed, this is how you set up your fork for local development: conda create -n geemap-test python conda activate geemap-test cd geemap/ pip install -e . Create a branch for local development: git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox: flake8 geemap tests python setup.py test or pytest To get flake8 and tox, just pip install them into your conda env. Commit your changes and push your branch to GitHub: git add . git commit -m \"Your detailed description of your changes.\" git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6, 3.7 and 3.8, and for PyPy. Check https://github.com/giswqs/geemap/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"conversion/","text":"conversion module Module for converting Google Earth Engine (GEE) JavaScripts to Python scripts and Jupyter notebooks. To convert a GEE JavaScript to Python script: js_to_python(in_file out_file) To convert all GEE JavaScripts in a folder recursively to Python scripts: js_to_python_dir(in_dir, out_dir) To convert a GEE Python script to Jupyter notebook: py_to_ipynb(in_file, template_file, out_file) To convert all GEE Python scripts in a folder recursively to Jupyter notebooks: py_to_ipynb_dir(in_dir, template_file, out_dir) To execute a Jupyter notebook and save output cells: execute_notebook(in_file) To execute all Jupyter notebooks in a folder recursively: execute_notebook_dir(in_dir) check_map_functions ( input_lines ) Extracts Earth Engine map function Parameters: Name Type Description Default input_lines list List of Earth Engine JavaScrips required Returns: Type Description list Output JavaScript with map function Source code in geemap/conversion.py def check_map_functions ( input_lines ): \"\"\"Extracts Earth Engine map function Args: input_lines (list): List of Earth Engine JavaScrips Returns: list: Output JavaScript with map function \"\"\" output_lines = [] for index , line in enumerate ( input_lines ): if ( '.map(function' in line ) or ( '.map (function' ) in line : bracket_index = line . index ( \"{\" ) matching_line_index , matching_char_index = find_matching_bracket ( input_lines , index , bracket_index ) func_start_index = line . index ( 'function' ) func_name = 'func_' + random_string () func_header = line [ func_start_index :] . replace ( 'function' , 'function ' + func_name ) output_lines . append ( ' \\n ' ) output_lines . append ( func_header ) for sub_index , tmp_line in enumerate ( input_lines [ index + 1 : matching_line_index ]): output_lines . append ( tmp_line ) input_lines [ index + 1 + sub_index ] = '' header_line = line [: func_start_index ] + func_name header_line = header_line . rstrip () func_footer = input_lines [ matching_line_index ][: matching_char_index + 1 ] output_lines . append ( func_footer ) footer_line = input_lines [ matching_line_index ][ matching_char_index + 1 :] . strip () if footer_line == ')' or footer_line == ');' : header_line = header_line + footer_line footer_line = '' input_lines [ matching_line_index ] = footer_line output_lines . append ( header_line ) output_lines . append ( footer_line ) else : output_lines . append ( line ) return output_lines convert_for_loop ( line ) Converts JavaScript for loop to Python for loop. Parameters: Name Type Description Default line str Input JavaScript for loop required Returns: Type Description str Converted Python for loop. Source code in geemap/conversion.py def convert_for_loop ( line ): \"\"\"Converts JavaScript for loop to Python for loop. Args: line (str): Input JavaScript for loop Returns: str: Converted Python for loop. \"\"\" new_line = '' if 'var ' in line : line = line . replace ( 'var ' , '' ) start_index = line . index ( '(' ) end_index = line . index ( ')' ) prefix = line [:( start_index )] suffix = line [( end_index + 1 ):] params = line [( start_index + 1 ): end_index ] if ' in ' in params and params . count ( ';' ) == 0 : new_line = prefix + ' {} :' . format ( params ) + suffix return new_line items = params . split ( '=' ) param_name = items [ 0 ] . strip () items = params . split ( ';' ) subitems = [] for item in items : subitems . append ( item . split ( ' ' )[ - 1 ]) start = subitems [ 0 ] end = subitems [ 1 ] step = subitems [ 2 ] if '++' in step : step = 1 elif '--' in step : step = - 1 prefix = line [:( start_index )] suffix = line [( end_index + 1 ):] new_line = prefix + \\ ' {} in range( {} , {} , {} ):' . format ( param_name , start , end , step ) + suffix return new_line create_new_cell ( contents , replace = False ) Create a new cell in Jupyter notebook based on the contents. Parameters: Name Type Description Default contents str A string of Python code. required Source code in geemap/conversion.py def create_new_cell ( contents , replace = False ): \"\"\"Create a new cell in Jupyter notebook based on the contents. Args: contents (str): A string of Python code. \"\"\" from IPython.core.getipython import get_ipython shell = get_ipython () shell . set_next_input ( contents , replace = replace ) download_from_gdrive ( gfile_url , file_name , out_dir = '.' , unzip = True ) Download a file shared via Google Drive (e.g., https://drive.google.com/file/d/18SUo_HcDGltuWYZs1s7PpOmOq_FvFn04/view?usp=sharing) Parameters: Name Type Description Default gfile_url str The Google Drive shared file URL required file_name str The output file name to use. required out_dir str The output directory. Defaults to '.'. '.' unzip bool Whether to unzip the output file if it is a zip file. Defaults to True. True Source code in geemap/conversion.py def download_from_gdrive ( gfile_url , file_name , out_dir = '.' , unzip = True ): \"\"\"Download a file shared via Google Drive (e.g., https://drive.google.com/file/d/18SUo_HcDGltuWYZs1s7PpOmOq_FvFn04/view?usp=sharing) Args: gfile_url (str): The Google Drive shared file URL file_name (str): The output file name to use. out_dir (str, optional): The output directory. Defaults to '.'. unzip (bool, optional): Whether to unzip the output file if it is a zip file. Defaults to True. \"\"\" try : from google_drive_downloader import GoogleDriveDownloader as gdd except ImportError : print ( 'GoogleDriveDownloader package not installed. Installing ...' ) subprocess . check_call ( [ \"python\" , '-m' , 'pip' , 'install' , 'googledrivedownloader' ]) from google_drive_downloader import GoogleDriveDownloader as gdd file_id = gfile_url . split ( '/' )[ 5 ] print ( 'Google Drive file id: {} ' . format ( file_id )) dest_path = os . path . join ( out_dir , file_name ) gdd . download_file_from_google_drive ( file_id , dest_path , True , unzip ) download_from_url ( url , out_file_name = None , out_dir = '.' , unzip = True ) Download a file from a URL (e.g., https://github.com/giswqs/whitebox/raw/master/examples/testdata.zip) Parameters: Name Type Description Default url str The HTTP URL to download. required out_file_name str The output file name to use. Defaults to None. None out_dir str The output directory to use. Defaults to '.'. '.' unzip bool Whether to unzip the downloaded file if it is a zip file. Defaults to True. True Source code in geemap/conversion.py def download_from_url ( url , out_file_name = None , out_dir = '.' , unzip = True ): \"\"\"Download a file from a URL (e.g., https://github.com/giswqs/whitebox/raw/master/examples/testdata.zip) Args: url (str): The HTTP URL to download. out_file_name (str, optional): The output file name to use. Defaults to None. out_dir (str, optional): The output directory to use. Defaults to '.'. unzip (bool, optional): Whether to unzip the downloaded file if it is a zip file. Defaults to True. \"\"\" in_file_name = os . path . basename ( url ) if out_file_name is None : out_file_name = in_file_name out_file_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name ) print ( 'Downloading {} ...' . format ( url )) try : urllib . request . urlretrieve ( url , out_file_path ) except : print ( \"The URL is invalid. Please double check the URL.\" ) return final_path = out_file_path if unzip : # if it is a zip file if '.zip' in out_file_name : print ( \"Unzipping {} ...\" . format ( out_file_name )) with zipfile . ZipFile ( out_file_path , \"r\" ) as zip_ref : zip_ref . extractall ( out_dir ) final_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name . replace ( '.zip' , '' )) # if it is a tar file if '.tar' in out_file_name : print ( \"Unzipping {} ...\" . format ( out_file_name )) with tarfile . open ( out_file_path , \"r\" ) as tar_ref : tar_ref . extractall ( out_dir ) final_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name . replace ( '.tart' , '' )) print ( 'Data downloaded to: {} ' . format ( final_path )) download_gee_app ( url , out_file = None ) Downloads JavaScript source code from a GEE App Parameters: Name Type Description Default url str The URL of the GEE App. required out_file str The output file path for the downloaded JavaScript. Defaults to None. None Source code in geemap/conversion.py def download_gee_app ( url , out_file = None ): \"\"\"Downloads JavaScript source code from a GEE App Args: url (str): The URL of the GEE App. out_file (str, optional): The output file path for the downloaded JavaScript. Defaults to None. \"\"\" cwd = os . getcwd () out_file_name = os . path . basename ( url ) + '.js' out_file_path = os . path . join ( cwd , out_file_name ) items = url . split ( '/' ) items [ 3 ] = 'javascript' items [ 4 ] = items [ 4 ] + '-modules.json' json_url = '/' . join ( items ) print ( 'The json url: {} ' . format ( json_url )) if out_file is not None : out_file_path = out_file if not out_file_path . endswith ( 'js' ): out_file_path += '.js' out_dir = os . path . dirname ( out_file_path ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) json_path = out_file_path + 'on' try : urllib . request . urlretrieve ( json_url , json_path ) except : print ( \"The URL is invalid. Please double check the URL.\" ) return with open ( out_file_path , 'w' ) as f1 : with open ( json_path ) as f2 : lines = f2 . readlines () for line in lines : # print(line) items = line . split ( ' \\\\ n' ) for index , item in enumerate ( items ): if ( index > 0 ) and ( index < ( len ( items ) - 1 )): item = item . replace ( ' \\\\ \"' , '\"' ) item = item . replace ( r ' \\\\ ' , ' \\n ' ) item = item . replace ( ' \\\\ r' , '' ) f1 . write ( item + ' \\n ' ) os . remove ( json_path ) print ( 'The JavaScript is saved at: {} ' . format ( out_file_path )) execute_notebook ( in_file ) Executes a Jupyter notebook and save output cells Parameters: Name Type Description Default in_file str Input Jupyter notebook. required Source code in geemap/conversion.py def execute_notebook ( in_file ): \"\"\"Executes a Jupyter notebook and save output cells Args: in_file (str): Input Jupyter notebook. \"\"\" # command = 'jupyter nbconvert --to notebook --execute ' + in_file + ' --inplace' command = 'jupyter nbconvert --to notebook --execute \" {} \" --inplace' . format ( in_file ) print ( os . popen ( command ) . read () . rstrip ()) execute_notebook_dir ( in_dir ) Executes all Jupyter notebooks in the given directory recursively and save output cells. Parameters: Name Type Description Default in_dir str Input folder containing notebooks. required Source code in geemap/conversion.py def execute_notebook_dir ( in_dir ): \"\"\"Executes all Jupyter notebooks in the given directory recursively and save output cells. Args: in_dir (str): Input folder containing notebooks. \"\"\" print ( 'Executing Earth Engine Jupyter notebooks ... \\n ' ) in_dir = os . path . abspath ( in_dir ) files = list ( Path ( in_dir ) . rglob ( '*.ipynb' )) count = len ( files ) if files is not None : for index , file in enumerate ( files ): in_file = str ( file ) print ( 'Processing {} / {} : {} ...' . format ( index + 1 , count , file )) execute_notebook ( in_file ) find_matching_bracket ( lines , start_line_index , start_char_index , matching_char = '{' ) Finds the position of the matching closing bracket from a list of lines. Parameters: Name Type Description Default lines list The input list of lines. required start_line_index int The line index where the starting bracket is located. required start_char_index int The position index of the starting bracket. required matching_char str The starting bracket to search for. Defaults to '{'. '{' Returns: Type Description matching_line_index (int) The line index where the matching closing bracket is located. matching_char_index (int): The position index of the matching closing bracket. Source code in geemap/conversion.py def find_matching_bracket ( lines , start_line_index , start_char_index , matching_char = '{' ): \"\"\"Finds the position of the matching closing bracket from a list of lines. Args: lines (list): The input list of lines. start_line_index (int): The line index where the starting bracket is located. start_char_index (int): The position index of the starting bracket. matching_char (str, optional): The starting bracket to search for. Defaults to '{'. Returns: matching_line_index (int): The line index where the matching closing bracket is located. matching_char_index (int): The position index of the matching closing bracket. \"\"\" matching_line_index = - 1 matching_char_index = - 1 matching_chars = { '{' : '}' , '(' : ')' , '[' : ']' } if matching_char not in matching_chars . keys (): print ( \"The matching character must be one of the following: {} \" . format ( ', ' . join ( matching_chars . keys ()))) return matching_line_index , matching_char_index # Create a deque to use it as a stack. d = deque () for line_index in range ( start_line_index , len ( lines )): line = lines [ line_index ] # deal with the line where the starting bracket is located. if line_index == start_line_index : line = lines [ line_index ][ start_char_index :] for index , item in enumerate ( line ): # Pops a starting bracket for each closing bracket if item == matching_chars [ matching_char ]: d . popleft () # Push all starting brackets elif item == matching_char : d . append ( matching_char ) # If deque becomes empty if not d : matching_line_index = line_index if line_index == start_line_index : matching_char_index = start_char_index + index else : matching_char_index = index return matching_line_index , matching_char_index return matching_line_index , matching_char_index format_params ( line , sep = ':' ) Formats keys in a dictionary and adds quotes to the keys. For example, {min: 0, max: 10} will result in ('min': 0, 'max': 10) Parameters: Name Type Description Default line str A string. required sep str Separator. Defaults to ':'. ':' Returns: Type Description [str] A string with keys quoted Source code in geemap/conversion.py def format_params ( line , sep = ':' ): \"\"\"Formats keys in a dictionary and adds quotes to the keys. For example, {min: 0, max: 10} will result in ('min': 0, 'max': 10) Args: line (str): A string. sep (str, optional): Separator. Defaults to ':'. Returns: [str]: A string with keys quoted \"\"\" # print(line) new_line = line prefix = \"\" suffix = \"\" if line . strip () . startswith ( 'for' ): # skip for loop return line # find all occurrences of a substring def find_all ( a_str , sub ): start = 0 while True : start = a_str . find ( sub , start ) if start == - 1 : return yield start start += len ( sub ) # use start += 1 to find overlapping matches indices = list ( find_all ( line , sep )) count = len ( indices ) if \"{\" in line : bracket_index = line . index ( \"{\" ) if bracket_index < indices [ 0 ]: prefix = line [: bracket_index + 1 ] line = line [ bracket_index + 1 :] if count > 0 : items = line . split ( sep ) if count == 1 : for i in range ( 0 , count ): item = items [ i ] . strip () if ( '\"' not in item ) and ( \"'\" not in item ): new_item = \"'\" + item + \"'\" items [ i ] = items [ i ] . replace ( item , new_item ) new_line = ':' . join ( items ) elif count > 1 : for i in range ( 0 , count ): item = items [ i ] if ',' in item : subitems = item . split ( ',' ) subitem = subitems [ - 1 ] if ( '\"' not in subitem ) and ( \"'\" not in subitem ): new_subitem = \"'\" + subitem . strip () + \"'\" subitems [ - 1 ] = subitems [ - 1 ] . replace ( subitem , new_subitem ) items [ i ] = ', ' . join ( subitems ) else : if ( '\"' not in item ) and ( \"'\" not in item ): new_item = \"'\" + item . strip () + \"'\" padding = len ( item ) - len ( item . strip ()) items [ i ] = \" \" * padding + item . replace ( item , new_item ) new_line = ':' . join ( items ) return prefix + new_line get_js_examples ( out_dir = None ) Gets Earth Engine JavaScript examples from the geemap package. Parameters: Name Type Description Default out_dir str The folder to copy the JavaScript examples to. Defaults to None. None Returns: Type Description str The folder containing the JavaScript examples. Source code in geemap/conversion.py def get_js_examples ( out_dir = None ): \"\"\"Gets Earth Engine JavaScript examples from the geemap package. Args: out_dir (str, optional): The folder to copy the JavaScript examples to. Defaults to None. Returns: str: The folder containing the JavaScript examples. \"\"\" pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) example_dir = os . path . join ( pkg_dir , 'data' ) js_dir = os . path . join ( example_dir , 'javascripts' ) files = list ( Path ( js_dir ) . rglob ( '*.js' )) if out_dir is None : out_dir = js_dir else : if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) for file in files : basename = os . path . basename ( file ) out_path = os . path . join ( out_dir , basename ) shutil . copyfile ( file , out_path ) return out_dir get_nb_template ( download_latest = False , out_file = None ) Get the Earth Engine Jupyter notebook template. Parameters: Name Type Description Default download_latest bool If True, downloads the latest notebook template from GitHub. Defaults to False. False out_file str Set the output file path of the notebook template. Defaults to None. None Returns: Type Description str The file path of the template. Source code in geemap/conversion.py def get_nb_template ( download_latest = False , out_file = None ): \"\"\"Get the Earth Engine Jupyter notebook template. Args: download_latest (bool, optional): If True, downloads the latest notebook template from GitHub. Defaults to False. out_file (str, optional): Set the output file path of the notebook template. Defaults to None. Returns: str: The file path of the template. \"\"\" pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) example_dir = os . path . join ( pkg_dir , 'data' ) template_dir = os . path . join ( example_dir , 'template' ) template_file = os . path . join ( template_dir , 'template.py' ) if out_file is None : out_file = template_file return out_file if not out_file . endswith ( '.py' ): out_file = out_file + '.py' if not os . path . exists ( os . path . dirname ( out_file )): os . makedirs ( os . path . dirname ( out_file )) if download_latest : template_url = 'https://raw.githubusercontent.com/giswqs/geemap/master/examples/template/template.py' print ( \"Downloading the latest notebook template from {} \" . format ( template_url )) urllib . request . urlretrieve ( template_url , out_file ) elif out_file is not None : shutil . copyfile ( template_file , out_file ) return out_file js_snippet_to_py ( in_js_snippet , add_new_cell = True , import_ee = True , import_geemap = True , show_map = True ) Converts an Earth Engine JavaScript snippet wrapped in triple quotes to Python directly on a Jupyter notebook. Parameters: Name Type Description Default in_js_snippet str Earth Engine JavaScript within triple quotes. required add_new_cell bool Whether add the converted Python to a new cell. True import_ee bool Whether to import ee. Defaults to True. True import_geemap bool Whether to import geemap. Defaults to True. True show_map bool Whether to show the map. Defaults to True. True Returns: Type Description list A list of Python script. Source code in geemap/conversion.py def js_snippet_to_py ( in_js_snippet , add_new_cell = True , import_ee = True , import_geemap = True , show_map = True ): \"\"\"Converts an Earth Engine JavaScript snippet wrapped in triple quotes to Python directly on a Jupyter notebook. Args: in_js_snippet (str): Earth Engine JavaScript within triple quotes. add_new_cell (bool, optional): Whether add the converted Python to a new cell. import_ee (bool, optional): Whether to import ee. Defaults to True. import_geemap (bool, optional): Whether to import geemap. Defaults to True. show_map (bool, optional): Whether to show the map. Defaults to True. Returns: list: A list of Python script. \"\"\" work_dir = os . path . expanduser ( \"~\" ) in_js = os . path . join ( work_dir , 'tmp_js_snippet.js' ) out_py = os . path . join ( work_dir , 'tmp_py_snippet.py' ) try : with open ( in_js , 'w' ) as f : f . write ( in_js_snippet ) js_to_python ( in_js , out_file = out_py , use_qgis = False ) out_lines = [] if import_ee : out_lines . append ( 'import ee \\n ' ) if import_geemap : out_lines . append ( 'import geemap \\n\\n ' ) out_lines . append ( 'Map = geemap.Map() \\n ' ) if import_ee : out_lines . append ( 'ee.Initialize() \\n ' ) with open ( out_py ) as f : lines = f . readlines () for index , line in enumerate ( lines ): if index < ( len ( lines ) - 1 ): if line . strip () == 'import ee' : continue # elif import_ee and (line.strip() == 'import ee'): # out_lines.append(line) # out_lines.append('ee.Initialize()\\n') # continue next_line = lines [ index + 1 ] if line . strip () == '' and next_line . strip () == '' : continue else : out_lines . append ( line ) elif index == ( len ( lines ) - 1 ) and lines [ index ] . strip () != '' : out_lines . append ( line ) if show_map : out_lines . append ( 'Map \\n ' ) os . remove ( in_js ) os . remove ( out_py ) if add_new_cell : contents = '' . join ( out_lines ) create_new_cell ( contents ) else : return out_lines except Exception as e : print ( e ) js_to_python ( in_file , out_file = None , use_qgis = True , github_repo = None ) Converts an Earth Engine JavaScript to Python script. !!! args in_file (str): File path of the input JavaScript. out_file (str, optional): File path of the output Python script. Defaults to None. use_qgis (bool, optional): Whether to add \"from ee_plugin import Map \" to the output script. Defaults to True. github_repo (str, optional): GitHub repo url. Defaults to None. !!! returns list : Python script Source code in geemap/conversion.py def js_to_python ( in_file , out_file = None , use_qgis = True , github_repo = None ): \"\"\"Converts an Earth Engine JavaScript to Python script. Args: in_file (str): File path of the input JavaScript. out_file (str, optional): File path of the output Python script. Defaults to None. use_qgis (bool, optional): Whether to add \"from ee_plugin import Map \\n\" to the output script. Defaults to True. github_repo (str, optional): GitHub repo url. Defaults to None. Returns: list : Python script \"\"\" in_file = os . path . abspath ( in_file ) if out_file is None : out_file = in_file . replace ( \".js\" , \".py\" ) root_dir = os . path . dirname ( os . path . abspath ( __file__ )) if not os . path . isfile ( in_file ): in_file = os . path . join ( root_dir , in_file ) if not os . path . isfile ( out_file ): out_file = os . path . join ( root_dir , out_file ) is_python = False add_github_url = False qgis_import_str = '' if use_qgis : qgis_import_str = \"from ee_plugin import Map \\n \" github_url = \"\" if github_repo is not None : github_url = \"# GitHub URL: \" + github_repo + in_file + \" \\n\\n \" math_import = False math_import_str = \"\" lines = [] with open ( in_file ) as f : lines = f . readlines () math_import = use_math ( lines ) for line in lines : line = line . strip () if line == 'import ee' : is_python = True if math_import : math_import_str = \"import math \\n \" output = \"\" if is_python : # only update the GitHub URL if it is already a GEE Python script output = github_url + '' . join ( map ( str , lines )) else : # deal with JavaScript header = github_url + \"import ee \\n \" + qgis_import_str + math_import_str function_defs = [] output = header + \" \\n \" with open ( in_file ) as f : lines = f . readlines () # print('Processing {}'.format(in_file)) lines = check_map_functions ( lines ) for index , line in enumerate ( lines ): if ( '/* color' in line ) and ( '*/' in line ): line = line [: line . index ( '/*' )] . lstrip () + \\ line [( line . index ( '*/' ) + 2 ):] if ( \"= function\" in line ) or ( \"=function\" in line ) or line . strip () . startswith ( \"function\" ): bracket_index = line . index ( \"{\" ) matching_line_index , matching_char_index = find_matching_bracket ( lines , index , bracket_index ) line = line [: bracket_index ] + line [ bracket_index + 1 :] if matching_line_index == index : line = line [: matching_char_index ] + \\ line [ matching_char_index + 1 :] else : tmp_line = lines [ matching_line_index ] lines [ matching_line_index ] = tmp_line [: matching_char_index ] + \\ tmp_line [ matching_char_index + 1 :] line = line . replace ( \" = function\" , \"\" ) . replace ( \"=function\" , '' ) . replace ( \"function \" , '' ) if line . lstrip () . startswith ( '//' ): line = line . replace ( '//' , '' ) . lstrip () line = \" \" * ( len ( line ) - len ( line . lstrip ()) ) + \"# def \" + line . strip () + \":\" else : line = \" \" * ( len ( line ) - len ( line . lstrip ()) ) + \"def \" + line . strip () + \":\" elif \"{\" in line : bracket_index = line . index ( \"{\" ) matching_line_index , matching_char_index = find_matching_bracket ( lines , index , bracket_index ) if ( matching_line_index == index ) and ( ':' in line ): pass elif ( 'for (' in line ) or ( 'for(' in line ): line = convert_for_loop ( line ) lines [ index ] = line bracket_index = line . index ( \"{\" ) matching_line_index , matching_char_index = find_matching_bracket ( lines , index , bracket_index ) tmp_line = lines [ matching_line_index ] lines [ matching_line_index ] = tmp_line [: matching_char_index ] + \\ tmp_line [ matching_char_index + 1 :] line = line . replace ( '{' , '' ) if line is None : line = '' line = line . replace ( \"//\" , \"#\" ) line = line . replace ( \"var \" , \"\" , 1 ) line = line . replace ( \"/*\" , '#' ) line = line . replace ( \"*/\" , '#' ) line = line . replace ( \"true\" , \"True\" ) . replace ( \"false\" , \"False\" ) line = line . replace ( \"null\" , \" {} \" ) line = line . replace ( \".or\" , \".Or\" ) line = line . replace ( \".and\" , '.And' ) line = line . replace ( \".not\" , '.Not' ) line = line . replace ( 'visualize({' , 'visualize(**{' ) line = line . replace ( 'Math.PI' , 'math.pi' ) line = line . replace ( 'Math.' , 'math.' ) line = line . replace ( '= new' , '=' ) line = line . rstrip () if line . endswith ( \"+\" ): line = line + \" \\\\ \" elif line . endswith ( \";\" ): line = line [: - 1 ] if line . lstrip () . startswith ( '*' ): line = line . replace ( '*' , '#' ) if ( \":\" in line ) and ( not line . strip () . startswith ( \"#\" )) and ( not line . strip () . startswith ( 'def' )) and ( not line . strip () . startswith ( \".\" )): line = format_params ( line ) if index < ( len ( lines ) - 1 ) and line . lstrip () . startswith ( \"#\" ) and lines [ index + 1 ] . lstrip () . startswith ( \".\" ): line = '' if line . lstrip () . startswith ( \".\" ): if \"#\" in line : line = line [: line . index ( \"#\" )] output = output . rstrip () + \" \" + \" \\\\ \" + \" \\n \" + line + \" \\n \" else : output += line + \" \\n \" out_dir = os . path . dirname ( out_file ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) with open ( out_file , 'w' ) as f : f . write ( output ) return output js_to_python_dir ( in_dir , out_dir = None , use_qgis = True , github_repo = None ) Converts all Earth Engine JavaScripts in a folder recursively to Python scripts. !!! args in_dir (str): The input folder containing Earth Engine JavaScripts. out_dir (str, optional): The output folder containing Earth Engine Python scripts. Defaults to None. use_qgis (bool, optional): Whether to add \"from ee_plugin import Map \" to the output script. Defaults to True. github_repo (str, optional): GitHub repo url. Defaults to None. Source code in geemap/conversion.py def js_to_python_dir ( in_dir , out_dir = None , use_qgis = True , github_repo = None ): \"\"\"Converts all Earth Engine JavaScripts in a folder recursively to Python scripts. Args: in_dir (str): The input folder containing Earth Engine JavaScripts. out_dir (str, optional): The output folder containing Earth Engine Python scripts. Defaults to None. use_qgis (bool, optional): Whether to add \"from ee_plugin import Map \\n\" to the output script. Defaults to True. github_repo (str, optional): GitHub repo url. Defaults to None. \"\"\" print ( 'Converting Earth Engine JavaScripts to Python scripts... \\n ' ) in_dir = os . path . abspath ( in_dir ) if out_dir is None : out_dir = in_dir elif not os . path . exists ( out_dir ): out_dir = os . path . abspath ( out_dir ) os . makedirs ( out_dir ) else : out_dir = os . path . abspath ( out_dir ) files = list ( Path ( in_dir ) . rglob ( '*.js' )) for index , in_file in enumerate ( files ): print ( 'Processing {} / {} : {} ' . format ( index + 1 , len ( files ), in_file )) out_file = os . path . splitext ( in_file )[ 0 ] + \"_qgis.py\" out_file = out_file . replace ( in_dir , out_dir ) js_to_python ( in_file , out_file , use_qgis , github_repo ) py_to_ipynb ( in_file , template_file , out_file = None , github_username = None , github_repo = None ) Converts Earth Engine Python script to Jupyter notebook. Parameters: Name Type Description Default in_file str Input Earth Engine Python script. required template_file str Input Jupyter notebook template. required out_file str Output Jupyter notebook. None github_username str GitHub username. Defaults to None. None github_repo str GitHub repo name. Defaults to None. None Source code in geemap/conversion.py def py_to_ipynb ( in_file , template_file , out_file = None , github_username = None , github_repo = None ): \"\"\"Converts Earth Engine Python script to Jupyter notebook. Args: in_file (str): Input Earth Engine Python script. template_file (str): Input Jupyter notebook template. out_file (str, optional)): Output Jupyter notebook. github_username (str, optional): GitHub username. Defaults to None. github_repo (str, optional): GitHub repo name. Defaults to None. \"\"\" in_file = os . path . abspath ( in_file ) if out_file is None : out_file = os . path . splitext ( in_file )[ 0 ] . replace ( '_qgis' , '' ) + '.ipynb' out_py_file = os . path . splitext ( out_file )[ 0 ] + '.py' out_dir = os . path . dirname ( out_file ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) if out_dir == os . path . dirname ( in_file ): out_py_file = os . path . splitext ( out_file )[ 0 ] + '.py' content = remove_qgis_import ( in_file ) header = template_header ( template_file ) footer = template_footer ( template_file ) if ( github_username is not None ) and ( github_repo is not None ): out_py_path = str ( out_file ) . split ( '/' ) index = out_py_path . index ( github_repo ) out_py_relative_path = '/' . join ( out_py_path [ index + 1 :]) out_ipynb_relative_path = out_py_relative_path . replace ( '.py' , '.ipynb' ) new_header = [] for index , line in enumerate ( header ): if index < 9 : # Change Google Colab and binder URLs line = line . replace ( 'giswqs' , github_username ) line = line . replace ( 'geemap' , github_repo ) line = line . replace ( 'examples/template/template.ipynb' , out_ipynb_relative_path ) new_header . append ( line ) header = new_header if content != None : out_text = header + content + footer else : out_text = header + footer if not os . path . exists ( os . path . dirname ( out_py_file )): os . makedirs ( os . path . dirname ( out_py_file )) with open ( out_py_file , 'w' ) as f : f . writelines ( out_text ) try : # command = 'ipynb-py-convert ' + out_py_file + ' ' + out_file command = 'ipynb-py-convert \" {} \" \" {} \"' . format ( out_py_file , out_file ) print ( os . popen ( command ) . read () . rstrip ()) # os.popen(command) except : print ( 'Please install ipynb-py-convert using the following command: \\n ' ) print ( 'pip install ipynb-py-convert' ) py_to_ipynb_dir ( in_dir , template_file , out_dir = None , github_username = None , github_repo = None ) Converts Earth Engine Python scripts in a folder recursively to Jupyter notebooks. Parameters: Name Type Description Default in_dir str Input folder containing Earth Engine Python scripts. required template_file str Input jupyter notebook template file. required out_dir str Output folder. Defaults to None. None github_username str GitHub username. Defaults to None. None github_repo str GitHub repo name. Defaults to None. None Source code in geemap/conversion.py def py_to_ipynb_dir ( in_dir , template_file , out_dir = None , github_username = None , github_repo = None ): \"\"\"Converts Earth Engine Python scripts in a folder recursively to Jupyter notebooks. Args: in_dir (str): Input folder containing Earth Engine Python scripts. template_file (str): Input jupyter notebook template file. out_dir str, optional): Output folder. Defaults to None. github_username (str, optional): GitHub username. Defaults to None. github_repo (str, optional): GitHub repo name. Defaults to None. \"\"\" print ( 'Converting Earth Engine Python scripts to Jupyter notebooks ... \\n ' ) in_dir = os . path . abspath ( in_dir ) files = [] qgis_files = list ( Path ( in_dir ) . rglob ( '*_qgis.py' )) py_files = list ( Path ( in_dir ) . rglob ( '*.py' )) if len ( qgis_files ) == len ( py_files ) / 2 : files = qgis_files else : files = py_files if out_dir is None : out_dir = in_dir elif not os . path . exists ( out_dir ): out_dir = os . path . abspath ( out_dir ) os . makedirs ( out_dir ) else : out_dir = os . path . abspath ( out_dir ) for index , file in enumerate ( files ): in_file = str ( file ) out_file = in_file . replace ( in_dir , out_dir ) . replace ( '_qgis' , '' ) . replace ( '.py' , '.ipynb' ) print ( 'Processing {} / {} : {} ' . format ( index + 1 , len ( files ), in_file )) py_to_ipynb ( in_file , template_file , out_file , github_username , github_repo ) random_string ( string_length = 3 ) Generates a random string of fixed length. Parameters: Name Type Description Default string_length int Fixed length. Defaults to 3. 3 Returns: Type Description str A random string Source code in geemap/conversion.py def random_string ( string_length = 3 ): \"\"\"Generates a random string of fixed length. Args: string_length (int, optional): Fixed length. Defaults to 3. Returns: str: A random string \"\"\" # random.seed(1001) letters = string . ascii_lowercase return '' . join ( random . choice ( letters ) for i in range ( string_length )) remove_qgis_import ( in_file ) Removes 'from ee_plugin import Map' from an Earth Engine Python script. Parameters: Name Type Description Default in_file str Input file path of the Python script. required Returns: Type Description list List of lines 'from ee_plugin import Map' removed. Source code in geemap/conversion.py def remove_qgis_import ( in_file ): \"\"\"Removes 'from ee_plugin import Map' from an Earth Engine Python script. Args: in_file (str): Input file path of the Python script. Returns: list: List of lines 'from ee_plugin import Map' removed. \"\"\" in_file = os . path . abspath ( in_file ) start_index = 0 with open ( in_file ) as f : lines = f . readlines () for index , line in enumerate ( lines ): if 'from ee_plugin import Map' in line : start_index = index i = 1 while True : line_tmp = lines [ start_index + i ] . strip () if line_tmp != '' : return lines [ start_index + i :] else : i = i + 1 template_footer ( in_template ) Extracts footer from the notebook template. Parameters: Name Type Description Default in_template str Input notebook template file path. required Returns: Type Description list List of lines. Source code in geemap/conversion.py def template_footer ( in_template ): \"\"\"Extracts footer from the notebook template. Args: in_template (str): Input notebook template file path. Returns: list: List of lines. \"\"\" footer = [] template_lines = [] footer_start_index = 0 with open ( in_template ) as f : template_lines = f . readlines () for index , line in enumerate ( template_lines ): if '## Display Earth Engine data layers' in line : footer_start_index = index - 3 footer = [ ' \\n ' ] + template_lines [ footer_start_index :] return footer template_header ( in_template ) Extracts header from the notebook template. Parameters: Name Type Description Default in_template str Input notebook template file path. required Returns: Type Description list List of lines. Source code in geemap/conversion.py def template_header ( in_template ): \"\"\"Extracts header from the notebook template. Args: in_template (str): Input notebook template file path. Returns: list: List of lines. \"\"\" header = [] template_lines = [] header_end_index = 0 with open ( in_template ) as f : template_lines = f . readlines () for index , line in enumerate ( template_lines ): if '## Add Earth Engine Python script' in line : header_end_index = index + 5 header = template_lines [: header_end_index ] return header update_nb_header ( in_file , github_username = None , github_repo = None ) Updates notebook header (binder and Google Colab URLs). Parameters: Name Type Description Default in_file str The input Jupyter notebook. required github_username str GitHub username. Defaults to None. None github_repo str GitHub repo name. Defaults to None. None Source code in geemap/conversion.py def update_nb_header ( in_file , github_username = None , github_repo = None ): \"\"\"Updates notebook header (binder and Google Colab URLs). Args: in_file (str): The input Jupyter notebook. github_username (str, optional): GitHub username. Defaults to None. github_repo (str, optional): GitHub repo name. Defaults to None. \"\"\" if github_username is None : github_username = 'giswqs' if github_repo is None : github_repo = 'geemap' index = in_file . index ( github_repo ) file_relative_path = in_file [ index + len ( github_repo ) + 1 :] output_lines = [] with open ( in_file ) as f : lines = f . readlines () start_line_index = 2 start_char_index = lines [ start_line_index ] . index ( '{' ) matching_line_index , matching_char_index = find_matching_bracket ( lines , start_line_index , start_char_index ) header = lines [: matching_line_index ] content = lines [ matching_line_index :] new_header = [] search_string = '' for line in header : line = line . replace ( 'giswqs' , github_username ) line = line . replace ( 'geemap' , github_repo ) if 'master?filepath=' in line : search_string = 'master?filepath=' start_index = line . index ( search_string ) + len ( search_string ) end_index = line . index ( '.ipynb' ) + 6 relative_path = line [ start_index : end_index ] line = line . replace ( relative_path , file_relative_path ) elif '/master/' in line : search_string = '/master/' start_index = line . index ( search_string ) + len ( search_string ) end_index = line . index ( '.ipynb' ) + 6 relative_path = line [ start_index : end_index ] line = line . replace ( relative_path , file_relative_path ) new_header . append ( line ) output_lines = new_header + content with open ( in_file , 'w' ) as f : f . writelines ( output_lines ) update_nb_header_dir ( in_dir , github_username = None , github_repo = None ) Updates header (binder and Google Colab URLs) of all notebooks in a folder . Parameters: Name Type Description Default in_dir str The input directory containing Jupyter notebooks. required github_username str GitHub username. Defaults to None. None github_repo str GitHub repo name. Defaults to None. None Source code in geemap/conversion.py def update_nb_header_dir ( in_dir , github_username = None , github_repo = None ): \"\"\"Updates header (binder and Google Colab URLs) of all notebooks in a folder . Args: in_dir (str): The input directory containing Jupyter notebooks. github_username (str, optional): GitHub username. Defaults to None. github_repo (str, optional): GitHub repo name. Defaults to None. \"\"\" files = list ( Path ( in_dir ) . rglob ( '*.ipynb' )) for index , file in enumerate ( files ): file = str ( file ) if '.ipynb_checkpoints' in file : del files [ index ] count = len ( files ) if files is not None : for index , file in enumerate ( files ): in_file = str ( file ) print ( 'Processing {} / {} : {} ...' . format ( index + 1 , count , file )) update_nb_header ( in_file , github_username , github_repo ) use_math ( lines ) Checks if an Earth Engine uses Math library Parameters: Name Type Description Default lines list An Earth Engine JavaScript. required Returns: Type Description [bool] Returns True if the script contains 'Math.'. For example 'Math.PI', 'Math.pow' Source code in geemap/conversion.py def use_math ( lines ): \"\"\"Checks if an Earth Engine uses Math library Args: lines (list): An Earth Engine JavaScript. Returns: [bool]: Returns True if the script contains 'Math.'. For example 'Math.PI', 'Math.pow' \"\"\" math_import = False for line in lines : if 'Math.' in line : math_import = True return math_import","title":"conversion module"},{"location":"conversion/#conversion-module","text":"","title":"conversion module"},{"location":"conversion/#geemap.conversion","text":"Module for converting Google Earth Engine (GEE) JavaScripts to Python scripts and Jupyter notebooks. To convert a GEE JavaScript to Python script: js_to_python(in_file out_file) To convert all GEE JavaScripts in a folder recursively to Python scripts: js_to_python_dir(in_dir, out_dir) To convert a GEE Python script to Jupyter notebook: py_to_ipynb(in_file, template_file, out_file) To convert all GEE Python scripts in a folder recursively to Jupyter notebooks: py_to_ipynb_dir(in_dir, template_file, out_dir) To execute a Jupyter notebook and save output cells: execute_notebook(in_file) To execute all Jupyter notebooks in a folder recursively: execute_notebook_dir(in_dir)","title":"geemap.conversion"},{"location":"conversion/#geemap.conversion.check_map_functions","text":"Extracts Earth Engine map function Parameters: Name Type Description Default input_lines list List of Earth Engine JavaScrips required Returns: Type Description list Output JavaScript with map function Source code in geemap/conversion.py def check_map_functions ( input_lines ): \"\"\"Extracts Earth Engine map function Args: input_lines (list): List of Earth Engine JavaScrips Returns: list: Output JavaScript with map function \"\"\" output_lines = [] for index , line in enumerate ( input_lines ): if ( '.map(function' in line ) or ( '.map (function' ) in line : bracket_index = line . index ( \"{\" ) matching_line_index , matching_char_index = find_matching_bracket ( input_lines , index , bracket_index ) func_start_index = line . index ( 'function' ) func_name = 'func_' + random_string () func_header = line [ func_start_index :] . replace ( 'function' , 'function ' + func_name ) output_lines . append ( ' \\n ' ) output_lines . append ( func_header ) for sub_index , tmp_line in enumerate ( input_lines [ index + 1 : matching_line_index ]): output_lines . append ( tmp_line ) input_lines [ index + 1 + sub_index ] = '' header_line = line [: func_start_index ] + func_name header_line = header_line . rstrip () func_footer = input_lines [ matching_line_index ][: matching_char_index + 1 ] output_lines . append ( func_footer ) footer_line = input_lines [ matching_line_index ][ matching_char_index + 1 :] . strip () if footer_line == ')' or footer_line == ');' : header_line = header_line + footer_line footer_line = '' input_lines [ matching_line_index ] = footer_line output_lines . append ( header_line ) output_lines . append ( footer_line ) else : output_lines . append ( line ) return output_lines","title":"check_map_functions()"},{"location":"conversion/#geemap.conversion.convert_for_loop","text":"Converts JavaScript for loop to Python for loop. Parameters: Name Type Description Default line str Input JavaScript for loop required Returns: Type Description str Converted Python for loop. Source code in geemap/conversion.py def convert_for_loop ( line ): \"\"\"Converts JavaScript for loop to Python for loop. Args: line (str): Input JavaScript for loop Returns: str: Converted Python for loop. \"\"\" new_line = '' if 'var ' in line : line = line . replace ( 'var ' , '' ) start_index = line . index ( '(' ) end_index = line . index ( ')' ) prefix = line [:( start_index )] suffix = line [( end_index + 1 ):] params = line [( start_index + 1 ): end_index ] if ' in ' in params and params . count ( ';' ) == 0 : new_line = prefix + ' {} :' . format ( params ) + suffix return new_line items = params . split ( '=' ) param_name = items [ 0 ] . strip () items = params . split ( ';' ) subitems = [] for item in items : subitems . append ( item . split ( ' ' )[ - 1 ]) start = subitems [ 0 ] end = subitems [ 1 ] step = subitems [ 2 ] if '++' in step : step = 1 elif '--' in step : step = - 1 prefix = line [:( start_index )] suffix = line [( end_index + 1 ):] new_line = prefix + \\ ' {} in range( {} , {} , {} ):' . format ( param_name , start , end , step ) + suffix return new_line","title":"convert_for_loop()"},{"location":"conversion/#geemap.conversion.create_new_cell","text":"Create a new cell in Jupyter notebook based on the contents. Parameters: Name Type Description Default contents str A string of Python code. required Source code in geemap/conversion.py def create_new_cell ( contents , replace = False ): \"\"\"Create a new cell in Jupyter notebook based on the contents. Args: contents (str): A string of Python code. \"\"\" from IPython.core.getipython import get_ipython shell = get_ipython () shell . set_next_input ( contents , replace = replace )","title":"create_new_cell()"},{"location":"conversion/#geemap.conversion.download_from_gdrive","text":"Download a file shared via Google Drive (e.g., https://drive.google.com/file/d/18SUo_HcDGltuWYZs1s7PpOmOq_FvFn04/view?usp=sharing) Parameters: Name Type Description Default gfile_url str The Google Drive shared file URL required file_name str The output file name to use. required out_dir str The output directory. Defaults to '.'. '.' unzip bool Whether to unzip the output file if it is a zip file. Defaults to True. True Source code in geemap/conversion.py def download_from_gdrive ( gfile_url , file_name , out_dir = '.' , unzip = True ): \"\"\"Download a file shared via Google Drive (e.g., https://drive.google.com/file/d/18SUo_HcDGltuWYZs1s7PpOmOq_FvFn04/view?usp=sharing) Args: gfile_url (str): The Google Drive shared file URL file_name (str): The output file name to use. out_dir (str, optional): The output directory. Defaults to '.'. unzip (bool, optional): Whether to unzip the output file if it is a zip file. Defaults to True. \"\"\" try : from google_drive_downloader import GoogleDriveDownloader as gdd except ImportError : print ( 'GoogleDriveDownloader package not installed. Installing ...' ) subprocess . check_call ( [ \"python\" , '-m' , 'pip' , 'install' , 'googledrivedownloader' ]) from google_drive_downloader import GoogleDriveDownloader as gdd file_id = gfile_url . split ( '/' )[ 5 ] print ( 'Google Drive file id: {} ' . format ( file_id )) dest_path = os . path . join ( out_dir , file_name ) gdd . download_file_from_google_drive ( file_id , dest_path , True , unzip )","title":"download_from_gdrive()"},{"location":"conversion/#geemap.conversion.download_from_url","text":"Download a file from a URL (e.g., https://github.com/giswqs/whitebox/raw/master/examples/testdata.zip) Parameters: Name Type Description Default url str The HTTP URL to download. required out_file_name str The output file name to use. Defaults to None. None out_dir str The output directory to use. Defaults to '.'. '.' unzip bool Whether to unzip the downloaded file if it is a zip file. Defaults to True. True Source code in geemap/conversion.py def download_from_url ( url , out_file_name = None , out_dir = '.' , unzip = True ): \"\"\"Download a file from a URL (e.g., https://github.com/giswqs/whitebox/raw/master/examples/testdata.zip) Args: url (str): The HTTP URL to download. out_file_name (str, optional): The output file name to use. Defaults to None. out_dir (str, optional): The output directory to use. Defaults to '.'. unzip (bool, optional): Whether to unzip the downloaded file if it is a zip file. Defaults to True. \"\"\" in_file_name = os . path . basename ( url ) if out_file_name is None : out_file_name = in_file_name out_file_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name ) print ( 'Downloading {} ...' . format ( url )) try : urllib . request . urlretrieve ( url , out_file_path ) except : print ( \"The URL is invalid. Please double check the URL.\" ) return final_path = out_file_path if unzip : # if it is a zip file if '.zip' in out_file_name : print ( \"Unzipping {} ...\" . format ( out_file_name )) with zipfile . ZipFile ( out_file_path , \"r\" ) as zip_ref : zip_ref . extractall ( out_dir ) final_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name . replace ( '.zip' , '' )) # if it is a tar file if '.tar' in out_file_name : print ( \"Unzipping {} ...\" . format ( out_file_name )) with tarfile . open ( out_file_path , \"r\" ) as tar_ref : tar_ref . extractall ( out_dir ) final_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name . replace ( '.tart' , '' )) print ( 'Data downloaded to: {} ' . format ( final_path ))","title":"download_from_url()"},{"location":"conversion/#geemap.conversion.download_gee_app","text":"Downloads JavaScript source code from a GEE App Parameters: Name Type Description Default url str The URL of the GEE App. required out_file str The output file path for the downloaded JavaScript. Defaults to None. None Source code in geemap/conversion.py def download_gee_app ( url , out_file = None ): \"\"\"Downloads JavaScript source code from a GEE App Args: url (str): The URL of the GEE App. out_file (str, optional): The output file path for the downloaded JavaScript. Defaults to None. \"\"\" cwd = os . getcwd () out_file_name = os . path . basename ( url ) + '.js' out_file_path = os . path . join ( cwd , out_file_name ) items = url . split ( '/' ) items [ 3 ] = 'javascript' items [ 4 ] = items [ 4 ] + '-modules.json' json_url = '/' . join ( items ) print ( 'The json url: {} ' . format ( json_url )) if out_file is not None : out_file_path = out_file if not out_file_path . endswith ( 'js' ): out_file_path += '.js' out_dir = os . path . dirname ( out_file_path ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) json_path = out_file_path + 'on' try : urllib . request . urlretrieve ( json_url , json_path ) except : print ( \"The URL is invalid. Please double check the URL.\" ) return with open ( out_file_path , 'w' ) as f1 : with open ( json_path ) as f2 : lines = f2 . readlines () for line in lines : # print(line) items = line . split ( ' \\\\ n' ) for index , item in enumerate ( items ): if ( index > 0 ) and ( index < ( len ( items ) - 1 )): item = item . replace ( ' \\\\ \"' , '\"' ) item = item . replace ( r ' \\\\ ' , ' \\n ' ) item = item . replace ( ' \\\\ r' , '' ) f1 . write ( item + ' \\n ' ) os . remove ( json_path ) print ( 'The JavaScript is saved at: {} ' . format ( out_file_path ))","title":"download_gee_app()"},{"location":"conversion/#geemap.conversion.execute_notebook","text":"Executes a Jupyter notebook and save output cells Parameters: Name Type Description Default in_file str Input Jupyter notebook. required Source code in geemap/conversion.py def execute_notebook ( in_file ): \"\"\"Executes a Jupyter notebook and save output cells Args: in_file (str): Input Jupyter notebook. \"\"\" # command = 'jupyter nbconvert --to notebook --execute ' + in_file + ' --inplace' command = 'jupyter nbconvert --to notebook --execute \" {} \" --inplace' . format ( in_file ) print ( os . popen ( command ) . read () . rstrip ())","title":"execute_notebook()"},{"location":"conversion/#geemap.conversion.execute_notebook_dir","text":"Executes all Jupyter notebooks in the given directory recursively and save output cells. Parameters: Name Type Description Default in_dir str Input folder containing notebooks. required Source code in geemap/conversion.py def execute_notebook_dir ( in_dir ): \"\"\"Executes all Jupyter notebooks in the given directory recursively and save output cells. Args: in_dir (str): Input folder containing notebooks. \"\"\" print ( 'Executing Earth Engine Jupyter notebooks ... \\n ' ) in_dir = os . path . abspath ( in_dir ) files = list ( Path ( in_dir ) . rglob ( '*.ipynb' )) count = len ( files ) if files is not None : for index , file in enumerate ( files ): in_file = str ( file ) print ( 'Processing {} / {} : {} ...' . format ( index + 1 , count , file )) execute_notebook ( in_file )","title":"execute_notebook_dir()"},{"location":"conversion/#geemap.conversion.find_matching_bracket","text":"Finds the position of the matching closing bracket from a list of lines. Parameters: Name Type Description Default lines list The input list of lines. required start_line_index int The line index where the starting bracket is located. required start_char_index int The position index of the starting bracket. required matching_char str The starting bracket to search for. Defaults to '{'. '{' Returns: Type Description matching_line_index (int) The line index where the matching closing bracket is located. matching_char_index (int): The position index of the matching closing bracket. Source code in geemap/conversion.py def find_matching_bracket ( lines , start_line_index , start_char_index , matching_char = '{' ): \"\"\"Finds the position of the matching closing bracket from a list of lines. Args: lines (list): The input list of lines. start_line_index (int): The line index where the starting bracket is located. start_char_index (int): The position index of the starting bracket. matching_char (str, optional): The starting bracket to search for. Defaults to '{'. Returns: matching_line_index (int): The line index where the matching closing bracket is located. matching_char_index (int): The position index of the matching closing bracket. \"\"\" matching_line_index = - 1 matching_char_index = - 1 matching_chars = { '{' : '}' , '(' : ')' , '[' : ']' } if matching_char not in matching_chars . keys (): print ( \"The matching character must be one of the following: {} \" . format ( ', ' . join ( matching_chars . keys ()))) return matching_line_index , matching_char_index # Create a deque to use it as a stack. d = deque () for line_index in range ( start_line_index , len ( lines )): line = lines [ line_index ] # deal with the line where the starting bracket is located. if line_index == start_line_index : line = lines [ line_index ][ start_char_index :] for index , item in enumerate ( line ): # Pops a starting bracket for each closing bracket if item == matching_chars [ matching_char ]: d . popleft () # Push all starting brackets elif item == matching_char : d . append ( matching_char ) # If deque becomes empty if not d : matching_line_index = line_index if line_index == start_line_index : matching_char_index = start_char_index + index else : matching_char_index = index return matching_line_index , matching_char_index return matching_line_index , matching_char_index","title":"find_matching_bracket()"},{"location":"conversion/#geemap.conversion.format_params","text":"Formats keys in a dictionary and adds quotes to the keys. For example, {min: 0, max: 10} will result in ('min': 0, 'max': 10) Parameters: Name Type Description Default line str A string. required sep str Separator. Defaults to ':'. ':' Returns: Type Description [str] A string with keys quoted Source code in geemap/conversion.py def format_params ( line , sep = ':' ): \"\"\"Formats keys in a dictionary and adds quotes to the keys. For example, {min: 0, max: 10} will result in ('min': 0, 'max': 10) Args: line (str): A string. sep (str, optional): Separator. Defaults to ':'. Returns: [str]: A string with keys quoted \"\"\" # print(line) new_line = line prefix = \"\" suffix = \"\" if line . strip () . startswith ( 'for' ): # skip for loop return line # find all occurrences of a substring def find_all ( a_str , sub ): start = 0 while True : start = a_str . find ( sub , start ) if start == - 1 : return yield start start += len ( sub ) # use start += 1 to find overlapping matches indices = list ( find_all ( line , sep )) count = len ( indices ) if \"{\" in line : bracket_index = line . index ( \"{\" ) if bracket_index < indices [ 0 ]: prefix = line [: bracket_index + 1 ] line = line [ bracket_index + 1 :] if count > 0 : items = line . split ( sep ) if count == 1 : for i in range ( 0 , count ): item = items [ i ] . strip () if ( '\"' not in item ) and ( \"'\" not in item ): new_item = \"'\" + item + \"'\" items [ i ] = items [ i ] . replace ( item , new_item ) new_line = ':' . join ( items ) elif count > 1 : for i in range ( 0 , count ): item = items [ i ] if ',' in item : subitems = item . split ( ',' ) subitem = subitems [ - 1 ] if ( '\"' not in subitem ) and ( \"'\" not in subitem ): new_subitem = \"'\" + subitem . strip () + \"'\" subitems [ - 1 ] = subitems [ - 1 ] . replace ( subitem , new_subitem ) items [ i ] = ', ' . join ( subitems ) else : if ( '\"' not in item ) and ( \"'\" not in item ): new_item = \"'\" + item . strip () + \"'\" padding = len ( item ) - len ( item . strip ()) items [ i ] = \" \" * padding + item . replace ( item , new_item ) new_line = ':' . join ( items ) return prefix + new_line","title":"format_params()"},{"location":"conversion/#geemap.conversion.get_js_examples","text":"Gets Earth Engine JavaScript examples from the geemap package. Parameters: Name Type Description Default out_dir str The folder to copy the JavaScript examples to. Defaults to None. None Returns: Type Description str The folder containing the JavaScript examples. Source code in geemap/conversion.py def get_js_examples ( out_dir = None ): \"\"\"Gets Earth Engine JavaScript examples from the geemap package. Args: out_dir (str, optional): The folder to copy the JavaScript examples to. Defaults to None. Returns: str: The folder containing the JavaScript examples. \"\"\" pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) example_dir = os . path . join ( pkg_dir , 'data' ) js_dir = os . path . join ( example_dir , 'javascripts' ) files = list ( Path ( js_dir ) . rglob ( '*.js' )) if out_dir is None : out_dir = js_dir else : if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) for file in files : basename = os . path . basename ( file ) out_path = os . path . join ( out_dir , basename ) shutil . copyfile ( file , out_path ) return out_dir","title":"get_js_examples()"},{"location":"conversion/#geemap.conversion.get_nb_template","text":"Get the Earth Engine Jupyter notebook template. Parameters: Name Type Description Default download_latest bool If True, downloads the latest notebook template from GitHub. Defaults to False. False out_file str Set the output file path of the notebook template. Defaults to None. None Returns: Type Description str The file path of the template. Source code in geemap/conversion.py def get_nb_template ( download_latest = False , out_file = None ): \"\"\"Get the Earth Engine Jupyter notebook template. Args: download_latest (bool, optional): If True, downloads the latest notebook template from GitHub. Defaults to False. out_file (str, optional): Set the output file path of the notebook template. Defaults to None. Returns: str: The file path of the template. \"\"\" pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) example_dir = os . path . join ( pkg_dir , 'data' ) template_dir = os . path . join ( example_dir , 'template' ) template_file = os . path . join ( template_dir , 'template.py' ) if out_file is None : out_file = template_file return out_file if not out_file . endswith ( '.py' ): out_file = out_file + '.py' if not os . path . exists ( os . path . dirname ( out_file )): os . makedirs ( os . path . dirname ( out_file )) if download_latest : template_url = 'https://raw.githubusercontent.com/giswqs/geemap/master/examples/template/template.py' print ( \"Downloading the latest notebook template from {} \" . format ( template_url )) urllib . request . urlretrieve ( template_url , out_file ) elif out_file is not None : shutil . copyfile ( template_file , out_file ) return out_file","title":"get_nb_template()"},{"location":"conversion/#geemap.conversion.js_snippet_to_py","text":"Converts an Earth Engine JavaScript snippet wrapped in triple quotes to Python directly on a Jupyter notebook. Parameters: Name Type Description Default in_js_snippet str Earth Engine JavaScript within triple quotes. required add_new_cell bool Whether add the converted Python to a new cell. True import_ee bool Whether to import ee. Defaults to True. True import_geemap bool Whether to import geemap. Defaults to True. True show_map bool Whether to show the map. Defaults to True. True Returns: Type Description list A list of Python script. Source code in geemap/conversion.py def js_snippet_to_py ( in_js_snippet , add_new_cell = True , import_ee = True , import_geemap = True , show_map = True ): \"\"\"Converts an Earth Engine JavaScript snippet wrapped in triple quotes to Python directly on a Jupyter notebook. Args: in_js_snippet (str): Earth Engine JavaScript within triple quotes. add_new_cell (bool, optional): Whether add the converted Python to a new cell. import_ee (bool, optional): Whether to import ee. Defaults to True. import_geemap (bool, optional): Whether to import geemap. Defaults to True. show_map (bool, optional): Whether to show the map. Defaults to True. Returns: list: A list of Python script. \"\"\" work_dir = os . path . expanduser ( \"~\" ) in_js = os . path . join ( work_dir , 'tmp_js_snippet.js' ) out_py = os . path . join ( work_dir , 'tmp_py_snippet.py' ) try : with open ( in_js , 'w' ) as f : f . write ( in_js_snippet ) js_to_python ( in_js , out_file = out_py , use_qgis = False ) out_lines = [] if import_ee : out_lines . append ( 'import ee \\n ' ) if import_geemap : out_lines . append ( 'import geemap \\n\\n ' ) out_lines . append ( 'Map = geemap.Map() \\n ' ) if import_ee : out_lines . append ( 'ee.Initialize() \\n ' ) with open ( out_py ) as f : lines = f . readlines () for index , line in enumerate ( lines ): if index < ( len ( lines ) - 1 ): if line . strip () == 'import ee' : continue # elif import_ee and (line.strip() == 'import ee'): # out_lines.append(line) # out_lines.append('ee.Initialize()\\n') # continue next_line = lines [ index + 1 ] if line . strip () == '' and next_line . strip () == '' : continue else : out_lines . append ( line ) elif index == ( len ( lines ) - 1 ) and lines [ index ] . strip () != '' : out_lines . append ( line ) if show_map : out_lines . append ( 'Map \\n ' ) os . remove ( in_js ) os . remove ( out_py ) if add_new_cell : contents = '' . join ( out_lines ) create_new_cell ( contents ) else : return out_lines except Exception as e : print ( e )","title":"js_snippet_to_py()"},{"location":"conversion/#geemap.conversion.js_to_python","text":"Converts an Earth Engine JavaScript to Python script. !!! args in_file (str): File path of the input JavaScript. out_file (str, optional): File path of the output Python script. Defaults to None. use_qgis (bool, optional): Whether to add \"from ee_plugin import Map \" to the output script. Defaults to True. github_repo (str, optional): GitHub repo url. Defaults to None. !!! returns list : Python script Source code in geemap/conversion.py def js_to_python ( in_file , out_file = None , use_qgis = True , github_repo = None ): \"\"\"Converts an Earth Engine JavaScript to Python script. Args: in_file (str): File path of the input JavaScript. out_file (str, optional): File path of the output Python script. Defaults to None. use_qgis (bool, optional): Whether to add \"from ee_plugin import Map \\n\" to the output script. Defaults to True. github_repo (str, optional): GitHub repo url. Defaults to None. Returns: list : Python script \"\"\" in_file = os . path . abspath ( in_file ) if out_file is None : out_file = in_file . replace ( \".js\" , \".py\" ) root_dir = os . path . dirname ( os . path . abspath ( __file__ )) if not os . path . isfile ( in_file ): in_file = os . path . join ( root_dir , in_file ) if not os . path . isfile ( out_file ): out_file = os . path . join ( root_dir , out_file ) is_python = False add_github_url = False qgis_import_str = '' if use_qgis : qgis_import_str = \"from ee_plugin import Map \\n \" github_url = \"\" if github_repo is not None : github_url = \"# GitHub URL: \" + github_repo + in_file + \" \\n\\n \" math_import = False math_import_str = \"\" lines = [] with open ( in_file ) as f : lines = f . readlines () math_import = use_math ( lines ) for line in lines : line = line . strip () if line == 'import ee' : is_python = True if math_import : math_import_str = \"import math \\n \" output = \"\" if is_python : # only update the GitHub URL if it is already a GEE Python script output = github_url + '' . join ( map ( str , lines )) else : # deal with JavaScript header = github_url + \"import ee \\n \" + qgis_import_str + math_import_str function_defs = [] output = header + \" \\n \" with open ( in_file ) as f : lines = f . readlines () # print('Processing {}'.format(in_file)) lines = check_map_functions ( lines ) for index , line in enumerate ( lines ): if ( '/* color' in line ) and ( '*/' in line ): line = line [: line . index ( '/*' )] . lstrip () + \\ line [( line . index ( '*/' ) + 2 ):] if ( \"= function\" in line ) or ( \"=function\" in line ) or line . strip () . startswith ( \"function\" ): bracket_index = line . index ( \"{\" ) matching_line_index , matching_char_index = find_matching_bracket ( lines , index , bracket_index ) line = line [: bracket_index ] + line [ bracket_index + 1 :] if matching_line_index == index : line = line [: matching_char_index ] + \\ line [ matching_char_index + 1 :] else : tmp_line = lines [ matching_line_index ] lines [ matching_line_index ] = tmp_line [: matching_char_index ] + \\ tmp_line [ matching_char_index + 1 :] line = line . replace ( \" = function\" , \"\" ) . replace ( \"=function\" , '' ) . replace ( \"function \" , '' ) if line . lstrip () . startswith ( '//' ): line = line . replace ( '//' , '' ) . lstrip () line = \" \" * ( len ( line ) - len ( line . lstrip ()) ) + \"# def \" + line . strip () + \":\" else : line = \" \" * ( len ( line ) - len ( line . lstrip ()) ) + \"def \" + line . strip () + \":\" elif \"{\" in line : bracket_index = line . index ( \"{\" ) matching_line_index , matching_char_index = find_matching_bracket ( lines , index , bracket_index ) if ( matching_line_index == index ) and ( ':' in line ): pass elif ( 'for (' in line ) or ( 'for(' in line ): line = convert_for_loop ( line ) lines [ index ] = line bracket_index = line . index ( \"{\" ) matching_line_index , matching_char_index = find_matching_bracket ( lines , index , bracket_index ) tmp_line = lines [ matching_line_index ] lines [ matching_line_index ] = tmp_line [: matching_char_index ] + \\ tmp_line [ matching_char_index + 1 :] line = line . replace ( '{' , '' ) if line is None : line = '' line = line . replace ( \"//\" , \"#\" ) line = line . replace ( \"var \" , \"\" , 1 ) line = line . replace ( \"/*\" , '#' ) line = line . replace ( \"*/\" , '#' ) line = line . replace ( \"true\" , \"True\" ) . replace ( \"false\" , \"False\" ) line = line . replace ( \"null\" , \" {} \" ) line = line . replace ( \".or\" , \".Or\" ) line = line . replace ( \".and\" , '.And' ) line = line . replace ( \".not\" , '.Not' ) line = line . replace ( 'visualize({' , 'visualize(**{' ) line = line . replace ( 'Math.PI' , 'math.pi' ) line = line . replace ( 'Math.' , 'math.' ) line = line . replace ( '= new' , '=' ) line = line . rstrip () if line . endswith ( \"+\" ): line = line + \" \\\\ \" elif line . endswith ( \";\" ): line = line [: - 1 ] if line . lstrip () . startswith ( '*' ): line = line . replace ( '*' , '#' ) if ( \":\" in line ) and ( not line . strip () . startswith ( \"#\" )) and ( not line . strip () . startswith ( 'def' )) and ( not line . strip () . startswith ( \".\" )): line = format_params ( line ) if index < ( len ( lines ) - 1 ) and line . lstrip () . startswith ( \"#\" ) and lines [ index + 1 ] . lstrip () . startswith ( \".\" ): line = '' if line . lstrip () . startswith ( \".\" ): if \"#\" in line : line = line [: line . index ( \"#\" )] output = output . rstrip () + \" \" + \" \\\\ \" + \" \\n \" + line + \" \\n \" else : output += line + \" \\n \" out_dir = os . path . dirname ( out_file ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) with open ( out_file , 'w' ) as f : f . write ( output ) return output","title":"js_to_python()"},{"location":"conversion/#geemap.conversion.js_to_python_dir","text":"Converts all Earth Engine JavaScripts in a folder recursively to Python scripts. !!! args in_dir (str): The input folder containing Earth Engine JavaScripts. out_dir (str, optional): The output folder containing Earth Engine Python scripts. Defaults to None. use_qgis (bool, optional): Whether to add \"from ee_plugin import Map \" to the output script. Defaults to True. github_repo (str, optional): GitHub repo url. Defaults to None. Source code in geemap/conversion.py def js_to_python_dir ( in_dir , out_dir = None , use_qgis = True , github_repo = None ): \"\"\"Converts all Earth Engine JavaScripts in a folder recursively to Python scripts. Args: in_dir (str): The input folder containing Earth Engine JavaScripts. out_dir (str, optional): The output folder containing Earth Engine Python scripts. Defaults to None. use_qgis (bool, optional): Whether to add \"from ee_plugin import Map \\n\" to the output script. Defaults to True. github_repo (str, optional): GitHub repo url. Defaults to None. \"\"\" print ( 'Converting Earth Engine JavaScripts to Python scripts... \\n ' ) in_dir = os . path . abspath ( in_dir ) if out_dir is None : out_dir = in_dir elif not os . path . exists ( out_dir ): out_dir = os . path . abspath ( out_dir ) os . makedirs ( out_dir ) else : out_dir = os . path . abspath ( out_dir ) files = list ( Path ( in_dir ) . rglob ( '*.js' )) for index , in_file in enumerate ( files ): print ( 'Processing {} / {} : {} ' . format ( index + 1 , len ( files ), in_file )) out_file = os . path . splitext ( in_file )[ 0 ] + \"_qgis.py\" out_file = out_file . replace ( in_dir , out_dir ) js_to_python ( in_file , out_file , use_qgis , github_repo )","title":"js_to_python_dir()"},{"location":"conversion/#geemap.conversion.py_to_ipynb","text":"Converts Earth Engine Python script to Jupyter notebook. Parameters: Name Type Description Default in_file str Input Earth Engine Python script. required template_file str Input Jupyter notebook template. required out_file str Output Jupyter notebook. None github_username str GitHub username. Defaults to None. None github_repo str GitHub repo name. Defaults to None. None Source code in geemap/conversion.py def py_to_ipynb ( in_file , template_file , out_file = None , github_username = None , github_repo = None ): \"\"\"Converts Earth Engine Python script to Jupyter notebook. Args: in_file (str): Input Earth Engine Python script. template_file (str): Input Jupyter notebook template. out_file (str, optional)): Output Jupyter notebook. github_username (str, optional): GitHub username. Defaults to None. github_repo (str, optional): GitHub repo name. Defaults to None. \"\"\" in_file = os . path . abspath ( in_file ) if out_file is None : out_file = os . path . splitext ( in_file )[ 0 ] . replace ( '_qgis' , '' ) + '.ipynb' out_py_file = os . path . splitext ( out_file )[ 0 ] + '.py' out_dir = os . path . dirname ( out_file ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) if out_dir == os . path . dirname ( in_file ): out_py_file = os . path . splitext ( out_file )[ 0 ] + '.py' content = remove_qgis_import ( in_file ) header = template_header ( template_file ) footer = template_footer ( template_file ) if ( github_username is not None ) and ( github_repo is not None ): out_py_path = str ( out_file ) . split ( '/' ) index = out_py_path . index ( github_repo ) out_py_relative_path = '/' . join ( out_py_path [ index + 1 :]) out_ipynb_relative_path = out_py_relative_path . replace ( '.py' , '.ipynb' ) new_header = [] for index , line in enumerate ( header ): if index < 9 : # Change Google Colab and binder URLs line = line . replace ( 'giswqs' , github_username ) line = line . replace ( 'geemap' , github_repo ) line = line . replace ( 'examples/template/template.ipynb' , out_ipynb_relative_path ) new_header . append ( line ) header = new_header if content != None : out_text = header + content + footer else : out_text = header + footer if not os . path . exists ( os . path . dirname ( out_py_file )): os . makedirs ( os . path . dirname ( out_py_file )) with open ( out_py_file , 'w' ) as f : f . writelines ( out_text ) try : # command = 'ipynb-py-convert ' + out_py_file + ' ' + out_file command = 'ipynb-py-convert \" {} \" \" {} \"' . format ( out_py_file , out_file ) print ( os . popen ( command ) . read () . rstrip ()) # os.popen(command) except : print ( 'Please install ipynb-py-convert using the following command: \\n ' ) print ( 'pip install ipynb-py-convert' )","title":"py_to_ipynb()"},{"location":"conversion/#geemap.conversion.py_to_ipynb_dir","text":"Converts Earth Engine Python scripts in a folder recursively to Jupyter notebooks. Parameters: Name Type Description Default in_dir str Input folder containing Earth Engine Python scripts. required template_file str Input jupyter notebook template file. required out_dir str Output folder. Defaults to None. None github_username str GitHub username. Defaults to None. None github_repo str GitHub repo name. Defaults to None. None Source code in geemap/conversion.py def py_to_ipynb_dir ( in_dir , template_file , out_dir = None , github_username = None , github_repo = None ): \"\"\"Converts Earth Engine Python scripts in a folder recursively to Jupyter notebooks. Args: in_dir (str): Input folder containing Earth Engine Python scripts. template_file (str): Input jupyter notebook template file. out_dir str, optional): Output folder. Defaults to None. github_username (str, optional): GitHub username. Defaults to None. github_repo (str, optional): GitHub repo name. Defaults to None. \"\"\" print ( 'Converting Earth Engine Python scripts to Jupyter notebooks ... \\n ' ) in_dir = os . path . abspath ( in_dir ) files = [] qgis_files = list ( Path ( in_dir ) . rglob ( '*_qgis.py' )) py_files = list ( Path ( in_dir ) . rglob ( '*.py' )) if len ( qgis_files ) == len ( py_files ) / 2 : files = qgis_files else : files = py_files if out_dir is None : out_dir = in_dir elif not os . path . exists ( out_dir ): out_dir = os . path . abspath ( out_dir ) os . makedirs ( out_dir ) else : out_dir = os . path . abspath ( out_dir ) for index , file in enumerate ( files ): in_file = str ( file ) out_file = in_file . replace ( in_dir , out_dir ) . replace ( '_qgis' , '' ) . replace ( '.py' , '.ipynb' ) print ( 'Processing {} / {} : {} ' . format ( index + 1 , len ( files ), in_file )) py_to_ipynb ( in_file , template_file , out_file , github_username , github_repo )","title":"py_to_ipynb_dir()"},{"location":"conversion/#geemap.conversion.random_string","text":"Generates a random string of fixed length. Parameters: Name Type Description Default string_length int Fixed length. Defaults to 3. 3 Returns: Type Description str A random string Source code in geemap/conversion.py def random_string ( string_length = 3 ): \"\"\"Generates a random string of fixed length. Args: string_length (int, optional): Fixed length. Defaults to 3. Returns: str: A random string \"\"\" # random.seed(1001) letters = string . ascii_lowercase return '' . join ( random . choice ( letters ) for i in range ( string_length ))","title":"random_string()"},{"location":"conversion/#geemap.conversion.remove_qgis_import","text":"Removes 'from ee_plugin import Map' from an Earth Engine Python script. Parameters: Name Type Description Default in_file str Input file path of the Python script. required Returns: Type Description list List of lines 'from ee_plugin import Map' removed. Source code in geemap/conversion.py def remove_qgis_import ( in_file ): \"\"\"Removes 'from ee_plugin import Map' from an Earth Engine Python script. Args: in_file (str): Input file path of the Python script. Returns: list: List of lines 'from ee_plugin import Map' removed. \"\"\" in_file = os . path . abspath ( in_file ) start_index = 0 with open ( in_file ) as f : lines = f . readlines () for index , line in enumerate ( lines ): if 'from ee_plugin import Map' in line : start_index = index i = 1 while True : line_tmp = lines [ start_index + i ] . strip () if line_tmp != '' : return lines [ start_index + i :] else : i = i + 1","title":"remove_qgis_import()"},{"location":"conversion/#geemap.conversion.template_footer","text":"Extracts footer from the notebook template. Parameters: Name Type Description Default in_template str Input notebook template file path. required Returns: Type Description list List of lines. Source code in geemap/conversion.py def template_footer ( in_template ): \"\"\"Extracts footer from the notebook template. Args: in_template (str): Input notebook template file path. Returns: list: List of lines. \"\"\" footer = [] template_lines = [] footer_start_index = 0 with open ( in_template ) as f : template_lines = f . readlines () for index , line in enumerate ( template_lines ): if '## Display Earth Engine data layers' in line : footer_start_index = index - 3 footer = [ ' \\n ' ] + template_lines [ footer_start_index :] return footer","title":"template_footer()"},{"location":"conversion/#geemap.conversion.template_header","text":"Extracts header from the notebook template. Parameters: Name Type Description Default in_template str Input notebook template file path. required Returns: Type Description list List of lines. Source code in geemap/conversion.py def template_header ( in_template ): \"\"\"Extracts header from the notebook template. Args: in_template (str): Input notebook template file path. Returns: list: List of lines. \"\"\" header = [] template_lines = [] header_end_index = 0 with open ( in_template ) as f : template_lines = f . readlines () for index , line in enumerate ( template_lines ): if '## Add Earth Engine Python script' in line : header_end_index = index + 5 header = template_lines [: header_end_index ] return header","title":"template_header()"},{"location":"conversion/#geemap.conversion.update_nb_header","text":"Updates notebook header (binder and Google Colab URLs). Parameters: Name Type Description Default in_file str The input Jupyter notebook. required github_username str GitHub username. Defaults to None. None github_repo str GitHub repo name. Defaults to None. None Source code in geemap/conversion.py def update_nb_header ( in_file , github_username = None , github_repo = None ): \"\"\"Updates notebook header (binder and Google Colab URLs). Args: in_file (str): The input Jupyter notebook. github_username (str, optional): GitHub username. Defaults to None. github_repo (str, optional): GitHub repo name. Defaults to None. \"\"\" if github_username is None : github_username = 'giswqs' if github_repo is None : github_repo = 'geemap' index = in_file . index ( github_repo ) file_relative_path = in_file [ index + len ( github_repo ) + 1 :] output_lines = [] with open ( in_file ) as f : lines = f . readlines () start_line_index = 2 start_char_index = lines [ start_line_index ] . index ( '{' ) matching_line_index , matching_char_index = find_matching_bracket ( lines , start_line_index , start_char_index ) header = lines [: matching_line_index ] content = lines [ matching_line_index :] new_header = [] search_string = '' for line in header : line = line . replace ( 'giswqs' , github_username ) line = line . replace ( 'geemap' , github_repo ) if 'master?filepath=' in line : search_string = 'master?filepath=' start_index = line . index ( search_string ) + len ( search_string ) end_index = line . index ( '.ipynb' ) + 6 relative_path = line [ start_index : end_index ] line = line . replace ( relative_path , file_relative_path ) elif '/master/' in line : search_string = '/master/' start_index = line . index ( search_string ) + len ( search_string ) end_index = line . index ( '.ipynb' ) + 6 relative_path = line [ start_index : end_index ] line = line . replace ( relative_path , file_relative_path ) new_header . append ( line ) output_lines = new_header + content with open ( in_file , 'w' ) as f : f . writelines ( output_lines )","title":"update_nb_header()"},{"location":"conversion/#geemap.conversion.update_nb_header_dir","text":"Updates header (binder and Google Colab URLs) of all notebooks in a folder . Parameters: Name Type Description Default in_dir str The input directory containing Jupyter notebooks. required github_username str GitHub username. Defaults to None. None github_repo str GitHub repo name. Defaults to None. None Source code in geemap/conversion.py def update_nb_header_dir ( in_dir , github_username = None , github_repo = None ): \"\"\"Updates header (binder and Google Colab URLs) of all notebooks in a folder . Args: in_dir (str): The input directory containing Jupyter notebooks. github_username (str, optional): GitHub username. Defaults to None. github_repo (str, optional): GitHub repo name. Defaults to None. \"\"\" files = list ( Path ( in_dir ) . rglob ( '*.ipynb' )) for index , file in enumerate ( files ): file = str ( file ) if '.ipynb_checkpoints' in file : del files [ index ] count = len ( files ) if files is not None : for index , file in enumerate ( files ): in_file = str ( file ) print ( 'Processing {} / {} : {} ...' . format ( index + 1 , count , file )) update_nb_header ( in_file , github_username , github_repo )","title":"update_nb_header_dir()"},{"location":"conversion/#geemap.conversion.use_math","text":"Checks if an Earth Engine uses Math library Parameters: Name Type Description Default lines list An Earth Engine JavaScript. required Returns: Type Description [bool] Returns True if the script contains 'Math.'. For example 'Math.PI', 'Math.pow' Source code in geemap/conversion.py def use_math ( lines ): \"\"\"Checks if an Earth Engine uses Math library Args: lines (list): An Earth Engine JavaScript. Returns: [bool]: Returns True if the script contains 'Math.'. For example 'Math.PI', 'Math.pow' \"\"\" math_import = False for line in lines : if 'Math.' in line : math_import = True return math_import","title":"use_math()"},{"location":"eefolium/","text":"eefolium module This module extends the folium Map class. It is designed to be used in Google Colab, as Google Colab currently does not support ipyleaflet. Map The Map class inherits from folium.Map. By default, the Map will add Google Maps as the basemap. Set add_google_map = False to use OpenStreetMap as the basemap. Returns: Type Description object folium map object. add_basemap ( self , basemap = 'HYBRID' ) Adds a basemap to the map. Parameters: Name Type Description Default basemap str Can be one of string from ee_basemaps. Defaults to 'HYBRID'. 'HYBRID' Source code in geemap/eefolium.py def add_basemap ( self , basemap = 'HYBRID' ): \"\"\"Adds a basemap to the map. Args: basemap (str, optional): Can be one of string from ee_basemaps. Defaults to 'HYBRID'. \"\"\" try : ee_basemaps [ basemap ] . add_to ( self ) except : print ( 'Basemap can only be one of the following: {} ' . format ( ', ' . join ( ee_basemaps . keys ()))) add_layer ( self , ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ) Adds a given EE object to the map as a layer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer untitled'. 'Layer untitled' shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/eefolium.py def add_layer ( self , ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ): \"\"\"Adds a given EE object to the map as a layer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer untitled'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" image = None if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) folium . raster_layers . TileLayer ( tiles = map_id_dict [ 'tile_fetcher' ] . url_format , attr = 'Google Earth Engine' , name = name , overlay = True , control = True , show = shown , opacity = opacity ) . add_to ( self ) add_layer_control ( self ) Adds layer basemap to the map. Source code in geemap/eefolium.py def add_layer_control ( self ): \"\"\"Adds layer basemap to the map. \"\"\" folium . LayerControl () . add_to ( self ) add_tile_layer ( self , tiles = 'OpenStreetMap' , name = None , attribution = '' , overlay = True , control = True , shown = True , opacity = 1.0 , API_key = None ) Add a XYZ tile layer to the map. Parameters: Name Type Description Default tiles str The URL of the XYZ tile service. 'OpenStreetMap' name str The layer name to use on the layer control. Defaults to None. None attribution str The attribution of the data layer. Defaults to ''. '' overlay str Allows overlay. Defaults to True. True control str Adds the layer to the layer control. Defaults to True. True shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float Sets the opacity for the layer. 1.0 API_key str \u2013 API key for Cloudmade or Mapbox tiles. Defaults to True. None Source code in geemap/eefolium.py def add_tile_layer ( self , tiles = 'OpenStreetMap' , name = None , attribution = '' , overlay = True , control = True , shown = True , opacity = 1.0 , API_key = None ): \"\"\"Add a XYZ tile layer to the map. Args: tiles (str): The URL of the XYZ tile service. name (str, optional): The layer name to use on the layer control. Defaults to None. attribution (str, optional): The attribution of the data layer. Defaults to ''. overlay (str, optional): Allows overlay. Defaults to True. control (str, optional): Adds the layer to the layer control. Defaults to True. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): Sets the opacity for the layer. API_key (str, optional): \u2013 API key for Cloudmade or Mapbox tiles. Defaults to True. \"\"\" try : folium . raster_layers . TileLayer ( tiles = tiles , name = name , attr = attribution , overlay = overlay , control = control , show = shown , opacity = opacity , API_key = API_key ) . add_to ( self ) except : print ( \"Failed to add the specified TileLayer.\" ) add_wms_layer ( self , url , layers , name = None , attribution = '' , overlay = True , control = True , shown = True , format = 'image/png' ) Add a WMS layer to the map. Parameters: Name Type Description Default url str The URL of the WMS web service. required layers str Comma-separated list of WMS layers to show. required name str The layer name to use on the layer control. Defaults to None. None attribution str The attribution of the data layer. Defaults to ''. '' overlay str Allows overlay. Defaults to True. True control str Adds the layer to the layer control. Defaults to True. True shown bool A flag indicating whether the layer should be on by default. Defaults to True. True format str WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/jpeg'. 'image/png' Source code in geemap/eefolium.py def add_wms_layer ( self , url , layers , name = None , attribution = '' , overlay = True , control = True , shown = True , format = 'image/png' ): \"\"\"Add a WMS layer to the map. Args: url (str): The URL of the WMS web service. layers (str): Comma-separated list of WMS layers to show. name (str, optional): The layer name to use on the layer control. Defaults to None. attribution (str, optional): The attribution of the data layer. Defaults to ''. overlay (str, optional): Allows overlay. Defaults to True. control (str, optional): Adds the layer to the layer control. Defaults to True. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/jpeg'. \"\"\" try : folium . raster_layers . WmsTileLayer ( url = url , layers = layers , attr = attribution , name = name , overlay = overlay , control = control , show = shown ) . add_to ( self ) except : print ( \"Failed to add the specified WMS TileLayer.\" ) addLayer ( self , ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ) Adds a given EE object to the map as a layer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer untitled'. 'Layer untitled' shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/eefolium.py def add_layer ( self , ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ): \"\"\"Adds a given EE object to the map as a layer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer untitled'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" image = None if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) folium . raster_layers . TileLayer ( tiles = map_id_dict [ 'tile_fetcher' ] . url_format , attr = 'Google Earth Engine' , name = name , overlay = True , control = True , show = shown , opacity = opacity ) . add_to ( self ) addLayerControl ( self ) Adds layer basemap to the map. Source code in geemap/eefolium.py def add_layer_control ( self ): \"\"\"Adds layer basemap to the map. \"\"\" folium . LayerControl () . add_to ( self ) center_object ( self , ee_object , zoom = 10 ) Centers the map view on a given object. Parameters: Name Type Description Default ee_object Element|Geometry An Earth Engine object to center on - a geometry, image or feature. required zoom int The zoom level, from 1 to 24. Defaults to 10. 10 Source code in geemap/eefolium.py def center_object ( self , ee_object , zoom = 10 ): \"\"\"Centers the map view on a given object. Args: ee_object (Element|Geometry): An Earth Engine object to center on - a geometry, image or feature. zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10. \"\"\" lat = 0 lon = 0 bounds = [[ lat , lon ], [ lat , lon ]] if isinstance ( ee_object , ee . geometry . Geometry ): centroid = ee_object . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . featurecollection . FeatureCollection ): centroid = ee_object . geometry () . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . image . Image ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] else : bounds = [[ 0 , 0 ], [ 0 , 0 ]] self . fit_bounds ( bounds , max_zoom = zoom ) centerObject ( self , ee_object , zoom = 10 ) Centers the map view on a given object. Parameters: Name Type Description Default ee_object Element|Geometry An Earth Engine object to center on - a geometry, image or feature. required zoom int The zoom level, from 1 to 24. Defaults to 10. 10 Source code in geemap/eefolium.py def center_object ( self , ee_object , zoom = 10 ): \"\"\"Centers the map view on a given object. Args: ee_object (Element|Geometry): An Earth Engine object to center on - a geometry, image or feature. zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10. \"\"\" lat = 0 lon = 0 bounds = [[ lat , lon ], [ lat , lon ]] if isinstance ( ee_object , ee . geometry . Geometry ): centroid = ee_object . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . featurecollection . FeatureCollection ): centroid = ee_object . geometry () . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . image . Image ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] else : bounds = [[ 0 , 0 ], [ 0 , 0 ]] self . fit_bounds ( bounds , max_zoom = zoom ) publish ( self , name = None , headline = 'Untitled' , visibility = 'PUBLIC' , overwrite = True , open = True ) Publish the map to datapane.com Parameters: Name Type Description Default name str The URL of the map. Defaults to None. None headline str Title of the map. Defaults to 'Untitled'. 'Untitled' visibility str Visibility of the map. It can be one of the following: PUBLIC, PRIVATE, ORG. Defaults to 'PUBLIC'. 'PUBLIC' overwrite bool Whether to overwrite the existing map with the same name. Defaults to True. True open bool Whether to open the map. Defaults to True. True Source code in geemap/eefolium.py def publish ( self , name = None , headline = 'Untitled' , visibility = 'PUBLIC' , overwrite = True , open = True ): \"\"\"Publish the map to datapane.com Args: name (str, optional): The URL of the map. Defaults to None. headline (str, optional): Title of the map. Defaults to 'Untitled'. visibility (str, optional): Visibility of the map. It can be one of the following: PUBLIC, PRIVATE, ORG. Defaults to 'PUBLIC'. overwrite (bool, optional): Whether to overwrite the existing map with the same name. Defaults to True. open (bool, optional): Whether to open the map. Defaults to True. \"\"\" import webbrowser try : import datapane as dp except Exception as e : print ( 'The datapane Python package is not installed. You need to install and authenticate datapane first.' ) webbrowser . open_new_tab ( 'https://docs.datapane.com/tutorials/tut-getting-started' ) return import datapane as dp # import logging # logging.getLogger('googleapiclient.discovery_cache').setLevel(logging.ERROR) if name is None : name = 'folium_' + random_string ( 6 ) visibility = visibility . upper () if visibility not in [ 'PUBLIC' , 'PRIVATE' , 'ORG' ]: visibility = 'PRIVATE' if overwrite : delete_dp_report ( name ) report = dp . Report ( dp . Plot ( self )) report . publish ( name = name , headline = headline , visibility = visibility , open = open ) set_center ( self , lon , lat , zoom = 10 ) Centers the map view at a given coordinates with the given zoom level. Parameters: Name Type Description Default lon float The longitude of the center, in degrees. required lat float The latitude of the center, in degrees. required zoom int The zoom level, from 1 to 24. Defaults to 10. 10 Source code in geemap/eefolium.py def set_center ( self , lon , lat , zoom = 10 ): \"\"\"Centers the map view at a given coordinates with the given zoom level. Args: lon (float): The longitude of the center, in degrees. lat (float): The latitude of the center, in degrees. zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10. \"\"\" self . fit_bounds ([[ lat , lon ], [ lat , lon ]], max_zoom = zoom ) set_control_visibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ) Sets the visibility of the controls on the map. Parameters: Name Type Description Default layerControl bool Whether to show the control that allows the user to toggle layers on/off. Defaults to True. True fullscreenControl bool Whether to show the control that allows the user to make the map full-screen. Defaults to True. True latLngPopup bool Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. True Source code in geemap/eefolium.py def set_control_visibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ): \"\"\"Sets the visibility of the controls on the map. Args: layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True. fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True. latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. \"\"\" if layerControl : folium . LayerControl () . add_to ( self ) if fullscreenControl : plugins . Fullscreen () . add_to ( self ) if latLngPopup : folium . LatLngPopup () . add_to ( self ) set_options ( self , mapTypeId = 'HYBRID' , styles = {}, types = []) Adds Google basemap to the map. Parameters: Name Type Description Default mapTypeId str A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. 'HYBRID' styles [type] A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. {} types [type] A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. [] Source code in geemap/eefolium.py def setOptions ( self , mapTypeId = 'HYBRID' , styles = {}, types = []): \"\"\"Adds Google basemap to the map. Args: mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. styles ([type], optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. types ([type], optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. \"\"\" try : ee_basemaps [ mapTypeId ] . add_to ( self ) except : print ( 'Basemap can only be one of the following: {} ' . format ( ', ' . join ( ee_basemaps . keys ()))) setCenter ( self , lon , lat , zoom = 10 ) Centers the map view at a given coordinates with the given zoom level. Parameters: Name Type Description Default lon float The longitude of the center, in degrees. required lat float The latitude of the center, in degrees. required zoom int The zoom level, from 1 to 24. Defaults to 10. 10 Source code in geemap/eefolium.py def set_center ( self , lon , lat , zoom = 10 ): \"\"\"Centers the map view at a given coordinates with the given zoom level. Args: lon (float): The longitude of the center, in degrees. lat (float): The latitude of the center, in degrees. zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10. \"\"\" self . fit_bounds ([[ lat , lon ], [ lat , lon ]], max_zoom = zoom ) setControlVisibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ) Sets the visibility of the controls on the map. Parameters: Name Type Description Default layerControl bool Whether to show the control that allows the user to toggle layers on/off. Defaults to True. True fullscreenControl bool Whether to show the control that allows the user to make the map full-screen. Defaults to True. True latLngPopup bool Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. True Source code in geemap/eefolium.py def set_control_visibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ): \"\"\"Sets the visibility of the controls on the map. Args: layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True. fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True. latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. \"\"\" if layerControl : folium . LayerControl () . add_to ( self ) if fullscreenControl : plugins . Fullscreen () . add_to ( self ) if latLngPopup : folium . LatLngPopup () . add_to ( self ) setOptions ( self , mapTypeId = 'HYBRID' , styles = {}, types = []) Adds Google basemap to the map. Parameters: Name Type Description Default mapTypeId str A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. 'HYBRID' styles [type] A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. {} types [type] A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. [] Source code in geemap/eefolium.py def setOptions ( self , mapTypeId = 'HYBRID' , styles = {}, types = []): \"\"\"Adds Google basemap to the map. Args: mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. styles ([type], optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. types ([type], optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. \"\"\" try : ee_basemaps [ mapTypeId ] . add_to ( self ) except : print ( 'Basemap can only be one of the following: {} ' . format ( ', ' . join ( ee_basemaps . keys ()))) add_image_to_gif ( in_gif , out_gif , in_image , xy = None , image_size = ( 80 , 80 ), circle_mask = False ) Adds an image logo to a GIF image. Parameters: Name Type Description Default in_gif str Input file path to the GIF image. required out_gif str Output file path to the GIF image. required in_image str Input file path to the image. required xy tuple Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. None image_size tuple Resize image. Defaults to (80, 80). (80, 80) circle_mask bool Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False. False Source code in geemap/eefolium.py def add_image_to_gif ( in_gif , out_gif , in_image , xy = None , image_size = ( 80 , 80 ), circle_mask = False ): \"\"\"Adds an image logo to a GIF image. Args: in_gif (str): Input file path to the GIF image. out_gif (str): Output file path to the GIF image. in_image (str): Input file path to the image. xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. image_size (tuple, optional): Resize image. Defaults to (80, 80). circle_mask (bool, optional): Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False. \"\"\" import io import warnings from PIL import Image , ImageDraw , ImageSequence , ImageFilter warnings . simplefilter ( 'ignore' ) in_gif = os . path . abspath ( in_gif ) is_url = False if in_image . startswith ( 'http' ): is_url = True if not os . path . exists ( in_gif ): print ( 'The input gif file does not exist.' ) return if ( not is_url ) and ( not os . path . exists ( in_image )): print ( 'The provided logo file does not exist.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) try : image = Image . open ( in_gif ) except Exception as e : print ( 'An error occurred while opening the image.' ) print ( e ) return try : if in_image . startswith ( 'http' ): logo_raw_image = open_image_from_url ( in_image ) else : in_image = os . path . abspath ( in_image ) logo_raw_image = Image . open ( in_image ) except Exception as e : print ( e ) logo_raw_size = logo_raw_image . size image_size = min ( logo_raw_size [ 0 ], image_size [ 0 ]), min ( logo_raw_size [ 1 ], image_size [ 1 ]) logo_image = logo_raw_image . convert ( 'RGBA' ) logo_image . thumbnail ( image_size , Image . ANTIALIAS ) W , H = image . size mask_im = None if circle_mask : mask_im = Image . new ( \"L\" , image_size , 0 ) draw = ImageDraw . Draw ( mask_im ) draw . ellipse (( 0 , 0 , image_size [ 0 ], image_size [ 1 ]), fill = 255 ) if has_transparency ( logo_raw_image ): mask_im = logo_image . copy () if xy is None : # default logo location is 5% width and 5% height of the image. xy = ( int ( 0.05 * W ), int ( 0.05 * H )) elif ( xy is not None ) and ( not isinstance ( xy , tuple )) and ( len ( xy ) == 2 ): print ( \"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\" ) return elif all ( isinstance ( item , int ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( x > 0 ) and ( x < W ) and ( y > 0 ) and ( y < H ): pass else : print ( 'xy is out of bounds. x must be within [0, {} ], and y must be within [0, {} ]' . format ( W , H )) return elif all ( isinstance ( item , str ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( '%' in x ) and ( '%' in y ): try : x = int ( float ( x . replace ( '%' , '' )) / 100.0 * W ) y = int ( float ( y . replace ( '%' , '' )) / 100.0 * H ) xy = ( x , y ) except Exception as e : print ( \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\" ) return else : print ( \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\" ) return try : frames = [] for index , frame in enumerate ( ImageSequence . Iterator ( image )): frame = frame . convert ( 'RGBA' ) frame . paste ( logo_image , xy , mask_im ) b = io . BytesIO () frame . save ( b , format = \"GIF\" ) frame = Image . open ( b ) frames . append ( frame ) frames [ 0 ] . save ( out_gif , save_all = True , append_images = frames [ 1 :]) except Exception as e : print ( e ) return add_text_to_gif ( in_gif , out_gif , xy = None , text_sequence = None , font_type = 'arial.ttf' , font_size = 20 , font_color = '#000000' , add_progress_bar = True , progress_bar_color = 'white' , progress_bar_height = 5 , duration = 100 , loop = 0 ) Adds animated text to a GIF image. Parameters: Name Type Description Default in_gif str The file path to the input GIF image. required out_gif str The file path to the output GIF image. required xy tuple Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. None text_sequence int, str, list Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None. None font_type str Font type. Defaults to \"arial.ttf\". 'arial.ttf' font_size int Font size. Defaults to 20. 20 font_color str Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff'). Defaults to '#000000'. '#000000' add_progress_bar bool Whether to add a progress bar at the bottom of the GIF. Defaults to True. True progress_bar_color str Color for the progress bar. Defaults to 'white'. 'white' progress_bar_height int Height of the progress bar. Defaults to 5. 5 duration int controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100. 100 loop int controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0. 0 Source code in geemap/eefolium.py def add_text_to_gif ( in_gif , out_gif , xy = None , text_sequence = None , font_type = \"arial.ttf\" , font_size = 20 , font_color = '#000000' , add_progress_bar = True , progress_bar_color = 'white' , progress_bar_height = 5 , duration = 100 , loop = 0 ): \"\"\"Adds animated text to a GIF image. Args: in_gif (str): The file path to the input GIF image. out_gif (str): The file path to the output GIF image. xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None. font_type (str, optional): Font type. Defaults to \"arial.ttf\". font_size (int, optional): Font size. Defaults to 20. font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff'). Defaults to '#000000'. add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True. progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'. progress_bar_height (int, optional): Height of the progress bar. Defaults to 5. duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100. loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0. \"\"\" import io import pkg_resources import warnings from PIL import Image , ImageDraw , ImageSequence , ImageFont warnings . simplefilter ( 'ignore' ) pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) default_font = os . path . join ( pkg_dir , 'data/fonts/arial.ttf' ) in_gif = os . path . abspath ( in_gif ) out_gif = os . path . abspath ( out_gif ) if not os . path . exists ( in_gif ): print ( 'The input gif file does not exist.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) if font_type == 'arial.ttf' : font = ImageFont . truetype ( default_font , font_size ) else : try : font_list = system_fonts ( show_full_path = True ) font_names = [ os . path . basename ( f ) for f in font_list ] if ( font_type in font_list ) or ( font_type in font_names ): font = ImageFont . truetype ( font_type , font_size ) else : print ( 'The specified font type could not be found on your system. Using the default font instead.' ) font = ImageFont . truetype ( default_font , font_size ) except Exception as e : print ( e ) font = ImageFont . truetype ( default_font , font_size ) color = check_color ( font_color ) progress_bar_color = check_color ( progress_bar_color ) try : image = Image . open ( in_gif ) except Exception as e : print ( 'An error occurred while opening the gif.' ) print ( e ) return count = image . n_frames W , H = image . size progress_bar_widths = [ i * 1.0 / count * W for i in range ( 1 , count + 1 )] progress_bar_shapes = [[( 0 , H - progress_bar_height ), ( x , H )] for x in progress_bar_widths ] if xy is None : # default text location is 5% width and 5% height of the image. xy = ( int ( 0.05 * W ), int ( 0.05 * H )) elif ( xy is not None ) and ( not isinstance ( xy , tuple )) and ( len ( xy ) == 2 ): print ( \"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\" ) return elif all ( isinstance ( item , int ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( x > 0 ) and ( x < W ) and ( y > 0 ) and ( y < H ): pass else : print ( 'xy is out of bounds. x must be within [0, {} ], and y must be within [0, {} ]' . format ( W , H )) return elif all ( isinstance ( item , str ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( '%' in x ) and ( '%' in y ): try : x = int ( float ( x . replace ( '%' , '' )) / 100.0 * W ) y = int ( float ( y . replace ( '%' , '' )) / 100.0 * H ) xy = ( x , y ) except Exception as e : print ( \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\" ) return else : print ( \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\" ) return if text_sequence is None : text = [ str ( x ) for x in range ( 1 , count + 1 )] elif isinstance ( text_sequence , int ): text = [ str ( x ) for x in range ( text_sequence , text_sequence + count + 1 )] elif isinstance ( text_sequence , str ): try : text_sequence = int ( text_sequence ) text = [ str ( x ) for x in range ( text_sequence , text_sequence + count + 1 )] except Exception as e : text = [ text_sequence ] * count elif isinstance ( text_sequence , list ) and len ( text_sequence ) != count : print ( 'The length of the text sequence must be equal to the number ( {} ) of frames in the gif.' . format ( count )) return else : text = [ str ( x ) for x in text_sequence ] try : frames = [] # Loop over each frame in the animated image for index , frame in enumerate ( ImageSequence . Iterator ( image )): # Draw the text on the frame frame = frame . convert ( 'RGB' ) draw = ImageDraw . Draw ( frame ) # w, h = draw.textsize(text[index]) draw . text ( xy , text [ index ], font = font , fill = color ) if add_progress_bar : draw . rectangle ( progress_bar_shapes [ index ], fill = progress_bar_color ) del draw b = io . BytesIO () frame . save ( b , format = \"GIF\" ) frame = Image . open ( b ) frames . append ( frame ) # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/ # Save the frames as a new image frames [ 0 ] . save ( out_gif , save_all = True , append_images = frames [ 1 :], duration = duration , loop = loop , optimize = True ) except Exception as e : print ( e ) return check_color ( in_color ) Checks the input color and returns the corresponding hex color code. Parameters: Name Type Description Default in_color str or tuple It can be a string (e.g., 'red', '#ffff00') or tuple (e.g., (255, 127, 0)). required Returns: Type Description str A hex color code. Source code in geemap/eefolium.py def check_color ( in_color ): \"\"\"Checks the input color and returns the corresponding hex color code. Args: in_color (str or tuple): It can be a string (e.g., 'red', '#ffff00') or tuple (e.g., (255, 127, 0)). Returns: str: A hex color code. \"\"\" out_color = '#000000' # default black color if isinstance ( in_color , tuple ) and len ( in_color ) == 3 : if all ( isinstance ( item , int ) for item in in_color ): rescaled_color = [ x / 255.0 for x in in_color ] out_color = colour . Color ( rgb = tuple ( rescaled_color )) return out_color . hex_l else : print ( 'RGB color must be a tuple with three integer values ranging from 0 to 255.' ) return else : try : out_color = colour . Color ( in_color ) return out_color . hex_l except Exception as e : print ( 'The provided color is invalid. Using the default black color.' ) print ( e ) return out_color check_install ( package ) Checks whether a package is installed. If not, it will install the package. Parameters: Name Type Description Default package str The name of the package to check. required Source code in geemap/eefolium.py def check_install ( package ): \"\"\"Checks whether a package is installed. If not, it will install the package. Args: package (str): The name of the package to check. \"\"\" import subprocess try : __import__ ( package ) # print('{} is already installed.'.format(package)) except ImportError : print ( ' {} is not installed. Installing ...' . format ( package )) try : subprocess . check_call ([ \"python\" , '-m' , 'pip' , 'install' , package ]) except Exception as e : print ( 'Failed to install {} ' . format ( package )) print ( e ) print ( \" {} has been installed successfully.\" . format ( package )) clone_repo ( out_dir = '.' , unzip = True ) Clones the geemap GitHub repository. Parameters: Name Type Description Default out_dir str Output folder for the repo. Defaults to '.'. '.' unzip bool Whether to unzip the repository. Defaults to True. True Source code in geemap/eefolium.py def clone_repo ( out_dir = '.' , unzip = True ): \"\"\"Clones the geemap GitHub repository. Args: out_dir (str, optional): Output folder for the repo. Defaults to '.'. unzip (bool, optional): Whether to unzip the repository. Defaults to True. \"\"\" url = 'https://github.com/giswqs/geemap/archive/master.zip' filename = 'geemap-master.zip' download_from_url ( url , out_file_name = filename , out_dir = out_dir , unzip = unzip ) copy_credentials_to_colab () Copies ee credentials from Google Drive to Google Colab. Source code in geemap/eefolium.py def copy_credentials_to_colab (): \"\"\"Copies ee credentials from Google Drive to Google Colab. \"\"\" import shutil src = '/content/drive/My Drive/.config/earthengine/credentials' dst = '/root/.config/earthengine/credentials' wd = os . path . dirname ( dst ) if not os . path . exists ( wd ): os . makedirs ( wd ) shutil . copyfile ( src , dst ) copy_credentials_to_drive () Copies ee credentials from Google Colab to Google Drive. Source code in geemap/eefolium.py def copy_credentials_to_drive (): \"\"\"Copies ee credentials from Google Colab to Google Drive. \"\"\" import shutil src = '/root/.config/earthengine/credentials' dst = '/content/drive/My Drive/.config/earthengine/credentials' wd = os . path . dirname ( dst ) if not os . path . exists ( wd ): os . makedirs ( wd ) shutil . copyfile ( src , dst ) create_code_cell ( code = '' , where = 'below' ) Creates a code cell in the IPython Notebook. Parameters: Name Type Description Default code str Code to fill the new code cell with. Defaults to ''. '' where str Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. 'below' Source code in geemap/eefolium.py def create_code_cell ( code = '' , where = 'below' ): \"\"\"Creates a code cell in the IPython Notebook. Args: code (str, optional): Code to fill the new code cell with. Defaults to ''. where (str, optional): Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. \"\"\" import base64 from IPython.display import Javascript , display encoded_code = ( base64 . b64encode ( str . encode ( code ))) . decode () display ( Javascript ( \"\"\" var code = IPython.notebook.insert_cell_ {0} ('code'); code.set_text(atob(\" {1} \")); \"\"\" . format ( where , encoded_code ))) create_colorbar ( width = 150 , height = 30 , palette = [ 'blue' , 'green' , 'red' ], add_ticks = True , add_labels = True , labels = None , vertical = False , out_file = None , font_type = 'arial.ttf' , font_size = 12 , font_color = 'black' , add_outline = True , outline_color = 'black' ) Creates a colorbar based on the provided palette. Parameters: Name Type Description Default width int Width of the colorbar in pixels. Defaults to 150. 150 height int Height of the colorbar in pixels. Defaults to 30. 30 palette list Palette for the colorbar. Each color can be provided as a string (e.g., 'red'), a hex string (e.g., '#ff0000'), or an RGB tuple (255, 0, 255). Defaults to ['blue', 'green', 'red']. ['blue', 'green', 'red'] add_ticks bool Whether to add tick markers to the colorbar. Defaults to True. True add_labels bool Whether to add labels to the colorbar. Defaults to True. True labels list A list of labels to add to the colorbar. Defaults to None. None vertical bool Whether to rotate the colorbar vertically. Defaults to False. False out_file str File path to the output colorbar in png format. Defaults to None. None font_type str Font type to use for labels. Defaults to 'arial.ttf'. 'arial.ttf' font_size int Font size to use for labels. Defaults to 12. 12 font_color str Font color to use for labels. Defaults to 'black'. 'black' add_outline bool Whether to add an outline to the colorbar. Defaults to True. True outline_color str Color for the outline of the colorbar. Defaults to 'black'. 'black' Returns: Type Description str File path of the output colorbar in png format. Source code in geemap/eefolium.py def create_colorbar ( width = 150 , height = 30 , palette = [ 'blue' , 'green' , 'red' ], add_ticks = True , add_labels = True , labels = None , vertical = False , out_file = None , font_type = 'arial.ttf' , font_size = 12 , font_color = 'black' , add_outline = True , outline_color = 'black' ): \"\"\"Creates a colorbar based on the provided palette. Args: width (int, optional): Width of the colorbar in pixels. Defaults to 150. height (int, optional): Height of the colorbar in pixels. Defaults to 30. palette (list, optional): Palette for the colorbar. Each color can be provided as a string (e.g., 'red'), a hex string (e.g., '#ff0000'), or an RGB tuple (255, 0, 255). Defaults to ['blue', 'green', 'red']. add_ticks (bool, optional): Whether to add tick markers to the colorbar. Defaults to True. add_labels (bool, optional): Whether to add labels to the colorbar. Defaults to True. labels (list, optional): A list of labels to add to the colorbar. Defaults to None. vertical (bool, optional): Whether to rotate the colorbar vertically. Defaults to False. out_file (str, optional): File path to the output colorbar in png format. Defaults to None. font_type (str, optional): Font type to use for labels. Defaults to 'arial.ttf'. font_size (int, optional): Font size to use for labels. Defaults to 12. font_color (str, optional): Font color to use for labels. Defaults to 'black'. add_outline (bool, optional): Whether to add an outline to the colorbar. Defaults to True. outline_color (str, optional): Color for the outline of the colorbar. Defaults to 'black'. Returns: str: File path of the output colorbar in png format. \"\"\" import decimal import io import math import pkg_resources import warnings from colour import Color from PIL import Image , ImageDraw , ImageFont warnings . simplefilter ( 'ignore' ) pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) if out_file is None : filename = 'colorbar_' + random_string () + '.png' out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) out_file = os . path . join ( out_dir , filename ) elif not out_file . endswith ( '.png' ): print ( 'The output file must end with .png' ) return else : out_file = os . path . abspath ( out_file ) if not os . path . exists ( os . path . dirname ( out_file )): os . makedirs ( os . path . dirname ( out_file )) im = Image . new ( 'RGBA' , ( width , height )) ld = im . load () def float_range ( start , stop , step ): while start < stop : yield float ( start ) start += decimal . Decimal ( step ) n_colors = len ( palette ) decimal_places = 2 rgb_colors = [ Color ( check_color ( c )) . rgb for c in palette ] keys = [ round ( c , decimal_places ) for c in list ( float_range ( 0 , 1.0001 , 1.0 / ( n_colors - 1 )))] heatmap = [] for index , item in enumerate ( keys ): pair = [ item , rgb_colors [ index ]] heatmap . append ( pair ) def gaussian ( x , a , b , c , d = 0 ): return a * math . exp ( - ( x - b ) ** 2 / ( 2 * c ** 2 )) + d def pixel ( x , width = 100 , map = [], spread = 1 ): width = float ( width ) r = sum ([ gaussian ( x , p [ 1 ][ 0 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) g = sum ([ gaussian ( x , p [ 1 ][ 1 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) b = sum ([ gaussian ( x , p [ 1 ][ 2 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) return min ( 1.0 , r ), min ( 1.0 , g ), min ( 1.0 , b ) for x in range ( im . size [ 0 ]): r , g , b = pixel ( x , width = width , map = heatmap ) r , g , b = [ int ( 256 * v ) for v in ( r , g , b )] for y in range ( im . size [ 1 ]): ld [ x , y ] = r , g , b if add_outline : draw = ImageDraw . Draw ( im ) draw . rectangle ([( 0 , 0 ), ( width - 1 , height - 1 )], outline = check_color ( outline_color )) del draw if add_ticks : tick_length = height * 0.1 x = [ key * width for key in keys ] y_top = height - tick_length y_bottom = height draw = ImageDraw . Draw ( im ) for i in x : shape = [( i , y_top ), ( i , y_bottom )] draw . line ( shape , fill = 'black' , width = 0 ) del draw if vertical : im = im . transpose ( Image . ROTATE_90 ) width , height = im . size if labels is None : labels = [ str ( c ) for c in keys ] elif len ( labels ) == 2 : try : lowerbound = float ( labels [ 0 ]) upperbound = float ( labels [ 1 ]) step = ( upperbound - lowerbound ) / ( len ( palette ) - 1 ) labels = [ str ( lowerbound + c * step ) for c in range ( 0 , len ( palette ))] except Exception as e : print ( e ) print ( 'The labels are invalid.' ) return elif len ( labels ) == len ( palette ): labels = [ str ( c ) for c in labels ] else : print ( 'The labels must have the same length as the palette.' ) return if add_labels : default_font = os . path . join ( pkg_dir , 'data/fonts/arial.ttf' ) if font_type == 'arial.ttf' : font = ImageFont . truetype ( default_font , font_size ) else : try : font_list = system_fonts ( show_full_path = True ) font_names = [ os . path . basename ( f ) for f in font_list ] if ( font_type in font_list ) or ( font_type in font_names ): font = ImageFont . truetype ( font_type , font_size ) else : print ( 'The specified font type could not be found on your system. Using the default font instead.' ) font = ImageFont . truetype ( default_font , font_size ) except Exception as e : print ( e ) font = ImageFont . truetype ( default_font , font_size ) font_color = check_color ( font_color ) draw = ImageDraw . Draw ( im ) w , h = draw . textsize ( labels [ 0 ], font = font ) for label in labels : w_tmp , h_tmp = draw . textsize ( label , font ) if w_tmp > w : w = w_tmp if h_tmp > h : h = h_tmp W , H = width + w * 2 , height + h * 2 background = Image . new ( 'RGBA' , ( W , H )) draw = ImageDraw . Draw ( background ) if vertical : xy = ( 0 , h ) else : xy = ( w , 0 ) background . paste ( im , xy , im ) for index , label in enumerate ( labels ): w_tmp , h_tmp = draw . textsize ( label , font ) if vertical : spacing = 5 x = width + spacing y = int ( height + h - keys [ index ] * height - h_tmp / 2 - 1 ) draw . text (( x , y ), label , font = font , fill = font_color ) else : x = int ( keys [ index ] * width + w - w_tmp / 2 ) spacing = int ( h * 0.05 ) y = height + spacing draw . text (( x , y ), label , font = font , fill = font_color ) im = background . copy () im . save ( out_file ) return out_file credentials_in_colab () Checks if the ee credentials file exists in Google Colab. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/eefolium.py def credentials_in_colab (): \"\"\"Checks if the ee credentials file exists in Google Colab. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" credentials_path = '/root/.config/earthengine/credentials' if os . path . exists ( credentials_path ): return True else : return False credentials_in_drive () Checks if the ee credentials file exists in Google Drive. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/eefolium.py def credentials_in_drive (): \"\"\"Checks if the ee credentials file exists in Google Drive. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" credentials_path = '/content/drive/My Drive/.config/earthengine/credentials' if os . path . exists ( credentials_path ): return True else : return False delete_dp_report ( name ) Deletes a datapane report. Parameters: Name Type Description Default name str Name of the report to delete. required Source code in geemap/eefolium.py def delete_dp_report ( name ): \"\"\"Deletes a datapane report. Args: name (str): Name of the report to delete. \"\"\" try : import datapane as dp reports = dp . Report . list () items = list ( reports ) names = list ( map ( lambda item : item [ 'name' ], items )) if name in names : report = dp . Report . get ( name ) url = report . blocks [ 0 ][ 'url' ] # print('Deleting {}...'.format(url)) dp . Report . delete ( dp . Report . by_id ( url )) except Exception as e : print ( e ) return delete_dp_reports () Deletes all datapane reports. Source code in geemap/eefolium.py def delete_dp_reports (): \"\"\"Deletes all datapane reports. \"\"\" try : import datapane as dp reports = dp . Report . list () for item in reports : print ( item [ 'name' ]) report = dp . Report . get ( item [ 'name' ]) url = report . blocks [ 0 ][ 'url' ] print ( 'Deleting {} ...' . format ( url )) dp . Report . delete ( dp . Report . by_id ( url )) except Exception as e : print ( e ) return download_ee_video ( collection , video_args , out_gif ) Downloads a video thumbnail as a GIF image from Earth Engine. Parameters: Name Type Description Default collection object An ee.ImageCollection. required video_args [type] Parameters for expring the video thumbnail. required out_gif str File path to the output GIF. required Source code in geemap/eefolium.py def download_ee_video ( collection , video_args , out_gif ): \"\"\"Downloads a video thumbnail as a GIF image from Earth Engine. Args: collection (object): An ee.ImageCollection. video_args ([type]): Parameters for expring the video thumbnail. out_gif (str): File path to the output GIF. \"\"\" import requests out_gif = os . path . abspath ( out_gif ) if not out_gif . endswith ( \".gif\" ): print ( 'The output file must have an extension of .gif.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) if 'region' in video_args . keys (): roi = video_args [ 'region' ] if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return video_args [ 'region' ] = roi try : print ( 'Generating URL...' ) url = collection . getVideoThumbURL ( video_args ) print ( 'Downloading GIF image from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading.' ) return else : with open ( out_gif , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) print ( 'The GIF image has been saved to: {} ' . format ( out_gif )) except Exception as e : print ( e ) ee_data_html ( asset ) Generates HTML from an asset to be used in the HTML widget. Parameters: Name Type Description Default asset dict A dictionary containing an Earth Engine asset. required Returns: Type Description str A string containing HTML. Source code in geemap/eefolium.py def ee_data_html ( asset ): \"\"\"Generates HTML from an asset to be used in the HTML widget. Args: asset (dict): A dictionary containing an Earth Engine asset. Returns: str: A string containing HTML. \"\"\" template = ''' <html> <body> <h3>asset_title</h3> <h4>Dataset Availability</h4> <p style=\"margin-left: 40px\">asset_dates</p> <h4>Earth Engine Snippet</h4> <p style=\"margin-left: 40px\">ee_id_snippet</p> <h4>Earth Engine Data Catalog</h4> <p style=\"margin-left: 40px\"><a href=\"asset_url\" target=\"_blank\">asset_id</a></p> <h4>Dataset Thumbnail</h4> <img src=\"thumbnail_url\"> </body> </html> ''' try : text = template . replace ( 'asset_title' , asset [ 'title' ]) text = text . replace ( 'asset_dates' , asset [ 'dates' ]) text = text . replace ( 'ee_id_snippet' , asset [ 'ee_id_snippet' ]) text = text . replace ( 'asset_id' , asset [ 'id' ]) text = text . replace ( 'asset_url' , asset [ 'asset_url' ]) # asset['thumbnail'] = ee_data_thumbnail(asset['id']) text = text . replace ( 'thumbnail_url' , asset [ 'thumbnail_url' ]) return text except Exception as e : print ( e ) return ee_data_thumbnail ( asset_id ) Retrieves the thumbnail URL of an Earth Engine asset. Parameters: Name Type Description Default asset_id str An Earth Engine asset id. required Returns: Type Description str An http url of the thumbnail. Source code in geemap/eefolium.py def ee_data_thumbnail ( asset_id ): \"\"\"Retrieves the thumbnail URL of an Earth Engine asset. Args: asset_id (str): An Earth Engine asset id. Returns: str: An http url of the thumbnail. \"\"\" import requests import urllib from bs4 import BeautifulSoup asset_uid = asset_id . replace ( '/' , '_' ) asset_url = \"https://developers.google.com/earth-engine/datasets/catalog/ {} \" . format ( asset_uid ) thumbnail_url = 'https://mw1.google.com/ges/dd/images/ {} _sample.png' . format ( asset_uid ) r = requests . get ( thumbnail_url ) try : if r . status_code != 200 : html_page = urllib . request . urlopen ( asset_url ) soup = BeautifulSoup ( html_page , features = \"html.parser\" ) for img in soup . findAll ( 'img' ): if 'sample.png' in img . get ( 'src' ): thumbnail_url = img . get ( 'src' ) return thumbnail_url return thumbnail_url except Exception as e : print ( e ) return ee_export_image ( ee_object , filename , scale = None , crs = None , region = None , file_per_band = False ) Exports an ee.Image as a GeoTIFF. Parameters: Name Type Description Default ee_object object The ee.Image to download. required filename str Output filename for the exported image. required scale float A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. None crs str A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. None region object A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. None file_per_band bool Whether to produce a different GeoTIFF per band. Defaults to False. False Source code in geemap/eefolium.py def ee_export_image ( ee_object , filename , scale = None , crs = None , region = None , file_per_band = False ): \"\"\"Exports an ee.Image as a GeoTIFF. Args: ee_object (object): The ee.Image to download. filename (str): Output filename for the exported image. scale (float, optional): A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. crs (str, optional): A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. region (object, optional): A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. file_per_band (bool, optional): Whether to produce a different GeoTIFF per band. Defaults to False. \"\"\" import requests import zipfile ee_initialize () if not isinstance ( ee_object , ee . Image ): print ( 'The ee_object must be an ee.Image.' ) return filename = os . path . abspath ( filename ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () filename_zip = filename . replace ( '.tif' , '.zip' ) if filetype != 'tif' : print ( 'The filename must end with .tif' ) return try : print ( 'Generating URL ...' ) params = { 'name' : name , 'filePerBand' : file_per_band } if scale is None : scale = ee_object . projection () . nominalScale () . multiply ( 10 ) params [ 'scale' ] = scale if region is None : region = ee_object . geometry () params [ 'region' ] = region if crs is not None : params [ 'crs' ] = crs url = ee_object . getDownloadURL ( params ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading.' ) return with open ( filename_zip , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) except Exception as e : print ( 'An error occurred while downloading.' ) print ( e ) return try : z = zipfile . ZipFile ( filename_zip ) z . extractall ( os . path . dirname ( filename )) os . remove ( filename_zip ) if file_per_band : print ( 'Data downloaded to {} ' . format ( os . path . dirname ( filename ))) else : print ( 'Data downloaded to {} ' . format ( filename )) except Exception as e : print ( e ) ee_export_image_collection ( ee_object , out_dir , scale = None , crs = None , region = None , file_per_band = False ) Exports an ImageCollection as GeoTIFFs. Parameters: Name Type Description Default ee_object object The ee.Image to download. required out_dir str The output directory for the exported images. required scale float A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. None crs str A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. None region object A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. None file_per_band bool Whether to produce a different GeoTIFF per band. Defaults to False. False Source code in geemap/eefolium.py def ee_export_image_collection ( ee_object , out_dir , scale = None , crs = None , region = None , file_per_band = False ): \"\"\"Exports an ImageCollection as GeoTIFFs. Args: ee_object (object): The ee.Image to download. out_dir (str): The output directory for the exported images. scale (float, optional): A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. crs (str, optional): A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. region (object, optional): A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. file_per_band (bool, optional): Whether to produce a different GeoTIFF per band. Defaults to False. \"\"\" import requests import zipfile ee_initialize () if not isinstance ( ee_object , ee . ImageCollection ): print ( 'The ee_object must be an ee.ImageCollection.' ) return if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) try : count = int ( ee_object . size () . getInfo ()) print ( \"Total number of images: {} \\n \" . format ( count )) for i in range ( 0 , count ): image = ee . Image ( ee_object . toList ( count ) . get ( i )) name = image . get ( 'system:index' ) . getInfo () + '.tif' filename = os . path . join ( os . path . abspath ( out_dir ), name ) print ( 'Exporting {} / {} : {} ' . format ( i + 1 , count , name )) ee_export_image ( image , filename = filename , scale = scale , crs = crs , region = region , file_per_band = file_per_band ) print ( ' \\n ' ) except Exception as e : print ( e ) ee_export_vector ( ee_object , filename , selectors = None ) Exports Earth Engine FeatureCollection to other formats, including shp, csv, json, kml, and kmz. Parameters: Name Type Description Default ee_object object ee.FeatureCollection to export. required filename str Output file name. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/eefolium.py def ee_export_vector ( ee_object , filename , selectors = None ): \"\"\"Exports Earth Engine FeatureCollection to other formats, including shp, csv, json, kml, and kmz. Args: ee_object (object): ee.FeatureCollection to export. filename (str): Output file name. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" import requests import zipfile ee_initialize () if not isinstance ( ee_object , ee . FeatureCollection ): print ( 'The ee_object must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' ] filename = os . path . abspath ( filename ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () filename_shp = filename if filetype == 'shp' : filename = filename . replace ( '.shp' , '.zip' ) if not ( filetype . lower () in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return if selectors is None : selectors = ee_object . first () . propertyNames () . getInfo () elif not isinstance ( selectors , list ): print ( \"selectors must be a list, such as ['attribute1', 'attribute2']\" ) return else : allowed_attributes = ee_object . first () . propertyNames () . getInfo () for attribute in selectors : if not ( attribute in allowed_attributes ): print ( 'Attributes must be one chosen from: {} ' . format ( ', ' . join ( allowed_attributes ))) return try : print ( 'Generating URL ...' ) url = ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading. \\n Retrying ...' ) try : new_ee_object = ee_object . map ( filter_polygons ) print ( 'Generating URL ...' ) url = new_ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) except Exception as e : print ( e ) with open ( filename , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) except Exception as e : print ( 'An error occurred while downloading.' ) print ( e ) return try : if filetype == 'shp' : z = zipfile . ZipFile ( filename ) z . extractall ( os . path . dirname ( filename )) os . remove ( filename ) filename = filename . replace ( '.zip' , '.shp' ) print ( 'Data downloaded to {} ' . format ( filename )) except Exception as e : print ( e ) ee_initialize ( token_name = 'EARTHENGINE_TOKEN' ) Authenticates Earth Engine and initialize an Earth Engine session Source code in geemap/eefolium.py def ee_initialize ( token_name = 'EARTHENGINE_TOKEN' ): \"\"\"Authenticates Earth Engine and initialize an Earth Engine session \"\"\" try : ee_token = os . environ . get ( token_name ) if ee_token is not None : credential = '{\"refresh_token\":\" %s \"}' % ee_token credential_file_path = os . path . expanduser ( \"~/.config/earthengine/\" ) os . makedirs ( credential_file_path , exist_ok = True ) with open ( credential_file_path + 'credentials' , 'w' ) as file : file . write ( credential ) elif in_colab_shell (): if credentials_in_drive () and ( not credentials_in_colab ()): copy_credentials_to_colab () elif not credentials_in_colab : ee . Authenticate () if is_drive_mounted () and ( not credentials_in_drive ()): copy_credentials_to_drive () else : if is_drive_mounted (): copy_credentials_to_drive () ee . Initialize () except : ee . Authenticate () ee . Initialize () ee_tile_layer ( ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ) Converts and Earth Engine layer to ipyleaflet TileLayer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer untitled'. 'Layer untitled' shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/eefolium.py def ee_tile_layer ( ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ): \"\"\"Converts and Earth Engine layer to ipyleaflet TileLayer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer untitled'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" ee_initialize () image = None if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) tile_layer = ipyleaflet . TileLayer ( url = map_id_dict [ 'tile_fetcher' ] . url_format , attribution = 'Google Earth Engine' , name = name , opacity = opacity , visible = True # visible=shown ) return tile_layer ee_to_csv ( ee_object , filename , selectors = None ) Downloads an ee.FeatureCollection as a CSV file. Parameters: Name Type Description Default ee_object object ee.FeatureCollection required filename str The output filepath of the CSV file. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/eefolium.py def ee_to_csv ( ee_object , filename , selectors = None ): \"\"\"Downloads an ee.FeatureCollection as a CSV file. Args: ee_object (object): ee.FeatureCollection filename (str): The output filepath of the CSV file. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" ee_initialize () try : if filename . lower () . endswith ( '.csv' ): ee_export_vector ( ee_object = ee_object , filename = filename , selectors = selectors ) else : print ( 'The filename must end with .csv' ) except Exception as e : print ( e ) ee_to_geojson ( ee_object , out_json = None ) Converts Earth Engine object to geojson. Parameters: Name Type Description Default ee_object object An Earth Engine object. required Returns: Type Description object GeoJSON object. Source code in geemap/eefolium.py def ee_to_geojson ( ee_object , out_json = None ): \"\"\"Converts Earth Engine object to geojson. Args: ee_object (object): An Earth Engine object. Returns: object: GeoJSON object. \"\"\" from json import dumps ee_initialize () try : if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): json_object = ee_object . getInfo () if out_json is not None : out_json = os . path . abspath ( out_json ) if not os . path . exists ( os . path . dirname ( out_json )): os . makedirs ( os . path . dirname ( out_json )) geojson = open ( out_json , \"w\" ) geojson . write ( dumps ({ \"type\" : \"FeatureCollection\" , \"features\" : json_object }, indent = 2 ) + \" \\n \" ) geojson . close () return json_object else : print ( \"Could not convert the Earth Engine object to geojson\" ) except Exception as e : print ( e ) ee_to_numpy ( ee_object , bands = None , region = None , properties = None , default_value = None ) Extracts a rectangular region of pixels from an image into a 2D numpy array per band. Parameters: Name Type Description Default ee_object object The image to sample. required bands list The list of band names to extract. Please make sure that all bands have the same spatial resolution. Defaults to None. None region object The region whose projected bounding box is used to sample the image. The maximum number of pixels you can export is 262,144. Resampling and reprojecting all bands to a fixed scale can be useful. Defaults to the footprint in each band. None properties list The properties to copy over from the sampled image. Defaults to all non-system properties. None default_value float A default value used when a sampled pixel is masked or outside a band's footprint. Defaults to None. None Returns: Type Description array A 3D numpy array. Source code in geemap/eefolium.py def ee_to_numpy ( ee_object , bands = None , region = None , properties = None , default_value = None ): \"\"\"Extracts a rectangular region of pixels from an image into a 2D numpy array per band. Args: ee_object (object): The image to sample. bands (list, optional): The list of band names to extract. Please make sure that all bands have the same spatial resolution. Defaults to None. region (object, optional): The region whose projected bounding box is used to sample the image. The maximum number of pixels you can export is 262,144. Resampling and reprojecting all bands to a fixed scale can be useful. Defaults to the footprint in each band. properties (list, optional): The properties to copy over from the sampled image. Defaults to all non-system properties. default_value (float, optional): A default value used when a sampled pixel is masked or outside a band's footprint. Defaults to None. Returns: array: A 3D numpy array. \"\"\" import numpy as np if not isinstance ( ee_object , ee . Image ): print ( 'The input must be an ee.Image.' ) return if region is None : region = ee_object . geometry () try : if bands is not None : ee_object = ee_object . select ( bands ) else : bands = ee_object . bandNames () . getInfo () band_count = len ( bands ) band_arrs = ee_object . sampleRectangle ( region = region , properties = properties , defaultValue = default_value ) band_values = [] for band in bands : band_arr = band_arrs . get ( band ) . getInfo () band_value = np . array ( band_arr ) band_values . append ( band_value ) image = np . dstack ( band_values ) return image except Exception as e : print ( e ) ee_to_shp ( ee_object , filename , selectors = None ) Downloads an ee.FeatureCollection as a shapefile. Parameters: Name Type Description Default ee_object object ee.FeatureCollection required filename str The output filepath of the shapefile. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/eefolium.py def ee_to_shp ( ee_object , filename , selectors = None ): \"\"\"Downloads an ee.FeatureCollection as a shapefile. Args: ee_object (object): ee.FeatureCollection filename (str): The output filepath of the shapefile. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" ee_initialize () try : if filename . lower () . endswith ( '.shp' ): ee_export_vector ( ee_object = ee_object , filename = filename , selectors = selectors ) else : print ( 'The filename must end with .shp' ) except Exception as e : print ( e ) filter_polygons ( ftr ) Converts GeometryCollection to Polygon/MultiPolygon Parameters: Name Type Description Default ftr object ee.Feature required Returns: Type Description object ee.Feature Source code in geemap/eefolium.py def filter_polygons ( ftr ): \"\"\"Converts GeometryCollection to Polygon/MultiPolygon Args: ftr (object): ee.Feature Returns: object: ee.Feature \"\"\" ee_initialize () geometries = ftr . geometry () . geometries () geometries = geometries . map ( lambda geo : ee . Feature ( ee . Geometry ( geo )) . set ( 'geoType' , ee . Geometry ( geo ) . type ())) polygons = ee . FeatureCollection ( geometries ) . filter ( ee . Filter . eq ( 'geoType' , 'Polygon' )) . geometry () return ee . Feature ( polygons ) . copyProperties ( ftr ) geocode ( location , max_rows = 10 , reverse = False ) Search location by address and lat/lon coordinates. Parameters: Name Type Description Default location str Place name or address required max_rows int Maximum number of records to return. Defaults to 10. 10 reverse bool Search place based on coordinates. Defaults to False. False Returns: Type Description list Returns a list of locations. Source code in geemap/eefolium.py def geocode ( location , max_rows = 10 , reverse = False ): \"\"\"Search location by address and lat/lon coordinates. Args: location (str): Place name or address max_rows (int, optional): Maximum number of records to return. Defaults to 10. reverse (bool, optional): Search place based on coordinates. Defaults to False. Returns: list: Returns a list of locations. \"\"\" if not isinstance ( location , str ): print ( 'The location must be a string.' ) return None if not reverse : locations = [] addresses = set () g = geocoder . arcgis ( location , maxRows = max_rows ) for result in g : address = result . address if not address in addresses : addresses . add ( address ) locations . append ( result ) if len ( locations ) > 0 : return locations else : return None else : try : if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return g = geocoder . arcgis ( latlon , method = 'reverse' ) locations = [] addresses = set () for result in g : address = result . address if not address in addresses : addresses . add ( address ) locations . append ( result ) if len ( locations ) > 0 : return locations else : return None except Exception as e : print ( e ) return None geojson_to_ee ( geo_json , geodesic = True ) Converts a geojson to ee.Geometry() Parameters: Name Type Description Default geo_json dict A geojson geometry dictionary or file path. required Returns: Type Description ee_object An ee.Geometry object Source code in geemap/eefolium.py def geojson_to_ee ( geo_json , geodesic = True ): \"\"\"Converts a geojson to ee.Geometry() Args: geo_json (dict): A geojson geometry dictionary or file path. Returns: ee_object: An ee.Geometry object \"\"\" ee_initialize () try : import json if not isinstance ( geo_json , dict ) and os . path . isfile ( geo_json ): with open ( os . path . abspath ( geo_json )) as f : geo_json = json . load ( f ) if geo_json [ 'type' ] == 'FeatureCollection' : features = ee . FeatureCollection ( geo_json [ 'features' ]) return features elif geo_json [ 'type' ] == 'Feature' : geom = None keys = geo_json [ 'properties' ][ 'style' ] . keys () if 'radius' in keys : # Checks whether it is a circle geom = ee . Geometry ( geo_json [ 'geometry' ]) radius = geo_json [ 'properties' ][ 'style' ][ 'radius' ] geom = geom . buffer ( radius ) elif geo_json [ 'geometry' ][ 'type' ] == 'Point' : # Checks whether it is a point coordinates = geo_json [ 'geometry' ][ 'coordinates' ] longitude = coordinates [ 0 ] latitude = coordinates [ 1 ] geom = ee . Geometry . Point ( longitude , latitude ) else : geom = ee . Geometry ( geo_json [ 'geometry' ], \"\" , geodesic ) return geom else : print ( \"Could not convert the geojson to ee.Geometry()\" ) except Exception as e : print ( \"Could not convert the geojson to ee.Geometry()\" ) print ( e ) has_transparency ( img ) Checks whether an image has transparency. Parameters: Name Type Description Default img object a PIL Image object. required Returns: Type Description bool True if it has transparency, False otherwise. Source code in geemap/eefolium.py def has_transparency ( img ): \"\"\"Checks whether an image has transparency. Args: img (object): a PIL Image object. Returns: bool: True if it has transparency, False otherwise. \"\"\" if img . mode == \"P\" : transparent = img . info . get ( \"transparency\" , - 1 ) for _ , index in img . getcolors (): if index == transparent : return True elif img . mode == \"RGBA\" : extrema = img . getextrema () if extrema [ 3 ][ 0 ] < 255 : return True return False hex_to_rgb ( value = 'FFFFFF' ) Converts hex color to RGB color. Parameters: Name Type Description Default value str Hex color code as a string. Defaults to 'FFFFFF'. 'FFFFFF' Returns: Type Description tuple RGB color as a tuple. Source code in geemap/eefolium.py def hex_to_rgb ( value = 'FFFFFF' ): \"\"\"Converts hex color to RGB color. Args: value (str, optional): Hex color code as a string. Defaults to 'FFFFFF'. Returns: tuple: RGB color as a tuple. \"\"\" value = value . lstrip ( '#' ) lv = len ( value ) return tuple ( int ( value [ i : i + lv // 3 ], 16 ) for i in range ( 0 , lv , lv // 3 )) in_colab_shell () Tests if the code is being executed within Google Colab. Source code in geemap/eefolium.py def in_colab_shell (): \"\"\"Tests if the code is being executed within Google Colab.\"\"\" try : import google.colab # pylint: disable=unused-variable return True except ImportError : return False install_from_github ( url ) Install a package from a GitHub repository. Parameters: Name Type Description Default url str The URL of the GitHub repository. required Source code in geemap/eefolium.py def install_from_github ( url ): \"\"\"Install a package from a GitHub repository. Args: url (str): The URL of the GitHub repository. \"\"\" try : download_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) if not os . path . exists ( download_dir ): os . makedirs ( download_dir ) repo_name = os . path . basename ( url ) zip_url = os . path . join ( url , 'archive/master.zip' ) filename = repo_name + '-master.zip' download_from_url ( url = zip_url , out_file_name = filename , out_dir = download_dir , unzip = True ) pkg_dir = os . path . join ( download_dir , repo_name + '-master' ) work_dir = os . getcwd () os . chdir ( pkg_dir ) cmd = 'pip install .' os . system ( cmd ) os . chdir ( work_dir ) print ( \" \\n Please comment out 'install_from_github()' and restart the kernel to take effect: \\n Jupyter menu -> Kernel -> Restart & Clear Output\" ) except Exception as e : print ( e ) is_drive_mounted () Checks whether Google Drive is mounted in Google Colab. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/eefolium.py def is_drive_mounted (): \"\"\"Checks whether Google Drive is mounted in Google Colab. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" drive_path = '/content/drive/My Drive' if os . path . exists ( drive_path ): return True else : return False is_latlon_valid ( location ) Checks whether a pair of coordinates is valid. Parameters: Name Type Description Default location str A pair of latlon coordinates separated by comma or space. required Returns: Type Description bool Returns True if valid. Source code in geemap/eefolium.py def is_latlon_valid ( location ): \"\"\"Checks whether a pair of coordinates is valid. Args: location (str): A pair of latlon coordinates separated by comma or space. Returns: bool: Returns True if valid. \"\"\" latlon = [] if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return False try : lat , lon = float ( latlon [ 0 ]), float ( latlon [ 1 ]) if lat >= - 90 and lat <= 90 and lon >= - 180 and lat <= 180 : return True else : return False except Exception as e : print ( e ) return False landsat_timeseries ( roi = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' ) Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Parameters: Name Type Description Default roi [type] [description]. Defaults to None. None start_year int [description]. Defaults to 1984. 1984 end_year int [description]. Defaults to 2019. 2019 start_date str [description]. Defaults to '06-10'. '06-10' end_date str [description]. Defaults to '09-20'. '09-20' roi object Region of interest to create the timelapse. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 1984. 1984 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. '06-10' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. '09-20' Returns: Type Description object Returns an ImageCollection containing annual Landsat images. Source code in geemap/eefolium.py def landsat_timeseries ( roi = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' ): \"\"\"Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Args: roi ([type], optional): [description]. Defaults to None. start_year (int, optional): [description]. Defaults to 1984. end_year (int, optional): [description]. Defaults to 2019. start_date (str, optional): [description]. Defaults to '06-10'. end_date (str, optional): [description]. Defaults to '09-20'. roi (object, optional): Region of interest to create the timelapse. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 1984. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. Returns: object: Returns an ImageCollection containing annual Landsat images. \"\"\" ################################################################################ # Input and output parameters. import re import datetime ee_initialize () if roi is None : # roi = ee.Geometry.Polygon( # [[[-180, -80], # [-180, 80], # [180, 80], # [180, -80], # [-180, -80]]], None, False) roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return ################################################################################ # Setup vars to get dates. if isinstance ( start_year , int ) and ( start_year >= 1984 ) and ( start_year < 2020 ): pass else : print ( 'The start year must be an integer >= 1984.' ) return if isinstance ( end_year , int ) and ( end_year > 1984 ) and ( end_year <= 2020 ): pass else : print ( 'The end year must be an integer <= 2020.' ) return if re . match ( \"[0-9] {2} \\-[0-9] {2} \" , start_date ) and re . match ( \"[0-9] {2} \\-[0-9] {2} \" , end_date ): pass else : print ( 'The start date and end date must be month-day, such as 06-10, 09-20' ) return try : datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) except Exception as e : print ( 'The input dates are invalid.' ) return def days_between ( d1 , d2 ): d1 = datetime . datetime . strptime ( d1 , \"%Y-%m- %d \" ) d2 = datetime . datetime . strptime ( d2 , \"%Y-%m- %d \" ) return abs (( d2 - d1 ) . days ) n_days = days_between ( str ( start_year ) + '-' + start_date , str ( start_year ) + '-' + end_date ) start_month = int ( start_date [: 2 ]) start_day = int ( start_date [ 3 : 5 ]) start_date = str ( start_year ) + '-' + start_date end_date = str ( end_year ) + '-' + end_date # Define a collection filter by date, bounds, and quality. def colFilter ( col , aoi ): # , startDate, endDate): return ( col . filterBounds ( aoi )) # Landsat collection preprocessingEnabled # Get Landsat surface reflectance collections for OLI, ETM+ and TM sensors. LC08col = ee . ImageCollection ( 'LANDSAT/LC08/C01/T1_SR' ) LE07col = ee . ImageCollection ( 'LANDSAT/LE07/C01/T1_SR' ) LT05col = ee . ImageCollection ( 'LANDSAT/LT05/C01/T1_SR' ) LT04col = ee . ImageCollection ( 'LANDSAT/LT04/C01/T1_SR' ) # Define a collection filter by date, bounds, and quality. def colFilter ( col , roi , start_date , end_date ): return ( col . filterBounds ( roi ) . filterDate ( start_date , end_date )) # .filter('CLOUD_COVER < 5') # .filter('GEOMETRIC_RMSE_MODEL < 15') # .filter('IMAGE_QUALITY == 9 || IMAGE_QUALITY_OLI == 9')) # Function to get and rename bands of interest from OLI. def renameOli ( img ): return ( img . select ( [ 'B2' , 'B3' , 'B4' , 'B5' , 'B6' , 'B7' , 'pixel_qa' ], [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ])) # Function to get and rename bands of interest from ETM+. def renameEtm ( img ): return ( img . select ( [ 'B1' , 'B2' , 'B3' , 'B4' , 'B5' , 'B7' , 'pixel_qa' ], [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ])) # Add NBR for LandTrendr segmentation. def calcNbr ( img ): return ( img . addBands ( img . normalizedDifference ([ 'NIR' , 'SWIR2' ]) . multiply ( - 10000 ) . rename ( 'NBR' )) . int16 ()) # Define function to mask out clouds and cloud shadows in images. # Use CFmask band included in USGS Landsat SR image product. def fmask ( img ): cloudShadowBitMask = 1 << 3 cloudsBitMask = 1 << 5 qa = img . select ( 'pixel_qa' ) mask = qa . bitwiseAnd ( cloudShadowBitMask ) . eq ( 0 ) \\ . And ( qa . bitwiseAnd ( cloudsBitMask ) . eq ( 0 )) return ( img . updateMask ( mask )) # Define function to prepare OLI images. def prepOli ( img ): orig = img img = renameOli ( img ) img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Define function to prepare ETM+ images. def prepEtm ( img ): orig = img img = renameEtm ( img ) img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Get annual median collection. def getAnnualComp ( y ): startDate = ee . Date . fromYMD ( ee . Number ( y ), ee . Number ( start_month ), ee . Number ( start_day )) endDate = startDate . advance ( ee . Number ( n_days ), 'day' ) # Filter collections and prepare them for merging. LC08coly = colFilter ( LC08col , roi , startDate , endDate ) . map ( prepOli ) LE07coly = colFilter ( LE07col , roi , startDate , endDate ) . map ( prepEtm ) LT05coly = colFilter ( LT05col , roi , startDate , endDate ) . map ( prepEtm ) LT04coly = colFilter ( LT04col , roi , startDate , endDate ) . map ( prepEtm ) # Merge the collections. col = LC08coly . merge ( LE07coly ) . merge ( LT05coly ) . merge ( LT04coly ) yearImg = col . median () nBands = yearImg . bandNames () . size () yearImg = ee . Image ( ee . Algorithms . If ( nBands , yearImg , dummyImg )) return ( calcNbr ( yearImg ) . set ({ 'year' : y , 'system:time_start' : startDate . millis (), 'nBands' : nBands })) ################################################################################ # Make a dummy image for missing years. bandNames = ee . List ([ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ]) fillerValues = ee . List . repeat ( 0 , bandNames . size ()) dummyImg = ee . Image . constant ( fillerValues ) . rename ( bandNames ) \\ . selfMask () . int16 () ################################################################################ # Get a list of years years = ee . List . sequence ( start_year , end_year ) ################################################################################ # Make list of annual image composites. imgList = years . map ( getAnnualComp ) # Convert image composite list to collection imgCol = ee . ImageCollection . fromImages ( imgList ) imgCol = imgCol . map ( lambda img : img . clip ( roi )) return imgCol landsat_ts_gif ( roi = None , out_gif = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' , bands = [ 'NIR' , 'Red' , 'Green' ], vis_params = None , dimensions = 768 , frames_per_second = 10 ) Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work. Parameters: Name Type Description Default roi object Region of interest to create the timelapse. Defaults to None. None out_gif [type] File path to the output animated GIF. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 1984. 1984 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. '06-10' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. '09-20' bands list Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. ['NIR', 'Red', 'Green'] vis_params dict Visualization parameters. Defaults to None. None dimensions int a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. 768 frames_per_second int Animation speed. Defaults to 10. 10 Returns: Type Description str File path to the output GIF image. Source code in geemap/eefolium.py def landsat_ts_gif ( roi = None , out_gif = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' , bands = [ 'NIR' , 'Red' , 'Green' ], vis_params = None , dimensions = 768 , frames_per_second = 10 ): \"\"\"Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work. Args: roi (object, optional): Region of interest to create the timelapse. Defaults to None. out_gif ([type], optional): File path to the output animated GIF. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 1984. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. bands (list, optional): Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. vis_params (dict, optional): Visualization parameters. Defaults to None. dimensions (int, optional): a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. frames_per_second (int, optional): Animation speed. Defaults to 10. Returns: str: File path to the output GIF image. \"\"\" ee_initialize () if roi is None : roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) elif isinstance ( roi , ee . Feature ) or isinstance ( roi , ee . FeatureCollection ): roi = roi . geometry () elif isinstance ( roi , ee . Geometry ): pass else : print ( 'The provided roi is invalid. It must be an ee.Geometry' ) return if out_gif is None : out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) filename = 'landsat_ts_' + random_string () + '.gif' out_gif = os . path . join ( out_dir , filename ) elif not out_gif . endswith ( '.gif' ): print ( 'The output file must end with .gif' ) return elif not os . path . isfile ( out_gif ): print ( 'The output file must be a file' ) return else : out_gif = os . path . abspath ( out_gif ) out_dir = os . path . dirname ( out_gif ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) allowed_bands = [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ] if len ( bands ) == 3 and all ( x in allowed_bands for x in bands ): pass else : print ( 'You can only select 3 bands from the following: {} ' . format ( ', ' . join ( allowed_bands ))) return try : col = landsat_timeseries ( roi , start_year , end_year , start_date , end_date ) if vis_params is None : vis_params = {} vis_params [ 'bands' ] = bands vis_params [ 'min' ] = 0 vis_params [ 'max' ] = 4000 vis_params [ 'gamma' ] = [ 1 , 1 , 1 ] video_args = vis_params . copy () video_args [ 'dimensions' ] = dimensions video_args [ 'region' ] = roi video_args [ 'framesPerSecond' ] = frames_per_second video_args [ 'crs' ] = 'EPSG:3857' if 'bands' not in video_args . keys (): video_args [ 'bands' ] = bands if 'min' not in video_args . keys (): video_args [ 'min' ] = 0 if 'max' not in video_args . keys (): video_args [ 'max' ] = 4000 if 'gamma' not in video_args . keys (): video_args [ 'gamma' ] = [ 1 , 1 , 1 ] download_ee_video ( col , video_args , out_gif ) return out_gif except Exception as e : print ( e ) return latlon_from_text ( location ) Extracts latlon from text. Parameters: Name Type Description Default location str A pair of latlon coordinates separated by comma or space. required Returns: Type Description bool Returns (lat, lon) if valid. Source code in geemap/eefolium.py def latlon_from_text ( location ): \"\"\"Extracts latlon from text. Args: location (str): A pair of latlon coordinates separated by comma or space. Returns: bool: Returns (lat, lon) if valid. \"\"\" latlon = [] try : if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return None lat , lon = latlon [ 0 ], latlon [ 1 ] if lat >= - 90 and lat <= 90 and lon >= - 180 and lat <= 180 : return lat , lon else : return None except Exception as e : print ( e ) print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return None legend_from_ee ( ee_class_table ) Extract legend from an Earth Engine class table on the Earth Engine Data Catalog page such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1 Value Color Description 0 1c0dff Water 1 05450a Evergreen needleleaf forest 2 086a10 Evergreen broadleaf forest 3 54a708 Deciduous needleleaf forest 4 78d203 Deciduous broadleaf forest 5 009900 Mixed forest 6 c6b044 Closed shrublands 7 dcd159 Open shrublands 8 dade48 Woody savannas 9 fbff13 Savannas 10 b6ff05 Grasslands 11 27ff87 Permanent wetlands 12 c24f44 Croplands 13 a5a5a5 Urban and built-up 14 ff6d4c Cropland/natural vegetation mosaic 15 69fff8 Snow and ice 16 f9ffa4 Barren or sparsely vegetated 254 ffffff Unclassified Parameters: Name Type Description Default ee_class_table str An Earth Engine class table with triple quotes. required Returns: Type Description dict Returns a legend dictionary that can be used to create a legend. Source code in geemap/eefolium.py def legend_from_ee ( ee_class_table ): \"\"\"Extract legend from an Earth Engine class table on the Earth Engine Data Catalog page such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1 Value Color Description 0 1c0dff Water 1 05450a Evergreen needleleaf forest 2 086a10 Evergreen broadleaf forest 3 54a708 Deciduous needleleaf forest 4 78d203 Deciduous broadleaf forest 5 009900 Mixed forest 6 c6b044 Closed shrublands 7 dcd159 Open shrublands 8 dade48 Woody savannas 9 fbff13 Savannas 10 b6ff05 Grasslands 11 27ff87 Permanent wetlands 12 c24f44 Croplands 13 a5a5a5 Urban and built-up 14 ff6d4c Cropland/natural vegetation mosaic 15 69fff8 Snow and ice 16 f9ffa4 Barren or sparsely vegetated 254 ffffff Unclassified Args: ee_class_table (str): An Earth Engine class table with triple quotes. Returns: dict: Returns a legend dictionary that can be used to create a legend. \"\"\" try : ee_class_table = ee_class_table . strip () lines = ee_class_table . split ( ' \\n ' )[ 1 :] if lines [ 0 ] == 'Value \\t Color \\t Description' : lines = lines [ 1 :] legend_dict = {} for index , line in enumerate ( lines ): items = line . split ( \" \\t \" ) items = [ item . strip () for item in items ] color = items [ 1 ] key = items [ 0 ] + \" \" + items [ 2 ] legend_dict [ key ] = color return legend_dict except Exception as e : print ( e ) minimum_bounding_box ( geojson ) Gets the minimum bounding box for a geojson polygon. Parameters: Name Type Description Default geojson dict A geojson dictionary. required Returns: Type Description tuple Returns a tuple containing the minimum bounding box in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -120)). Source code in geemap/eefolium.py def minimum_bounding_box ( geojson ): \"\"\"Gets the minimum bounding box for a geojson polygon. Args: geojson (dict): A geojson dictionary. Returns: tuple: Returns a tuple containing the minimum bounding box in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -120)). \"\"\" coordinates = [] try : if 'geometry' in geojson . keys (): coordinates = geojson [ 'geometry' ][ 'coordinates' ][ 0 ] else : coordinates = geojson [ 'coordinates' ][ 0 ] lower_left = min ([ x [ 1 ] for x in coordinates ]), min ( [ x [ 0 ] for x in coordinates ]) # (lat, lon) upper_right = max ([ x [ 1 ] for x in coordinates ]), max ([ x [ 0 ] for x in coordinates ]) # (lat, lon) bounds = ( lower_left , upper_right ) return bounds except Exception as e : print ( e ) return naip_timeseries ( roi = None , start_year = 2009 , end_year = 2018 ) Creates NAIP annual timeseries Parameters: Name Type Description Default roi object An ee.Geometry representing the region of interest. Defaults to None. None start_year int Starting year for the timeseries. Defaults to2009. 2009 end_year int Ending year for the timeseries. Defaults to 2018. 2018 Returns: Type Description object An ee.ImageCollection representing annual NAIP imagery. Source code in geemap/eefolium.py def naip_timeseries ( roi = None , start_year = 2009 , end_year = 2018 ): \"\"\"Creates NAIP annual timeseries Args: roi (object, optional): An ee.Geometry representing the region of interest. Defaults to None. start_year (int, optional): Starting year for the timeseries. Defaults to2009. end_year (int, optional): Ending year for the timeseries. Defaults to 2018. Returns: object: An ee.ImageCollection representing annual NAIP imagery. \"\"\" ee_initialize () try : def get_annual_NAIP ( year ): try : collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) if roi is not None : collection = collection . filterBounds ( roi ) start_date = ee . Date . fromYMD ( year , 1 , 1 ) end_date = ee . Date . fromYMD ( year , 12 , 31 ) naip = collection . filterDate ( start_date , end_date ) \\ . filter ( ee . Filter . listContains ( \"system:band_names\" , \"N\" )) naip = ee . Image ( ee . ImageCollection ( naip ) . mosaic ()) return naip except Exception as e : print ( e ) years = ee . List . sequence ( start_year , end_year ) collection = years . map ( get_annual_NAIP ) return collection except Exception as e : print ( e ) open_github ( subdir = None ) Opens the GitHub repository for this package. Parameters: Name Type Description Default subdir str Sub-directory of the repository. Defaults to None. None Source code in geemap/eefolium.py def open_github ( subdir = None ): \"\"\"Opens the GitHub repository for this package. Args: subdir (str, optional): Sub-directory of the repository. Defaults to None. \"\"\" import webbrowser url = 'https://github.com/giswqs/geemap' if subdir == 'source' : url += '/tree/master/geemap/' elif subdir == 'examples' : url += '/tree/master/examples' elif subdir == 'tutorials' : url += '/tree/master/tutorials' webbrowser . open_new_tab ( url ) open_image_from_url ( url ) Loads an image from the specified URL. Parameters: Name Type Description Default url str URL of the image. required Returns: Type Description object Image object. Source code in geemap/eefolium.py def open_image_from_url ( url ): \"\"\"Loads an image from the specified URL. Args: url (str): URL of the image. Returns: object: Image object. \"\"\" from PIL import Image import requests from io import BytesIO from urllib.parse import urlparse try : # if url.endswith('.gif'): # out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') # if not os.path.exists(out_dir): # os.makedirs(out_dir) # a = urlparse(url) # out_name = os.path.basename(a.path) # out_path = os.path.join(out_dir, out_name) # download_from_url(url, out_name, out_dir, unzip=False) # img = Image.open(out_path) # else: response = requests . get ( url ) img = Image . open ( BytesIO ( response . content )) return img except Exception as e : print ( e ) open_youtube () Opens the YouTube tutorials for geemap. Source code in geemap/eefolium.py def open_youtube (): \"\"\"Opens the YouTube tutorials for geemap. \"\"\" import webbrowser url = 'https://www.youtube.com/playlist?list=PLAxJ4-o7ZoPccOFv1dCwvGI6TYnirRTg3' webbrowser . open_new_tab ( url ) rgb_to_hex ( rgb = ( 255 , 255 , 255 )) Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255. Parameters: Name Type Description Default rgb tuple RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255). (255, 255, 255) Returns: Type Description str hex color code Source code in geemap/eefolium.py def rgb_to_hex ( rgb = ( 255 , 255 , 255 )): \"\"\"Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255. Args: rgb (tuple, optional): RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255). Returns: str: hex color code \"\"\" return ' %02x%02x%02x ' % rgb search_ee_data ( keywords ) Searches Earth Engine data catalog. Parameters: Name Type Description Default keywords str Keywords to search for can be id, provider, tag and so on required Returns: Type Description list Returns a lit of assets. Source code in geemap/eefolium.py def search_ee_data ( keywords ): \"\"\"Searches Earth Engine data catalog. Args: keywords (str): Keywords to search for can be id, provider, tag and so on Returns: list: Returns a lit of assets. \"\"\" try : cmd = 'geeadd search --keywords \" {} \"' . format ( str ( keywords )) output = os . popen ( cmd ) . read () start_index = output . index ( '[' ) assets = eval ( output [ start_index :]) results = [] for asset in assets : asset_dates = asset [ 'start_date' ] + ' - ' + asset [ 'end_date' ] asset_snippet = asset [ 'ee_id_snippet' ] start_index = asset_snippet . index ( \"'\" ) + 1 end_index = asset_snippet . index ( \"'\" , start_index ) asset_id = asset_snippet [ start_index : end_index ] asset [ 'dates' ] = asset_dates asset [ 'id' ] = asset_id asset [ 'uid' ] = asset_id . replace ( '/' , '_' ) # asset['url'] = 'https://developers.google.com/earth-engine/datasets/catalog/' + asset['uid'] # asset['thumbnail'] = 'https://mw1.google.com/ges/dd/images/{}_sample.png'.format( # asset['uid']) results . append ( asset ) return results except Exception as e : print ( e ) return sentinel2_timeseries ( roi = None , start_year = 2015 , end_year = 2019 , start_date = '01-01' , end_date = '12-31' ) Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Images include both level 1C and level 2A imagery. Parameters: Name Type Description Default roi object Region of interest to create the timelapse. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 2015. 2015 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'. '01-01' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'. '12-31' Returns: Type Description object Returns an ImageCollection containing annual Sentinel 2 images. Source code in geemap/eefolium.py def sentinel2_timeseries ( roi = None , start_year = 2015 , end_year = 2019 , start_date = '01-01' , end_date = '12-31' ): \"\"\"Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Images include both level 1C and level 2A imagery. Args: roi (object, optional): Region of interest to create the timelapse. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 2015. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'. Returns: object: Returns an ImageCollection containing annual Sentinel 2 images. \"\"\" ################################################################################ ################################################################################ # Input and output parameters. import re import datetime ee_initialize () if roi is None : # roi = ee.Geometry.Polygon( # [[[-180, -80], # [-180, 80], # [180, 80], # [180, -80], # [-180, -80]]], None, False) roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return ################################################################################ # Setup vars to get dates. if isinstance ( start_year , int ) and ( start_year >= 2015 ) and ( start_year <= 2020 ): pass else : print ( 'The start year must be an integer >= 2015.' ) return if isinstance ( end_year , int ) and ( end_year >= 2015 ) and ( end_year <= 2020 ): pass else : print ( 'The end year must be an integer <= 2020.' ) return if re . match ( \"[0-9] {2} \\-[0-9] {2} \" , start_date ) and re . match ( \"[0-9] {2} \\-[0-9] {2} \" , end_date ): pass else : print ( 'The start data and end date must be month-day, such as 06-10, 09-20' ) return try : datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) except Exception as e : print ( 'The input dates are invalid.' ) print ( e ) return try : start_test = datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) end_test = datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) if start_test > end_test : raise ValueError ( 'Start date must be prior to end date' ) except Exception as e : print ( e ) return def days_between ( d1 , d2 ): d1 = datetime . datetime . strptime ( d1 , \"%Y-%m- %d \" ) d2 = datetime . datetime . strptime ( d2 , \"%Y-%m- %d \" ) return abs (( d2 - d1 ) . days ) n_days = days_between ( str ( start_year ) + '-' + start_date , str ( start_year ) + '-' + end_date ) start_month = int ( start_date [: 2 ]) start_day = int ( start_date [ 3 : 5 ]) start_date = str ( start_year ) + '-' + start_date end_date = str ( end_year ) + '-' + end_date # Define a collection filter by date, bounds, and quality. def colFilter ( col , aoi ): # , startDate, endDate): return ( col . filterBounds ( aoi )) # Get Sentinel 2 collections, both Level-1C (top of atmophere) and Level-2A (surface reflectance) MSILCcol = ee . ImageCollection ( 'COPERNICUS/S2' ) MSI2Acol = ee . ImageCollection ( 'COPERNICUS/S2_SR' ) # Define a collection filter by date, bounds, and quality. def colFilter ( col , roi , start_date , end_date ): return ( col . filterBounds ( roi ) . filterDate ( start_date , end_date )) # .filter('CLOUD_COVER < 5') # .filter('GEOMETRIC_RMSE_MODEL < 15') # .filter('IMAGE_QUALITY == 9 || IMAGE_QUALITY_OLI == 9')) # Function to get and rename bands of interest from MSI def renameMSI ( img ): return ( img . select ( [ 'B2' , 'B3' , 'B4' , 'B5' , 'B6' , 'B7' , 'B8' , 'B8A' , 'B11' , 'B12' , 'QA60' ], [ 'Blue' , 'Green' , 'Red' , 'Red Edge 1' , 'Red Edge 2' , 'Red Edge 3' , 'NIR' , 'Red Edge 4' , 'SWIR1' , 'SWIR2' , 'QA60' ])) # Add NBR for LandTrendr segmentation. def calcNbr ( img ): return ( img . addBands ( img . normalizedDifference ([ 'NIR' , 'SWIR2' ]) . multiply ( - 10000 ) . rename ( 'NBR' )) . int16 ()) # Define function to mask out clouds and cloud shadows in images. # Use CFmask band included in USGS Landsat SR image product. def fmask ( img ): cloudOpaqueBitMask = 1 << 10 cloudCirrusBitMask = 1 << 11 qa = img . select ( 'QA60' ) mask = qa . bitwiseAnd ( cloudOpaqueBitMask ) . eq ( 0 ) \\ . And ( qa . bitwiseAnd ( cloudCirrusBitMask ) . eq ( 0 )) return ( img . updateMask ( mask )) # Define function to prepare MSI images. def prepMSI ( img ): orig = img img = renameMSI ( img ) img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Get annual median collection. def getAnnualComp ( y ): startDate = ee . Date . fromYMD ( ee . Number ( y ), ee . Number ( start_month ), ee . Number ( start_day )) endDate = startDate . advance ( ee . Number ( n_days ), 'day' ) # Filter collections and prepare them for merging. MSILCcoly = colFilter ( MSILCcol , roi , startDate , endDate ) . map ( prepMSI ) MSI2Acoly = colFilter ( MSI2Acol , roi , startDate , endDate ) . map ( prepMSI ) # Merge the collections. col = MSILCcoly . merge ( MSI2Acoly ) yearImg = col . median () nBands = yearImg . bandNames () . size () yearImg = ee . Image ( ee . Algorithms . If ( nBands , yearImg , dummyImg )) return ( calcNbr ( yearImg ) . set ({ 'year' : y , 'system:time_start' : startDate . millis (), 'nBands' : nBands })) ################################################################################ # Make a dummy image for missing years. bandNames = ee . List ([ 'Blue' , 'Green' , 'Red' , 'Red Edge 1' , 'Red Edge 2' , 'Red Edge 3' , 'NIR' , 'Red Edge 4' , 'SWIR1' , 'SWIR2' , 'QA60' ]) fillerValues = ee . List . repeat ( 0 , bandNames . size ()) dummyImg = ee . Image . constant ( fillerValues ) . rename ( bandNames ) \\ . selfMask () . int16 () ################################################################################ # Get a list of years years = ee . List . sequence ( start_year , end_year ) ################################################################################ # Make list of annual image composites. imgList = years . map ( getAnnualComp ) # Convert image composite list to collection imgCol = ee . ImageCollection . fromImages ( imgList ) imgCol = imgCol . map ( lambda img : img . clip ( roi )) return imgCol show_image ( img_path , width = None , height = None ) Shows an image within Jupyter notebook. Parameters: Name Type Description Default img_path str The image file path. required width int Width of the image in pixels. Defaults to None. None height int Height of the image in pixels. Defaults to None. None Source code in geemap/eefolium.py def show_image ( img_path , width = None , height = None ): \"\"\"Shows an image within Jupyter notebook. Args: img_path (str): The image file path. width (int, optional): Width of the image in pixels. Defaults to None. height (int, optional): Height of the image in pixels. Defaults to None. \"\"\" from IPython.display import display try : out = widgets . Output () # layout={'border': '1px solid black'}) # layout={'border': '1px solid black', 'width': str(width + 20) + 'px', 'height': str(height + 10) + 'px'},) out . clear_output ( wait = True ) display ( out ) with out : file = open ( img_path , \"rb\" ) image = file . read () if ( width is None ) and ( height is None ): display ( widgets . Image ( value = image )) elif ( width is not None ) and ( height is not None ): display ( widgets . Image ( value = image , width = width , height = height )) else : print ( 'You need set both width and height.' ) return except Exception as e : print ( e ) show_youtube ( id = 'h0pz3S6Tvx0' ) Displays a YouTube video within Jupyter notebooks. Parameters: Name Type Description Default id str Unique ID of the video. Defaults to 'h0pz3S6Tvx0'. 'h0pz3S6Tvx0' Source code in geemap/eefolium.py def show_youtube ( id = 'h0pz3S6Tvx0' ): \"\"\"Displays a YouTube video within Jupyter notebooks. Args: id (str, optional): Unique ID of the video. Defaults to 'h0pz3S6Tvx0'. \"\"\" from IPython.display import YouTubeVideo , display try : out = widgets . Output ( layout = { 'width' : '815px' }) # layout={'border': '1px solid black', 'width': '815px'}) out . clear_output ( wait = True ) display ( out ) with out : display ( YouTubeVideo ( id , width = 800 , height = 450 )) except Exception as e : print ( e ) shp_to_ee ( in_shp ) Converts a shapefile to Earth Engine objects. Parameters: Name Type Description Default in_shp str File path to a shapefile. required Returns: Type Description object Earth Engine objects representing the shapefile. Source code in geemap/eefolium.py def shp_to_ee ( in_shp ): \"\"\"Converts a shapefile to Earth Engine objects. Args: in_shp (str): File path to a shapefile. Returns: object: Earth Engine objects representing the shapefile. \"\"\" ee_initialize () try : json_data = shp_to_geojson ( in_shp ) ee_object = geojson_to_ee ( json_data ) return ee_object except Exception as e : print ( e ) shp_to_geojson ( in_shp , out_json = None ) Converts a shapefile to GeoJSON. Parameters: Name Type Description Default in_shp str File path of the input shapefile. required out_json str File path of the output GeoJSON. Defaults to None. None Returns: Type Description object The json object representing the shapefile. Source code in geemap/eefolium.py def shp_to_geojson ( in_shp , out_json = None ): \"\"\"Converts a shapefile to GeoJSON. Args: in_shp (str): File path of the input shapefile. out_json (str, optional): File path of the output GeoJSON. Defaults to None. Returns: object: The json object representing the shapefile. \"\"\" # check_install('pyshp') ee_initialize () try : import json import shapefile in_shp = os . path . abspath ( in_shp ) if out_json is None : out_json = os . path . splitext ( in_shp )[ 0 ] + \".json\" if os . path . exists ( out_json ): out_json = out_json . replace ( '.json' , '_bk.json' ) elif not os . path . exists ( os . path . dirname ( out_json )): os . makedirs ( os . path . dirname ( out_json )) reader = shapefile . Reader ( in_shp ) fields = reader . fields [ 1 :] field_names = [ field [ 0 ] for field in fields ] buffer = [] for sr in reader . shapeRecords (): atr = dict ( zip ( field_names , sr . record )) geom = sr . shape . __geo_interface__ buffer . append ( dict ( type = \"Feature\" , geometry = geom , properties = atr )) from json import dumps geojson = open ( out_json , \"w\" ) geojson . write ( dumps ({ \"type\" : \"FeatureCollection\" , \"features\" : buffer }, indent = 2 ) + \" \\n \" ) geojson . close () with open ( out_json ) as f : json_data = json . load ( f ) return json_data except Exception as e : print ( e ) system_fonts ( show_full_path = False ) Gets a list of system fonts. # Common font locations: # Linux: /usr/share/fonts/TTF/ # Windows: C:\\Windows\\Fonts # macOS: System > Library > Fonts Parameters: Name Type Description Default show_full_path bool Whether to show the full path of each system font. Defaults to False. False Returns: Type Description list A list of system fonts. Source code in geemap/eefolium.py def system_fonts ( show_full_path = False ): \"\"\"Gets a list of system fonts. # Common font locations: # Linux: /usr/share/fonts/TTF/ # Windows: C:\\Windows\\Fonts # macOS: System > Library > Fonts Args: show_full_path (bool, optional): Whether to show the full path of each system font. Defaults to False. Returns: list: A list of system fonts. \"\"\" try : import matplotlib.font_manager font_list = matplotlib . font_manager . findSystemFonts ( fontpaths = None , fontext = 'ttf' ) font_list . sort () font_names = [ os . path . basename ( f ) for f in font_list ] font_names . sort () if show_full_path : return font_list else : return font_names except Exception as e : print ( e ) update_package () Updates the geemap package from the geemap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. Source code in geemap/eefolium.py def update_package (): \"\"\"Updates the geemap package from the geemap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. \"\"\" try : download_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) if not os . path . exists ( download_dir ): os . makedirs ( download_dir ) clone_repo ( out_dir = download_dir ) pkg_dir = os . path . join ( download_dir , 'geemap-master' ) work_dir = os . getcwd () os . chdir ( pkg_dir ) cmd = 'pip install .' os . system ( cmd ) os . chdir ( work_dir ) print ( \" \\n Please comment out 'geemap.update_package()' and restart the kernel to take effect: \\n Jupyter menu -> Kernel -> Restart & Clear Output\" ) except Exception as e : print ( e ) zonal_statistics ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'MEAN' , scale = None , crs = None , tile_scale = 1.0 , ** kwargs ) Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Parameters: Name Type Description Default in_value_raster object An ee.Image that contains the values on which to calculate a statistic. required in_zone_vector object An ee.FeatureCollection that defines the zones. required out_file_path str Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz required statistics_type str Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps. 'MEAN' scale float A nominal scale in meters of the projection to work in. Defaults to None. None crs str The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. None tile_scale float A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. 1.0 Source code in geemap/eefolium.py def zonal_statistics ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'MEAN' , scale = None , crs = None , tile_scale = 1.0 , ** kwargs ): \"\"\"Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Args: in_value_raster (object): An ee.Image that contains the values on which to calculate a statistic. in_zone_vector (object): An ee.FeatureCollection that defines the zones. out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz statistics_type (str, optional): Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. \"\"\" if not isinstance ( in_value_raster , ee . Image ): print ( 'The input raster must be an ee.Image.' ) return if not isinstance ( in_zone_vector , ee . FeatureCollection ): print ( 'The input zone data must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' ] filename = os . path . abspath ( out_file_path ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () if not ( filetype in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return # Parameters for histogram # The maximum number of buckets to use when building a histogram; will be rounded up to a power of 2. max_buckets = None # The minimum histogram bucket width, or null to allow any power of 2. min_bucket_width = None # The number of values to accumulate before building the initial histogram. max_raw = None hist_min = 1.0 # The lower (inclusive) bound of the first bucket. hist_max = 100.0 # The upper (exclusive) bound of the last bucket. hist_steps = 10 # The number of buckets to use. if 'max_buckets' in kwargs . keys (): max_buckets = kwargs [ 'max_buckets' ] if 'min_bucket_width' in kwargs . keys (): min_bucket_width = kwargs [ 'min_bucket' ] if 'max_raw' in kwargs . keys (): max_raw = kwargs [ 'max_raw' ] if statistics_type . upper () == 'FIXED_HIST' and ( 'hist_min' in kwargs . keys ()) and ( 'hist_max' in kwargs . keys ()) and ( 'hist_steps' in kwargs . keys ()): hist_min = kwargs [ 'hist_min' ] hist_max = kwargs [ 'hist_max' ] hist_steps = kwargs [ 'hist_steps' ] elif statistics_type . upper () == 'FIXED_HIST' : print ( 'To use fixedHistogram, please provide these three parameters: hist_min, hist_max, and hist_steps.' ) return allowed_statistics = { 'MEAN' : ee . Reducer . mean (), 'MAXIMUM' : ee . Reducer . max (), 'MEDIAN' : ee . Reducer . median (), 'MINIMUM' : ee . Reducer . min (), 'STD' : ee . Reducer . stdDev (), 'MIN_MAX' : ee . Reducer . minMax (), 'SUM' : ee . Reducer . sum (), 'VARIANCE' : ee . Reducer . variance (), 'HIST' : ee . Reducer . histogram ( maxBuckets = max_buckets , minBucketWidth = min_bucket_width , maxRaw = max_raw ), 'FIXED_HIST' : ee . Reducer . fixedHistogram ( hist_min , hist_max , hist_steps ) } if not ( statistics_type . upper () in allowed_statistics . keys ()): print ( 'The statistics type must be one of the following: {} ' . format ( ', ' . join ( list ( allowed_statistics . keys ())))) return if scale is None : scale = in_value_raster . projection () . nominalScale () . multiply ( 10 ) try : print ( 'Computing statistics ...' ) result = in_value_raster . reduceRegions ( collection = in_zone_vector , reducer = allowed_statistics [ statistics_type ], scale = scale , crs = crs , tileScale = tile_scale ) ee_export_vector ( result , filename ) except Exception as e : print ( e ) zonal_statistics_by_group ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'SUM' , decimal_places = 0 , denominator = 1.0 , scale = None , crs = None , tile_scale = 1.0 ) Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Parameters: Name Type Description Default in_value_raster object An integer Image that contains the values on which to calculate area/percentage. required in_zone_vector object An ee.FeatureCollection that defines the zones. required out_file_path str Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz required statistics_type str Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'. 'SUM' decimal_places int The number of decimal places to use. Defaults to 0. 0 denominator float To covert area units (e.g., from square meters to square kilometers). Defaults to 1.0. 1.0 scale float A nominal scale in meters of the projection to work in. Defaults to None. None crs str The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. None tile_scale float A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. 1.0 Source code in geemap/eefolium.py def zonal_statistics_by_group ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'SUM' , decimal_places = 0 , denominator = 1.0 , scale = None , crs = None , tile_scale = 1.0 ): \"\"\"Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Args: in_value_raster (object): An integer Image that contains the values on which to calculate area/percentage. in_zone_vector (object): An ee.FeatureCollection that defines the zones. out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz statistics_type (str, optional): Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'. decimal_places (int, optional): The number of decimal places to use. Defaults to 0. denominator (float, optional): To covert area units (e.g., from square meters to square kilometers). Defaults to 1.0. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. \"\"\" if not isinstance ( in_value_raster , ee . Image ): print ( 'The input raster must be an ee.Image.' ) return band_count = in_value_raster . bandNames () . size () . getInfo () band_name = '' if band_count == 1 : band_name = in_value_raster . bandNames () . get ( 0 ) else : print ( 'The input image can only have one band.' ) return band_types = in_value_raster . bandTypes () . get ( band_name ) . getInfo () band_type = band_types . get ( 'precision' ) if band_type != 'int' : print ( 'The input image band must be integer type.' ) return if not isinstance ( in_zone_vector , ee . FeatureCollection ): print ( 'The input zone data must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' ] filename = os . path . abspath ( out_file_path ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] if not ( filetype . lower () in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return out_dir = os . path . dirname ( filename ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) allowed_statistics = [ 'SUM' , 'PERCENTAGE' ] if not ( statistics_type . upper () in allowed_statistics ): print ( 'The statistics type can only be one of {} ' . format ( ', ' . join ( allowed_statistics ))) return if scale is None : scale = in_value_raster . projection () . nominalScale () . multiply ( 10 ) try : print ( 'Computing ... ' ) geometry = in_zone_vector . geometry () hist = in_value_raster . reduceRegion ( ee . Reducer . frequencyHistogram ( ), geometry = geometry , bestEffort = True , scale = scale ) class_values = ee . Dictionary ( hist . get ( band_name )) . keys () . map ( lambda v : ee . Number . parse ( v )) . sort () class_names = class_values . map ( lambda c : ee . String ( 'Class_' ) . cat ( ee . Number ( c ) . format ())) class_count = class_values . size () . getInfo () dataset = ee . Image . pixelArea () . divide ( denominator ) . addBands ( in_value_raster ) init_result = dataset . reduceRegions ( ** { 'collection' : in_zone_vector , 'reducer' : ee . Reducer . sum () . group ( ** { 'groupField' : 1 , 'groupName' : 'group' , }), 'scale' : scale }) def build_dict ( input_list ): decimal_format = '%. {} f' . format ( decimal_places ) in_dict = input_list . map ( lambda x : ee . Dictionary () . set ( ee . String ( 'Class_' ) . cat ( ee . Number ( ee . Dictionary ( x ) . get ( 'group' )) . format ()), ee . Number . parse ( ee . Number ( ee . Dictionary ( x ) . get ( 'sum' )) . format ( decimal_format )))) return in_dict def get_keys ( input_list ): return input_list . map ( lambda x : ee . String ( 'Class_' ) . cat ( ee . Number ( ee . Dictionary ( x ) . get ( 'group' )) . format ())) def get_values ( input_list ): decimal_format = '%. {} f' . format ( decimal_places ) return input_list . map ( lambda x : ee . Number . parse ( ee . Number ( ee . Dictionary ( x ) . get ( 'sum' )) . format ( decimal_format ))) def set_attribute ( f ): groups = ee . List ( f . get ( 'groups' )) keys = get_keys ( groups ) values = get_values ( groups ) total_area = ee . List ( values ) . reduce ( ee . Reducer . sum ()) def get_class_values ( x ): cls_value = ee . Algorithms . If ( keys . contains ( x ), values . get ( keys . indexOf ( x )), 0 ) cls_value = ee . Algorithms . If ( ee . String ( statistics_type ) . compareTo ( ee . String ( 'SUM' )), ee . Number ( cls_value ) . divide ( ee . Number ( total_area )), cls_value ) return cls_value full_values = class_names . map ( lambda x : get_class_values ( x )) attr_dict = ee . Dictionary . fromLists ( class_names , full_values ) attr_dict = attr_dict . set ( 'Class_sum' , total_area ) return f . set ( attr_dict ) . set ( 'groups' , None ) final_result = init_result . map ( set_attribute ) ee_export_vector ( final_result , filename ) except Exception as e : print ( e )","title":"eefolium module"},{"location":"eefolium/#eefolium-module","text":"","title":"eefolium module"},{"location":"eefolium/#geemap.eefolium","text":"This module extends the folium Map class. It is designed to be used in Google Colab, as Google Colab currently does not support ipyleaflet.","title":"geemap.eefolium"},{"location":"eefolium/#geemap.eefolium.Map","text":"The Map class inherits from folium.Map. By default, the Map will add Google Maps as the basemap. Set add_google_map = False to use OpenStreetMap as the basemap. Returns: Type Description object folium map object.","title":"Map"},{"location":"eefolium/#geemap.eefolium.Map.add_basemap","text":"Adds a basemap to the map. Parameters: Name Type Description Default basemap str Can be one of string from ee_basemaps. Defaults to 'HYBRID'. 'HYBRID' Source code in geemap/eefolium.py def add_basemap ( self , basemap = 'HYBRID' ): \"\"\"Adds a basemap to the map. Args: basemap (str, optional): Can be one of string from ee_basemaps. Defaults to 'HYBRID'. \"\"\" try : ee_basemaps [ basemap ] . add_to ( self ) except : print ( 'Basemap can only be one of the following: {} ' . format ( ', ' . join ( ee_basemaps . keys ())))","title":"add_basemap()"},{"location":"eefolium/#geemap.eefolium.Map.add_layer","text":"Adds a given EE object to the map as a layer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer untitled'. 'Layer untitled' shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/eefolium.py def add_layer ( self , ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ): \"\"\"Adds a given EE object to the map as a layer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer untitled'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" image = None if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) folium . raster_layers . TileLayer ( tiles = map_id_dict [ 'tile_fetcher' ] . url_format , attr = 'Google Earth Engine' , name = name , overlay = True , control = True , show = shown , opacity = opacity ) . add_to ( self )","title":"add_layer()"},{"location":"eefolium/#geemap.eefolium.Map.add_layer_control","text":"Adds layer basemap to the map. Source code in geemap/eefolium.py def add_layer_control ( self ): \"\"\"Adds layer basemap to the map. \"\"\" folium . LayerControl () . add_to ( self )","title":"add_layer_control()"},{"location":"eefolium/#geemap.eefolium.Map.add_tile_layer","text":"Add a XYZ tile layer to the map. Parameters: Name Type Description Default tiles str The URL of the XYZ tile service. 'OpenStreetMap' name str The layer name to use on the layer control. Defaults to None. None attribution str The attribution of the data layer. Defaults to ''. '' overlay str Allows overlay. Defaults to True. True control str Adds the layer to the layer control. Defaults to True. True shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float Sets the opacity for the layer. 1.0 API_key str \u2013 API key for Cloudmade or Mapbox tiles. Defaults to True. None Source code in geemap/eefolium.py def add_tile_layer ( self , tiles = 'OpenStreetMap' , name = None , attribution = '' , overlay = True , control = True , shown = True , opacity = 1.0 , API_key = None ): \"\"\"Add a XYZ tile layer to the map. Args: tiles (str): The URL of the XYZ tile service. name (str, optional): The layer name to use on the layer control. Defaults to None. attribution (str, optional): The attribution of the data layer. Defaults to ''. overlay (str, optional): Allows overlay. Defaults to True. control (str, optional): Adds the layer to the layer control. Defaults to True. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): Sets the opacity for the layer. API_key (str, optional): \u2013 API key for Cloudmade or Mapbox tiles. Defaults to True. \"\"\" try : folium . raster_layers . TileLayer ( tiles = tiles , name = name , attr = attribution , overlay = overlay , control = control , show = shown , opacity = opacity , API_key = API_key ) . add_to ( self ) except : print ( \"Failed to add the specified TileLayer.\" )","title":"add_tile_layer()"},{"location":"eefolium/#geemap.eefolium.Map.add_wms_layer","text":"Add a WMS layer to the map. Parameters: Name Type Description Default url str The URL of the WMS web service. required layers str Comma-separated list of WMS layers to show. required name str The layer name to use on the layer control. Defaults to None. None attribution str The attribution of the data layer. Defaults to ''. '' overlay str Allows overlay. Defaults to True. True control str Adds the layer to the layer control. Defaults to True. True shown bool A flag indicating whether the layer should be on by default. Defaults to True. True format str WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/jpeg'. 'image/png' Source code in geemap/eefolium.py def add_wms_layer ( self , url , layers , name = None , attribution = '' , overlay = True , control = True , shown = True , format = 'image/png' ): \"\"\"Add a WMS layer to the map. Args: url (str): The URL of the WMS web service. layers (str): Comma-separated list of WMS layers to show. name (str, optional): The layer name to use on the layer control. Defaults to None. attribution (str, optional): The attribution of the data layer. Defaults to ''. overlay (str, optional): Allows overlay. Defaults to True. control (str, optional): Adds the layer to the layer control. Defaults to True. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/jpeg'. \"\"\" try : folium . raster_layers . WmsTileLayer ( url = url , layers = layers , attr = attribution , name = name , overlay = overlay , control = control , show = shown ) . add_to ( self ) except : print ( \"Failed to add the specified WMS TileLayer.\" )","title":"add_wms_layer()"},{"location":"eefolium/#geemap.eefolium.Map.addLayer","text":"Adds a given EE object to the map as a layer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer untitled'. 'Layer untitled' shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/eefolium.py def add_layer ( self , ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ): \"\"\"Adds a given EE object to the map as a layer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer untitled'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" image = None if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) folium . raster_layers . TileLayer ( tiles = map_id_dict [ 'tile_fetcher' ] . url_format , attr = 'Google Earth Engine' , name = name , overlay = True , control = True , show = shown , opacity = opacity ) . add_to ( self )","title":"addLayer()"},{"location":"eefolium/#geemap.eefolium.Map.addLayerControl","text":"Adds layer basemap to the map. Source code in geemap/eefolium.py def add_layer_control ( self ): \"\"\"Adds layer basemap to the map. \"\"\" folium . LayerControl () . add_to ( self )","title":"addLayerControl()"},{"location":"eefolium/#geemap.eefolium.Map.center_object","text":"Centers the map view on a given object. Parameters: Name Type Description Default ee_object Element|Geometry An Earth Engine object to center on - a geometry, image or feature. required zoom int The zoom level, from 1 to 24. Defaults to 10. 10 Source code in geemap/eefolium.py def center_object ( self , ee_object , zoom = 10 ): \"\"\"Centers the map view on a given object. Args: ee_object (Element|Geometry): An Earth Engine object to center on - a geometry, image or feature. zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10. \"\"\" lat = 0 lon = 0 bounds = [[ lat , lon ], [ lat , lon ]] if isinstance ( ee_object , ee . geometry . Geometry ): centroid = ee_object . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . featurecollection . FeatureCollection ): centroid = ee_object . geometry () . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . image . Image ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] else : bounds = [[ 0 , 0 ], [ 0 , 0 ]] self . fit_bounds ( bounds , max_zoom = zoom )","title":"center_object()"},{"location":"eefolium/#geemap.eefolium.Map.centerObject","text":"Centers the map view on a given object. Parameters: Name Type Description Default ee_object Element|Geometry An Earth Engine object to center on - a geometry, image or feature. required zoom int The zoom level, from 1 to 24. Defaults to 10. 10 Source code in geemap/eefolium.py def center_object ( self , ee_object , zoom = 10 ): \"\"\"Centers the map view on a given object. Args: ee_object (Element|Geometry): An Earth Engine object to center on - a geometry, image or feature. zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10. \"\"\" lat = 0 lon = 0 bounds = [[ lat , lon ], [ lat , lon ]] if isinstance ( ee_object , ee . geometry . Geometry ): centroid = ee_object . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . featurecollection . FeatureCollection ): centroid = ee_object . geometry () . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . image . Image ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] else : bounds = [[ 0 , 0 ], [ 0 , 0 ]] self . fit_bounds ( bounds , max_zoom = zoom )","title":"centerObject()"},{"location":"eefolium/#geemap.eefolium.Map.publish","text":"Publish the map to datapane.com Parameters: Name Type Description Default name str The URL of the map. Defaults to None. None headline str Title of the map. Defaults to 'Untitled'. 'Untitled' visibility str Visibility of the map. It can be one of the following: PUBLIC, PRIVATE, ORG. Defaults to 'PUBLIC'. 'PUBLIC' overwrite bool Whether to overwrite the existing map with the same name. Defaults to True. True open bool Whether to open the map. Defaults to True. True Source code in geemap/eefolium.py def publish ( self , name = None , headline = 'Untitled' , visibility = 'PUBLIC' , overwrite = True , open = True ): \"\"\"Publish the map to datapane.com Args: name (str, optional): The URL of the map. Defaults to None. headline (str, optional): Title of the map. Defaults to 'Untitled'. visibility (str, optional): Visibility of the map. It can be one of the following: PUBLIC, PRIVATE, ORG. Defaults to 'PUBLIC'. overwrite (bool, optional): Whether to overwrite the existing map with the same name. Defaults to True. open (bool, optional): Whether to open the map. Defaults to True. \"\"\" import webbrowser try : import datapane as dp except Exception as e : print ( 'The datapane Python package is not installed. You need to install and authenticate datapane first.' ) webbrowser . open_new_tab ( 'https://docs.datapane.com/tutorials/tut-getting-started' ) return import datapane as dp # import logging # logging.getLogger('googleapiclient.discovery_cache').setLevel(logging.ERROR) if name is None : name = 'folium_' + random_string ( 6 ) visibility = visibility . upper () if visibility not in [ 'PUBLIC' , 'PRIVATE' , 'ORG' ]: visibility = 'PRIVATE' if overwrite : delete_dp_report ( name ) report = dp . Report ( dp . Plot ( self )) report . publish ( name = name , headline = headline , visibility = visibility , open = open )","title":"publish()"},{"location":"eefolium/#geemap.eefolium.Map.set_center","text":"Centers the map view at a given coordinates with the given zoom level. Parameters: Name Type Description Default lon float The longitude of the center, in degrees. required lat float The latitude of the center, in degrees. required zoom int The zoom level, from 1 to 24. Defaults to 10. 10 Source code in geemap/eefolium.py def set_center ( self , lon , lat , zoom = 10 ): \"\"\"Centers the map view at a given coordinates with the given zoom level. Args: lon (float): The longitude of the center, in degrees. lat (float): The latitude of the center, in degrees. zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10. \"\"\" self . fit_bounds ([[ lat , lon ], [ lat , lon ]], max_zoom = zoom )","title":"set_center()"},{"location":"eefolium/#geemap.eefolium.Map.set_control_visibility","text":"Sets the visibility of the controls on the map. Parameters: Name Type Description Default layerControl bool Whether to show the control that allows the user to toggle layers on/off. Defaults to True. True fullscreenControl bool Whether to show the control that allows the user to make the map full-screen. Defaults to True. True latLngPopup bool Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. True Source code in geemap/eefolium.py def set_control_visibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ): \"\"\"Sets the visibility of the controls on the map. Args: layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True. fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True. latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. \"\"\" if layerControl : folium . LayerControl () . add_to ( self ) if fullscreenControl : plugins . Fullscreen () . add_to ( self ) if latLngPopup : folium . LatLngPopup () . add_to ( self )","title":"set_control_visibility()"},{"location":"eefolium/#geemap.eefolium.Map.set_options","text":"Adds Google basemap to the map. Parameters: Name Type Description Default mapTypeId str A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. 'HYBRID' styles [type] A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. {} types [type] A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. [] Source code in geemap/eefolium.py def setOptions ( self , mapTypeId = 'HYBRID' , styles = {}, types = []): \"\"\"Adds Google basemap to the map. Args: mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. styles ([type], optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. types ([type], optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. \"\"\" try : ee_basemaps [ mapTypeId ] . add_to ( self ) except : print ( 'Basemap can only be one of the following: {} ' . format ( ', ' . join ( ee_basemaps . keys ())))","title":"set_options()"},{"location":"eefolium/#geemap.eefolium.Map.setCenter","text":"Centers the map view at a given coordinates with the given zoom level. Parameters: Name Type Description Default lon float The longitude of the center, in degrees. required lat float The latitude of the center, in degrees. required zoom int The zoom level, from 1 to 24. Defaults to 10. 10 Source code in geemap/eefolium.py def set_center ( self , lon , lat , zoom = 10 ): \"\"\"Centers the map view at a given coordinates with the given zoom level. Args: lon (float): The longitude of the center, in degrees. lat (float): The latitude of the center, in degrees. zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10. \"\"\" self . fit_bounds ([[ lat , lon ], [ lat , lon ]], max_zoom = zoom )","title":"setCenter()"},{"location":"eefolium/#geemap.eefolium.Map.setControlVisibility","text":"Sets the visibility of the controls on the map. Parameters: Name Type Description Default layerControl bool Whether to show the control that allows the user to toggle layers on/off. Defaults to True. True fullscreenControl bool Whether to show the control that allows the user to make the map full-screen. Defaults to True. True latLngPopup bool Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. True Source code in geemap/eefolium.py def set_control_visibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ): \"\"\"Sets the visibility of the controls on the map. Args: layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True. fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True. latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. \"\"\" if layerControl : folium . LayerControl () . add_to ( self ) if fullscreenControl : plugins . Fullscreen () . add_to ( self ) if latLngPopup : folium . LatLngPopup () . add_to ( self )","title":"setControlVisibility()"},{"location":"eefolium/#geemap.eefolium.Map.setOptions","text":"Adds Google basemap to the map. Parameters: Name Type Description Default mapTypeId str A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. 'HYBRID' styles [type] A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. {} types [type] A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. [] Source code in geemap/eefolium.py def setOptions ( self , mapTypeId = 'HYBRID' , styles = {}, types = []): \"\"\"Adds Google basemap to the map. Args: mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. styles ([type], optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. types ([type], optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. \"\"\" try : ee_basemaps [ mapTypeId ] . add_to ( self ) except : print ( 'Basemap can only be one of the following: {} ' . format ( ', ' . join ( ee_basemaps . keys ())))","title":"setOptions()"},{"location":"eefolium/#geemap.eefolium.add_image_to_gif","text":"Adds an image logo to a GIF image. Parameters: Name Type Description Default in_gif str Input file path to the GIF image. required out_gif str Output file path to the GIF image. required in_image str Input file path to the image. required xy tuple Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. None image_size tuple Resize image. Defaults to (80, 80). (80, 80) circle_mask bool Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False. False Source code in geemap/eefolium.py def add_image_to_gif ( in_gif , out_gif , in_image , xy = None , image_size = ( 80 , 80 ), circle_mask = False ): \"\"\"Adds an image logo to a GIF image. Args: in_gif (str): Input file path to the GIF image. out_gif (str): Output file path to the GIF image. in_image (str): Input file path to the image. xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. image_size (tuple, optional): Resize image. Defaults to (80, 80). circle_mask (bool, optional): Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False. \"\"\" import io import warnings from PIL import Image , ImageDraw , ImageSequence , ImageFilter warnings . simplefilter ( 'ignore' ) in_gif = os . path . abspath ( in_gif ) is_url = False if in_image . startswith ( 'http' ): is_url = True if not os . path . exists ( in_gif ): print ( 'The input gif file does not exist.' ) return if ( not is_url ) and ( not os . path . exists ( in_image )): print ( 'The provided logo file does not exist.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) try : image = Image . open ( in_gif ) except Exception as e : print ( 'An error occurred while opening the image.' ) print ( e ) return try : if in_image . startswith ( 'http' ): logo_raw_image = open_image_from_url ( in_image ) else : in_image = os . path . abspath ( in_image ) logo_raw_image = Image . open ( in_image ) except Exception as e : print ( e ) logo_raw_size = logo_raw_image . size image_size = min ( logo_raw_size [ 0 ], image_size [ 0 ]), min ( logo_raw_size [ 1 ], image_size [ 1 ]) logo_image = logo_raw_image . convert ( 'RGBA' ) logo_image . thumbnail ( image_size , Image . ANTIALIAS ) W , H = image . size mask_im = None if circle_mask : mask_im = Image . new ( \"L\" , image_size , 0 ) draw = ImageDraw . Draw ( mask_im ) draw . ellipse (( 0 , 0 , image_size [ 0 ], image_size [ 1 ]), fill = 255 ) if has_transparency ( logo_raw_image ): mask_im = logo_image . copy () if xy is None : # default logo location is 5% width and 5% height of the image. xy = ( int ( 0.05 * W ), int ( 0.05 * H )) elif ( xy is not None ) and ( not isinstance ( xy , tuple )) and ( len ( xy ) == 2 ): print ( \"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\" ) return elif all ( isinstance ( item , int ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( x > 0 ) and ( x < W ) and ( y > 0 ) and ( y < H ): pass else : print ( 'xy is out of bounds. x must be within [0, {} ], and y must be within [0, {} ]' . format ( W , H )) return elif all ( isinstance ( item , str ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( '%' in x ) and ( '%' in y ): try : x = int ( float ( x . replace ( '%' , '' )) / 100.0 * W ) y = int ( float ( y . replace ( '%' , '' )) / 100.0 * H ) xy = ( x , y ) except Exception as e : print ( \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\" ) return else : print ( \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\" ) return try : frames = [] for index , frame in enumerate ( ImageSequence . Iterator ( image )): frame = frame . convert ( 'RGBA' ) frame . paste ( logo_image , xy , mask_im ) b = io . BytesIO () frame . save ( b , format = \"GIF\" ) frame = Image . open ( b ) frames . append ( frame ) frames [ 0 ] . save ( out_gif , save_all = True , append_images = frames [ 1 :]) except Exception as e : print ( e ) return","title":"add_image_to_gif()"},{"location":"eefolium/#geemap.eefolium.add_text_to_gif","text":"Adds animated text to a GIF image. Parameters: Name Type Description Default in_gif str The file path to the input GIF image. required out_gif str The file path to the output GIF image. required xy tuple Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. None text_sequence int, str, list Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None. None font_type str Font type. Defaults to \"arial.ttf\". 'arial.ttf' font_size int Font size. Defaults to 20. 20 font_color str Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff'). Defaults to '#000000'. '#000000' add_progress_bar bool Whether to add a progress bar at the bottom of the GIF. Defaults to True. True progress_bar_color str Color for the progress bar. Defaults to 'white'. 'white' progress_bar_height int Height of the progress bar. Defaults to 5. 5 duration int controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100. 100 loop int controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0. 0 Source code in geemap/eefolium.py def add_text_to_gif ( in_gif , out_gif , xy = None , text_sequence = None , font_type = \"arial.ttf\" , font_size = 20 , font_color = '#000000' , add_progress_bar = True , progress_bar_color = 'white' , progress_bar_height = 5 , duration = 100 , loop = 0 ): \"\"\"Adds animated text to a GIF image. Args: in_gif (str): The file path to the input GIF image. out_gif (str): The file path to the output GIF image. xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None. font_type (str, optional): Font type. Defaults to \"arial.ttf\". font_size (int, optional): Font size. Defaults to 20. font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff'). Defaults to '#000000'. add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True. progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'. progress_bar_height (int, optional): Height of the progress bar. Defaults to 5. duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100. loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0. \"\"\" import io import pkg_resources import warnings from PIL import Image , ImageDraw , ImageSequence , ImageFont warnings . simplefilter ( 'ignore' ) pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) default_font = os . path . join ( pkg_dir , 'data/fonts/arial.ttf' ) in_gif = os . path . abspath ( in_gif ) out_gif = os . path . abspath ( out_gif ) if not os . path . exists ( in_gif ): print ( 'The input gif file does not exist.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) if font_type == 'arial.ttf' : font = ImageFont . truetype ( default_font , font_size ) else : try : font_list = system_fonts ( show_full_path = True ) font_names = [ os . path . basename ( f ) for f in font_list ] if ( font_type in font_list ) or ( font_type in font_names ): font = ImageFont . truetype ( font_type , font_size ) else : print ( 'The specified font type could not be found on your system. Using the default font instead.' ) font = ImageFont . truetype ( default_font , font_size ) except Exception as e : print ( e ) font = ImageFont . truetype ( default_font , font_size ) color = check_color ( font_color ) progress_bar_color = check_color ( progress_bar_color ) try : image = Image . open ( in_gif ) except Exception as e : print ( 'An error occurred while opening the gif.' ) print ( e ) return count = image . n_frames W , H = image . size progress_bar_widths = [ i * 1.0 / count * W for i in range ( 1 , count + 1 )] progress_bar_shapes = [[( 0 , H - progress_bar_height ), ( x , H )] for x in progress_bar_widths ] if xy is None : # default text location is 5% width and 5% height of the image. xy = ( int ( 0.05 * W ), int ( 0.05 * H )) elif ( xy is not None ) and ( not isinstance ( xy , tuple )) and ( len ( xy ) == 2 ): print ( \"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\" ) return elif all ( isinstance ( item , int ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( x > 0 ) and ( x < W ) and ( y > 0 ) and ( y < H ): pass else : print ( 'xy is out of bounds. x must be within [0, {} ], and y must be within [0, {} ]' . format ( W , H )) return elif all ( isinstance ( item , str ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( '%' in x ) and ( '%' in y ): try : x = int ( float ( x . replace ( '%' , '' )) / 100.0 * W ) y = int ( float ( y . replace ( '%' , '' )) / 100.0 * H ) xy = ( x , y ) except Exception as e : print ( \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\" ) return else : print ( \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\" ) return if text_sequence is None : text = [ str ( x ) for x in range ( 1 , count + 1 )] elif isinstance ( text_sequence , int ): text = [ str ( x ) for x in range ( text_sequence , text_sequence + count + 1 )] elif isinstance ( text_sequence , str ): try : text_sequence = int ( text_sequence ) text = [ str ( x ) for x in range ( text_sequence , text_sequence + count + 1 )] except Exception as e : text = [ text_sequence ] * count elif isinstance ( text_sequence , list ) and len ( text_sequence ) != count : print ( 'The length of the text sequence must be equal to the number ( {} ) of frames in the gif.' . format ( count )) return else : text = [ str ( x ) for x in text_sequence ] try : frames = [] # Loop over each frame in the animated image for index , frame in enumerate ( ImageSequence . Iterator ( image )): # Draw the text on the frame frame = frame . convert ( 'RGB' ) draw = ImageDraw . Draw ( frame ) # w, h = draw.textsize(text[index]) draw . text ( xy , text [ index ], font = font , fill = color ) if add_progress_bar : draw . rectangle ( progress_bar_shapes [ index ], fill = progress_bar_color ) del draw b = io . BytesIO () frame . save ( b , format = \"GIF\" ) frame = Image . open ( b ) frames . append ( frame ) # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/ # Save the frames as a new image frames [ 0 ] . save ( out_gif , save_all = True , append_images = frames [ 1 :], duration = duration , loop = loop , optimize = True ) except Exception as e : print ( e ) return","title":"add_text_to_gif()"},{"location":"eefolium/#geemap.eefolium.check_color","text":"Checks the input color and returns the corresponding hex color code. Parameters: Name Type Description Default in_color str or tuple It can be a string (e.g., 'red', '#ffff00') or tuple (e.g., (255, 127, 0)). required Returns: Type Description str A hex color code. Source code in geemap/eefolium.py def check_color ( in_color ): \"\"\"Checks the input color and returns the corresponding hex color code. Args: in_color (str or tuple): It can be a string (e.g., 'red', '#ffff00') or tuple (e.g., (255, 127, 0)). Returns: str: A hex color code. \"\"\" out_color = '#000000' # default black color if isinstance ( in_color , tuple ) and len ( in_color ) == 3 : if all ( isinstance ( item , int ) for item in in_color ): rescaled_color = [ x / 255.0 for x in in_color ] out_color = colour . Color ( rgb = tuple ( rescaled_color )) return out_color . hex_l else : print ( 'RGB color must be a tuple with three integer values ranging from 0 to 255.' ) return else : try : out_color = colour . Color ( in_color ) return out_color . hex_l except Exception as e : print ( 'The provided color is invalid. Using the default black color.' ) print ( e ) return out_color","title":"check_color()"},{"location":"eefolium/#geemap.eefolium.check_install","text":"Checks whether a package is installed. If not, it will install the package. Parameters: Name Type Description Default package str The name of the package to check. required Source code in geemap/eefolium.py def check_install ( package ): \"\"\"Checks whether a package is installed. If not, it will install the package. Args: package (str): The name of the package to check. \"\"\" import subprocess try : __import__ ( package ) # print('{} is already installed.'.format(package)) except ImportError : print ( ' {} is not installed. Installing ...' . format ( package )) try : subprocess . check_call ([ \"python\" , '-m' , 'pip' , 'install' , package ]) except Exception as e : print ( 'Failed to install {} ' . format ( package )) print ( e ) print ( \" {} has been installed successfully.\" . format ( package ))","title":"check_install()"},{"location":"eefolium/#geemap.eefolium.clone_repo","text":"Clones the geemap GitHub repository. Parameters: Name Type Description Default out_dir str Output folder for the repo. Defaults to '.'. '.' unzip bool Whether to unzip the repository. Defaults to True. True Source code in geemap/eefolium.py def clone_repo ( out_dir = '.' , unzip = True ): \"\"\"Clones the geemap GitHub repository. Args: out_dir (str, optional): Output folder for the repo. Defaults to '.'. unzip (bool, optional): Whether to unzip the repository. Defaults to True. \"\"\" url = 'https://github.com/giswqs/geemap/archive/master.zip' filename = 'geemap-master.zip' download_from_url ( url , out_file_name = filename , out_dir = out_dir , unzip = unzip )","title":"clone_repo()"},{"location":"eefolium/#geemap.eefolium.copy_credentials_to_colab","text":"Copies ee credentials from Google Drive to Google Colab. Source code in geemap/eefolium.py def copy_credentials_to_colab (): \"\"\"Copies ee credentials from Google Drive to Google Colab. \"\"\" import shutil src = '/content/drive/My Drive/.config/earthengine/credentials' dst = '/root/.config/earthengine/credentials' wd = os . path . dirname ( dst ) if not os . path . exists ( wd ): os . makedirs ( wd ) shutil . copyfile ( src , dst )","title":"copy_credentials_to_colab()"},{"location":"eefolium/#geemap.eefolium.copy_credentials_to_drive","text":"Copies ee credentials from Google Colab to Google Drive. Source code in geemap/eefolium.py def copy_credentials_to_drive (): \"\"\"Copies ee credentials from Google Colab to Google Drive. \"\"\" import shutil src = '/root/.config/earthengine/credentials' dst = '/content/drive/My Drive/.config/earthengine/credentials' wd = os . path . dirname ( dst ) if not os . path . exists ( wd ): os . makedirs ( wd ) shutil . copyfile ( src , dst )","title":"copy_credentials_to_drive()"},{"location":"eefolium/#geemap.eefolium.create_code_cell","text":"Creates a code cell in the IPython Notebook. Parameters: Name Type Description Default code str Code to fill the new code cell with. Defaults to ''. '' where str Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. 'below' Source code in geemap/eefolium.py def create_code_cell ( code = '' , where = 'below' ): \"\"\"Creates a code cell in the IPython Notebook. Args: code (str, optional): Code to fill the new code cell with. Defaults to ''. where (str, optional): Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. \"\"\" import base64 from IPython.display import Javascript , display encoded_code = ( base64 . b64encode ( str . encode ( code ))) . decode () display ( Javascript ( \"\"\" var code = IPython.notebook.insert_cell_ {0} ('code'); code.set_text(atob(\" {1} \")); \"\"\" . format ( where , encoded_code )))","title":"create_code_cell()"},{"location":"eefolium/#geemap.eefolium.create_colorbar","text":"Creates a colorbar based on the provided palette. Parameters: Name Type Description Default width int Width of the colorbar in pixels. Defaults to 150. 150 height int Height of the colorbar in pixels. Defaults to 30. 30 palette list Palette for the colorbar. Each color can be provided as a string (e.g., 'red'), a hex string (e.g., '#ff0000'), or an RGB tuple (255, 0, 255). Defaults to ['blue', 'green', 'red']. ['blue', 'green', 'red'] add_ticks bool Whether to add tick markers to the colorbar. Defaults to True. True add_labels bool Whether to add labels to the colorbar. Defaults to True. True labels list A list of labels to add to the colorbar. Defaults to None. None vertical bool Whether to rotate the colorbar vertically. Defaults to False. False out_file str File path to the output colorbar in png format. Defaults to None. None font_type str Font type to use for labels. Defaults to 'arial.ttf'. 'arial.ttf' font_size int Font size to use for labels. Defaults to 12. 12 font_color str Font color to use for labels. Defaults to 'black'. 'black' add_outline bool Whether to add an outline to the colorbar. Defaults to True. True outline_color str Color for the outline of the colorbar. Defaults to 'black'. 'black' Returns: Type Description str File path of the output colorbar in png format. Source code in geemap/eefolium.py def create_colorbar ( width = 150 , height = 30 , palette = [ 'blue' , 'green' , 'red' ], add_ticks = True , add_labels = True , labels = None , vertical = False , out_file = None , font_type = 'arial.ttf' , font_size = 12 , font_color = 'black' , add_outline = True , outline_color = 'black' ): \"\"\"Creates a colorbar based on the provided palette. Args: width (int, optional): Width of the colorbar in pixels. Defaults to 150. height (int, optional): Height of the colorbar in pixels. Defaults to 30. palette (list, optional): Palette for the colorbar. Each color can be provided as a string (e.g., 'red'), a hex string (e.g., '#ff0000'), or an RGB tuple (255, 0, 255). Defaults to ['blue', 'green', 'red']. add_ticks (bool, optional): Whether to add tick markers to the colorbar. Defaults to True. add_labels (bool, optional): Whether to add labels to the colorbar. Defaults to True. labels (list, optional): A list of labels to add to the colorbar. Defaults to None. vertical (bool, optional): Whether to rotate the colorbar vertically. Defaults to False. out_file (str, optional): File path to the output colorbar in png format. Defaults to None. font_type (str, optional): Font type to use for labels. Defaults to 'arial.ttf'. font_size (int, optional): Font size to use for labels. Defaults to 12. font_color (str, optional): Font color to use for labels. Defaults to 'black'. add_outline (bool, optional): Whether to add an outline to the colorbar. Defaults to True. outline_color (str, optional): Color for the outline of the colorbar. Defaults to 'black'. Returns: str: File path of the output colorbar in png format. \"\"\" import decimal import io import math import pkg_resources import warnings from colour import Color from PIL import Image , ImageDraw , ImageFont warnings . simplefilter ( 'ignore' ) pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) if out_file is None : filename = 'colorbar_' + random_string () + '.png' out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) out_file = os . path . join ( out_dir , filename ) elif not out_file . endswith ( '.png' ): print ( 'The output file must end with .png' ) return else : out_file = os . path . abspath ( out_file ) if not os . path . exists ( os . path . dirname ( out_file )): os . makedirs ( os . path . dirname ( out_file )) im = Image . new ( 'RGBA' , ( width , height )) ld = im . load () def float_range ( start , stop , step ): while start < stop : yield float ( start ) start += decimal . Decimal ( step ) n_colors = len ( palette ) decimal_places = 2 rgb_colors = [ Color ( check_color ( c )) . rgb for c in palette ] keys = [ round ( c , decimal_places ) for c in list ( float_range ( 0 , 1.0001 , 1.0 / ( n_colors - 1 )))] heatmap = [] for index , item in enumerate ( keys ): pair = [ item , rgb_colors [ index ]] heatmap . append ( pair ) def gaussian ( x , a , b , c , d = 0 ): return a * math . exp ( - ( x - b ) ** 2 / ( 2 * c ** 2 )) + d def pixel ( x , width = 100 , map = [], spread = 1 ): width = float ( width ) r = sum ([ gaussian ( x , p [ 1 ][ 0 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) g = sum ([ gaussian ( x , p [ 1 ][ 1 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) b = sum ([ gaussian ( x , p [ 1 ][ 2 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) return min ( 1.0 , r ), min ( 1.0 , g ), min ( 1.0 , b ) for x in range ( im . size [ 0 ]): r , g , b = pixel ( x , width = width , map = heatmap ) r , g , b = [ int ( 256 * v ) for v in ( r , g , b )] for y in range ( im . size [ 1 ]): ld [ x , y ] = r , g , b if add_outline : draw = ImageDraw . Draw ( im ) draw . rectangle ([( 0 , 0 ), ( width - 1 , height - 1 )], outline = check_color ( outline_color )) del draw if add_ticks : tick_length = height * 0.1 x = [ key * width for key in keys ] y_top = height - tick_length y_bottom = height draw = ImageDraw . Draw ( im ) for i in x : shape = [( i , y_top ), ( i , y_bottom )] draw . line ( shape , fill = 'black' , width = 0 ) del draw if vertical : im = im . transpose ( Image . ROTATE_90 ) width , height = im . size if labels is None : labels = [ str ( c ) for c in keys ] elif len ( labels ) == 2 : try : lowerbound = float ( labels [ 0 ]) upperbound = float ( labels [ 1 ]) step = ( upperbound - lowerbound ) / ( len ( palette ) - 1 ) labels = [ str ( lowerbound + c * step ) for c in range ( 0 , len ( palette ))] except Exception as e : print ( e ) print ( 'The labels are invalid.' ) return elif len ( labels ) == len ( palette ): labels = [ str ( c ) for c in labels ] else : print ( 'The labels must have the same length as the palette.' ) return if add_labels : default_font = os . path . join ( pkg_dir , 'data/fonts/arial.ttf' ) if font_type == 'arial.ttf' : font = ImageFont . truetype ( default_font , font_size ) else : try : font_list = system_fonts ( show_full_path = True ) font_names = [ os . path . basename ( f ) for f in font_list ] if ( font_type in font_list ) or ( font_type in font_names ): font = ImageFont . truetype ( font_type , font_size ) else : print ( 'The specified font type could not be found on your system. Using the default font instead.' ) font = ImageFont . truetype ( default_font , font_size ) except Exception as e : print ( e ) font = ImageFont . truetype ( default_font , font_size ) font_color = check_color ( font_color ) draw = ImageDraw . Draw ( im ) w , h = draw . textsize ( labels [ 0 ], font = font ) for label in labels : w_tmp , h_tmp = draw . textsize ( label , font ) if w_tmp > w : w = w_tmp if h_tmp > h : h = h_tmp W , H = width + w * 2 , height + h * 2 background = Image . new ( 'RGBA' , ( W , H )) draw = ImageDraw . Draw ( background ) if vertical : xy = ( 0 , h ) else : xy = ( w , 0 ) background . paste ( im , xy , im ) for index , label in enumerate ( labels ): w_tmp , h_tmp = draw . textsize ( label , font ) if vertical : spacing = 5 x = width + spacing y = int ( height + h - keys [ index ] * height - h_tmp / 2 - 1 ) draw . text (( x , y ), label , font = font , fill = font_color ) else : x = int ( keys [ index ] * width + w - w_tmp / 2 ) spacing = int ( h * 0.05 ) y = height + spacing draw . text (( x , y ), label , font = font , fill = font_color ) im = background . copy () im . save ( out_file ) return out_file","title":"create_colorbar()"},{"location":"eefolium/#geemap.eefolium.credentials_in_colab","text":"Checks if the ee credentials file exists in Google Colab. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/eefolium.py def credentials_in_colab (): \"\"\"Checks if the ee credentials file exists in Google Colab. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" credentials_path = '/root/.config/earthengine/credentials' if os . path . exists ( credentials_path ): return True else : return False","title":"credentials_in_colab()"},{"location":"eefolium/#geemap.eefolium.credentials_in_drive","text":"Checks if the ee credentials file exists in Google Drive. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/eefolium.py def credentials_in_drive (): \"\"\"Checks if the ee credentials file exists in Google Drive. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" credentials_path = '/content/drive/My Drive/.config/earthengine/credentials' if os . path . exists ( credentials_path ): return True else : return False","title":"credentials_in_drive()"},{"location":"eefolium/#geemap.eefolium.delete_dp_report","text":"Deletes a datapane report. Parameters: Name Type Description Default name str Name of the report to delete. required Source code in geemap/eefolium.py def delete_dp_report ( name ): \"\"\"Deletes a datapane report. Args: name (str): Name of the report to delete. \"\"\" try : import datapane as dp reports = dp . Report . list () items = list ( reports ) names = list ( map ( lambda item : item [ 'name' ], items )) if name in names : report = dp . Report . get ( name ) url = report . blocks [ 0 ][ 'url' ] # print('Deleting {}...'.format(url)) dp . Report . delete ( dp . Report . by_id ( url )) except Exception as e : print ( e ) return","title":"delete_dp_report()"},{"location":"eefolium/#geemap.eefolium.delete_dp_reports","text":"Deletes all datapane reports. Source code in geemap/eefolium.py def delete_dp_reports (): \"\"\"Deletes all datapane reports. \"\"\" try : import datapane as dp reports = dp . Report . list () for item in reports : print ( item [ 'name' ]) report = dp . Report . get ( item [ 'name' ]) url = report . blocks [ 0 ][ 'url' ] print ( 'Deleting {} ...' . format ( url )) dp . Report . delete ( dp . Report . by_id ( url )) except Exception as e : print ( e ) return","title":"delete_dp_reports()"},{"location":"eefolium/#geemap.eefolium.download_ee_video","text":"Downloads a video thumbnail as a GIF image from Earth Engine. Parameters: Name Type Description Default collection object An ee.ImageCollection. required video_args [type] Parameters for expring the video thumbnail. required out_gif str File path to the output GIF. required Source code in geemap/eefolium.py def download_ee_video ( collection , video_args , out_gif ): \"\"\"Downloads a video thumbnail as a GIF image from Earth Engine. Args: collection (object): An ee.ImageCollection. video_args ([type]): Parameters for expring the video thumbnail. out_gif (str): File path to the output GIF. \"\"\" import requests out_gif = os . path . abspath ( out_gif ) if not out_gif . endswith ( \".gif\" ): print ( 'The output file must have an extension of .gif.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) if 'region' in video_args . keys (): roi = video_args [ 'region' ] if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return video_args [ 'region' ] = roi try : print ( 'Generating URL...' ) url = collection . getVideoThumbURL ( video_args ) print ( 'Downloading GIF image from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading.' ) return else : with open ( out_gif , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) print ( 'The GIF image has been saved to: {} ' . format ( out_gif )) except Exception as e : print ( e )","title":"download_ee_video()"},{"location":"eefolium/#geemap.eefolium.ee_data_html","text":"Generates HTML from an asset to be used in the HTML widget. Parameters: Name Type Description Default asset dict A dictionary containing an Earth Engine asset. required Returns: Type Description str A string containing HTML. Source code in geemap/eefolium.py def ee_data_html ( asset ): \"\"\"Generates HTML from an asset to be used in the HTML widget. Args: asset (dict): A dictionary containing an Earth Engine asset. Returns: str: A string containing HTML. \"\"\" template = ''' <html> <body> <h3>asset_title</h3> <h4>Dataset Availability</h4> <p style=\"margin-left: 40px\">asset_dates</p> <h4>Earth Engine Snippet</h4> <p style=\"margin-left: 40px\">ee_id_snippet</p> <h4>Earth Engine Data Catalog</h4> <p style=\"margin-left: 40px\"><a href=\"asset_url\" target=\"_blank\">asset_id</a></p> <h4>Dataset Thumbnail</h4> <img src=\"thumbnail_url\"> </body> </html> ''' try : text = template . replace ( 'asset_title' , asset [ 'title' ]) text = text . replace ( 'asset_dates' , asset [ 'dates' ]) text = text . replace ( 'ee_id_snippet' , asset [ 'ee_id_snippet' ]) text = text . replace ( 'asset_id' , asset [ 'id' ]) text = text . replace ( 'asset_url' , asset [ 'asset_url' ]) # asset['thumbnail'] = ee_data_thumbnail(asset['id']) text = text . replace ( 'thumbnail_url' , asset [ 'thumbnail_url' ]) return text except Exception as e : print ( e ) return","title":"ee_data_html()"},{"location":"eefolium/#geemap.eefolium.ee_data_thumbnail","text":"Retrieves the thumbnail URL of an Earth Engine asset. Parameters: Name Type Description Default asset_id str An Earth Engine asset id. required Returns: Type Description str An http url of the thumbnail. Source code in geemap/eefolium.py def ee_data_thumbnail ( asset_id ): \"\"\"Retrieves the thumbnail URL of an Earth Engine asset. Args: asset_id (str): An Earth Engine asset id. Returns: str: An http url of the thumbnail. \"\"\" import requests import urllib from bs4 import BeautifulSoup asset_uid = asset_id . replace ( '/' , '_' ) asset_url = \"https://developers.google.com/earth-engine/datasets/catalog/ {} \" . format ( asset_uid ) thumbnail_url = 'https://mw1.google.com/ges/dd/images/ {} _sample.png' . format ( asset_uid ) r = requests . get ( thumbnail_url ) try : if r . status_code != 200 : html_page = urllib . request . urlopen ( asset_url ) soup = BeautifulSoup ( html_page , features = \"html.parser\" ) for img in soup . findAll ( 'img' ): if 'sample.png' in img . get ( 'src' ): thumbnail_url = img . get ( 'src' ) return thumbnail_url return thumbnail_url except Exception as e : print ( e ) return","title":"ee_data_thumbnail()"},{"location":"eefolium/#geemap.eefolium.ee_export_image","text":"Exports an ee.Image as a GeoTIFF. Parameters: Name Type Description Default ee_object object The ee.Image to download. required filename str Output filename for the exported image. required scale float A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. None crs str A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. None region object A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. None file_per_band bool Whether to produce a different GeoTIFF per band. Defaults to False. False Source code in geemap/eefolium.py def ee_export_image ( ee_object , filename , scale = None , crs = None , region = None , file_per_band = False ): \"\"\"Exports an ee.Image as a GeoTIFF. Args: ee_object (object): The ee.Image to download. filename (str): Output filename for the exported image. scale (float, optional): A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. crs (str, optional): A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. region (object, optional): A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. file_per_band (bool, optional): Whether to produce a different GeoTIFF per band. Defaults to False. \"\"\" import requests import zipfile ee_initialize () if not isinstance ( ee_object , ee . Image ): print ( 'The ee_object must be an ee.Image.' ) return filename = os . path . abspath ( filename ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () filename_zip = filename . replace ( '.tif' , '.zip' ) if filetype != 'tif' : print ( 'The filename must end with .tif' ) return try : print ( 'Generating URL ...' ) params = { 'name' : name , 'filePerBand' : file_per_band } if scale is None : scale = ee_object . projection () . nominalScale () . multiply ( 10 ) params [ 'scale' ] = scale if region is None : region = ee_object . geometry () params [ 'region' ] = region if crs is not None : params [ 'crs' ] = crs url = ee_object . getDownloadURL ( params ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading.' ) return with open ( filename_zip , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) except Exception as e : print ( 'An error occurred while downloading.' ) print ( e ) return try : z = zipfile . ZipFile ( filename_zip ) z . extractall ( os . path . dirname ( filename )) os . remove ( filename_zip ) if file_per_band : print ( 'Data downloaded to {} ' . format ( os . path . dirname ( filename ))) else : print ( 'Data downloaded to {} ' . format ( filename )) except Exception as e : print ( e )","title":"ee_export_image()"},{"location":"eefolium/#geemap.eefolium.ee_export_image_collection","text":"Exports an ImageCollection as GeoTIFFs. Parameters: Name Type Description Default ee_object object The ee.Image to download. required out_dir str The output directory for the exported images. required scale float A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. None crs str A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. None region object A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. None file_per_band bool Whether to produce a different GeoTIFF per band. Defaults to False. False Source code in geemap/eefolium.py def ee_export_image_collection ( ee_object , out_dir , scale = None , crs = None , region = None , file_per_band = False ): \"\"\"Exports an ImageCollection as GeoTIFFs. Args: ee_object (object): The ee.Image to download. out_dir (str): The output directory for the exported images. scale (float, optional): A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. crs (str, optional): A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. region (object, optional): A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. file_per_band (bool, optional): Whether to produce a different GeoTIFF per band. Defaults to False. \"\"\" import requests import zipfile ee_initialize () if not isinstance ( ee_object , ee . ImageCollection ): print ( 'The ee_object must be an ee.ImageCollection.' ) return if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) try : count = int ( ee_object . size () . getInfo ()) print ( \"Total number of images: {} \\n \" . format ( count )) for i in range ( 0 , count ): image = ee . Image ( ee_object . toList ( count ) . get ( i )) name = image . get ( 'system:index' ) . getInfo () + '.tif' filename = os . path . join ( os . path . abspath ( out_dir ), name ) print ( 'Exporting {} / {} : {} ' . format ( i + 1 , count , name )) ee_export_image ( image , filename = filename , scale = scale , crs = crs , region = region , file_per_band = file_per_band ) print ( ' \\n ' ) except Exception as e : print ( e )","title":"ee_export_image_collection()"},{"location":"eefolium/#geemap.eefolium.ee_export_vector","text":"Exports Earth Engine FeatureCollection to other formats, including shp, csv, json, kml, and kmz. Parameters: Name Type Description Default ee_object object ee.FeatureCollection to export. required filename str Output file name. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/eefolium.py def ee_export_vector ( ee_object , filename , selectors = None ): \"\"\"Exports Earth Engine FeatureCollection to other formats, including shp, csv, json, kml, and kmz. Args: ee_object (object): ee.FeatureCollection to export. filename (str): Output file name. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" import requests import zipfile ee_initialize () if not isinstance ( ee_object , ee . FeatureCollection ): print ( 'The ee_object must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' ] filename = os . path . abspath ( filename ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () filename_shp = filename if filetype == 'shp' : filename = filename . replace ( '.shp' , '.zip' ) if not ( filetype . lower () in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return if selectors is None : selectors = ee_object . first () . propertyNames () . getInfo () elif not isinstance ( selectors , list ): print ( \"selectors must be a list, such as ['attribute1', 'attribute2']\" ) return else : allowed_attributes = ee_object . first () . propertyNames () . getInfo () for attribute in selectors : if not ( attribute in allowed_attributes ): print ( 'Attributes must be one chosen from: {} ' . format ( ', ' . join ( allowed_attributes ))) return try : print ( 'Generating URL ...' ) url = ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading. \\n Retrying ...' ) try : new_ee_object = ee_object . map ( filter_polygons ) print ( 'Generating URL ...' ) url = new_ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) except Exception as e : print ( e ) with open ( filename , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) except Exception as e : print ( 'An error occurred while downloading.' ) print ( e ) return try : if filetype == 'shp' : z = zipfile . ZipFile ( filename ) z . extractall ( os . path . dirname ( filename )) os . remove ( filename ) filename = filename . replace ( '.zip' , '.shp' ) print ( 'Data downloaded to {} ' . format ( filename )) except Exception as e : print ( e )","title":"ee_export_vector()"},{"location":"eefolium/#geemap.eefolium.ee_initialize","text":"Authenticates Earth Engine and initialize an Earth Engine session Source code in geemap/eefolium.py def ee_initialize ( token_name = 'EARTHENGINE_TOKEN' ): \"\"\"Authenticates Earth Engine and initialize an Earth Engine session \"\"\" try : ee_token = os . environ . get ( token_name ) if ee_token is not None : credential = '{\"refresh_token\":\" %s \"}' % ee_token credential_file_path = os . path . expanduser ( \"~/.config/earthengine/\" ) os . makedirs ( credential_file_path , exist_ok = True ) with open ( credential_file_path + 'credentials' , 'w' ) as file : file . write ( credential ) elif in_colab_shell (): if credentials_in_drive () and ( not credentials_in_colab ()): copy_credentials_to_colab () elif not credentials_in_colab : ee . Authenticate () if is_drive_mounted () and ( not credentials_in_drive ()): copy_credentials_to_drive () else : if is_drive_mounted (): copy_credentials_to_drive () ee . Initialize () except : ee . Authenticate () ee . Initialize ()","title":"ee_initialize()"},{"location":"eefolium/#geemap.eefolium.ee_tile_layer","text":"Converts and Earth Engine layer to ipyleaflet TileLayer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer untitled'. 'Layer untitled' shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/eefolium.py def ee_tile_layer ( ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ): \"\"\"Converts and Earth Engine layer to ipyleaflet TileLayer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer untitled'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" ee_initialize () image = None if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) tile_layer = ipyleaflet . TileLayer ( url = map_id_dict [ 'tile_fetcher' ] . url_format , attribution = 'Google Earth Engine' , name = name , opacity = opacity , visible = True # visible=shown ) return tile_layer","title":"ee_tile_layer()"},{"location":"eefolium/#geemap.eefolium.ee_to_csv","text":"Downloads an ee.FeatureCollection as a CSV file. Parameters: Name Type Description Default ee_object object ee.FeatureCollection required filename str The output filepath of the CSV file. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/eefolium.py def ee_to_csv ( ee_object , filename , selectors = None ): \"\"\"Downloads an ee.FeatureCollection as a CSV file. Args: ee_object (object): ee.FeatureCollection filename (str): The output filepath of the CSV file. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" ee_initialize () try : if filename . lower () . endswith ( '.csv' ): ee_export_vector ( ee_object = ee_object , filename = filename , selectors = selectors ) else : print ( 'The filename must end with .csv' ) except Exception as e : print ( e )","title":"ee_to_csv()"},{"location":"eefolium/#geemap.eefolium.ee_to_geojson","text":"Converts Earth Engine object to geojson. Parameters: Name Type Description Default ee_object object An Earth Engine object. required Returns: Type Description object GeoJSON object. Source code in geemap/eefolium.py def ee_to_geojson ( ee_object , out_json = None ): \"\"\"Converts Earth Engine object to geojson. Args: ee_object (object): An Earth Engine object. Returns: object: GeoJSON object. \"\"\" from json import dumps ee_initialize () try : if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): json_object = ee_object . getInfo () if out_json is not None : out_json = os . path . abspath ( out_json ) if not os . path . exists ( os . path . dirname ( out_json )): os . makedirs ( os . path . dirname ( out_json )) geojson = open ( out_json , \"w\" ) geojson . write ( dumps ({ \"type\" : \"FeatureCollection\" , \"features\" : json_object }, indent = 2 ) + \" \\n \" ) geojson . close () return json_object else : print ( \"Could not convert the Earth Engine object to geojson\" ) except Exception as e : print ( e )","title":"ee_to_geojson()"},{"location":"eefolium/#geemap.eefolium.ee_to_numpy","text":"Extracts a rectangular region of pixels from an image into a 2D numpy array per band. Parameters: Name Type Description Default ee_object object The image to sample. required bands list The list of band names to extract. Please make sure that all bands have the same spatial resolution. Defaults to None. None region object The region whose projected bounding box is used to sample the image. The maximum number of pixels you can export is 262,144. Resampling and reprojecting all bands to a fixed scale can be useful. Defaults to the footprint in each band. None properties list The properties to copy over from the sampled image. Defaults to all non-system properties. None default_value float A default value used when a sampled pixel is masked or outside a band's footprint. Defaults to None. None Returns: Type Description array A 3D numpy array. Source code in geemap/eefolium.py def ee_to_numpy ( ee_object , bands = None , region = None , properties = None , default_value = None ): \"\"\"Extracts a rectangular region of pixels from an image into a 2D numpy array per band. Args: ee_object (object): The image to sample. bands (list, optional): The list of band names to extract. Please make sure that all bands have the same spatial resolution. Defaults to None. region (object, optional): The region whose projected bounding box is used to sample the image. The maximum number of pixels you can export is 262,144. Resampling and reprojecting all bands to a fixed scale can be useful. Defaults to the footprint in each band. properties (list, optional): The properties to copy over from the sampled image. Defaults to all non-system properties. default_value (float, optional): A default value used when a sampled pixel is masked or outside a band's footprint. Defaults to None. Returns: array: A 3D numpy array. \"\"\" import numpy as np if not isinstance ( ee_object , ee . Image ): print ( 'The input must be an ee.Image.' ) return if region is None : region = ee_object . geometry () try : if bands is not None : ee_object = ee_object . select ( bands ) else : bands = ee_object . bandNames () . getInfo () band_count = len ( bands ) band_arrs = ee_object . sampleRectangle ( region = region , properties = properties , defaultValue = default_value ) band_values = [] for band in bands : band_arr = band_arrs . get ( band ) . getInfo () band_value = np . array ( band_arr ) band_values . append ( band_value ) image = np . dstack ( band_values ) return image except Exception as e : print ( e )","title":"ee_to_numpy()"},{"location":"eefolium/#geemap.eefolium.ee_to_shp","text":"Downloads an ee.FeatureCollection as a shapefile. Parameters: Name Type Description Default ee_object object ee.FeatureCollection required filename str The output filepath of the shapefile. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/eefolium.py def ee_to_shp ( ee_object , filename , selectors = None ): \"\"\"Downloads an ee.FeatureCollection as a shapefile. Args: ee_object (object): ee.FeatureCollection filename (str): The output filepath of the shapefile. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" ee_initialize () try : if filename . lower () . endswith ( '.shp' ): ee_export_vector ( ee_object = ee_object , filename = filename , selectors = selectors ) else : print ( 'The filename must end with .shp' ) except Exception as e : print ( e )","title":"ee_to_shp()"},{"location":"eefolium/#geemap.eefolium.filter_polygons","text":"Converts GeometryCollection to Polygon/MultiPolygon Parameters: Name Type Description Default ftr object ee.Feature required Returns: Type Description object ee.Feature Source code in geemap/eefolium.py def filter_polygons ( ftr ): \"\"\"Converts GeometryCollection to Polygon/MultiPolygon Args: ftr (object): ee.Feature Returns: object: ee.Feature \"\"\" ee_initialize () geometries = ftr . geometry () . geometries () geometries = geometries . map ( lambda geo : ee . Feature ( ee . Geometry ( geo )) . set ( 'geoType' , ee . Geometry ( geo ) . type ())) polygons = ee . FeatureCollection ( geometries ) . filter ( ee . Filter . eq ( 'geoType' , 'Polygon' )) . geometry () return ee . Feature ( polygons ) . copyProperties ( ftr )","title":"filter_polygons()"},{"location":"eefolium/#geemap.eefolium.geocode","text":"Search location by address and lat/lon coordinates. Parameters: Name Type Description Default location str Place name or address required max_rows int Maximum number of records to return. Defaults to 10. 10 reverse bool Search place based on coordinates. Defaults to False. False Returns: Type Description list Returns a list of locations. Source code in geemap/eefolium.py def geocode ( location , max_rows = 10 , reverse = False ): \"\"\"Search location by address and lat/lon coordinates. Args: location (str): Place name or address max_rows (int, optional): Maximum number of records to return. Defaults to 10. reverse (bool, optional): Search place based on coordinates. Defaults to False. Returns: list: Returns a list of locations. \"\"\" if not isinstance ( location , str ): print ( 'The location must be a string.' ) return None if not reverse : locations = [] addresses = set () g = geocoder . arcgis ( location , maxRows = max_rows ) for result in g : address = result . address if not address in addresses : addresses . add ( address ) locations . append ( result ) if len ( locations ) > 0 : return locations else : return None else : try : if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return g = geocoder . arcgis ( latlon , method = 'reverse' ) locations = [] addresses = set () for result in g : address = result . address if not address in addresses : addresses . add ( address ) locations . append ( result ) if len ( locations ) > 0 : return locations else : return None except Exception as e : print ( e ) return None","title":"geocode()"},{"location":"eefolium/#geemap.eefolium.geojson_to_ee","text":"Converts a geojson to ee.Geometry() Parameters: Name Type Description Default geo_json dict A geojson geometry dictionary or file path. required Returns: Type Description ee_object An ee.Geometry object Source code in geemap/eefolium.py def geojson_to_ee ( geo_json , geodesic = True ): \"\"\"Converts a geojson to ee.Geometry() Args: geo_json (dict): A geojson geometry dictionary or file path. Returns: ee_object: An ee.Geometry object \"\"\" ee_initialize () try : import json if not isinstance ( geo_json , dict ) and os . path . isfile ( geo_json ): with open ( os . path . abspath ( geo_json )) as f : geo_json = json . load ( f ) if geo_json [ 'type' ] == 'FeatureCollection' : features = ee . FeatureCollection ( geo_json [ 'features' ]) return features elif geo_json [ 'type' ] == 'Feature' : geom = None keys = geo_json [ 'properties' ][ 'style' ] . keys () if 'radius' in keys : # Checks whether it is a circle geom = ee . Geometry ( geo_json [ 'geometry' ]) radius = geo_json [ 'properties' ][ 'style' ][ 'radius' ] geom = geom . buffer ( radius ) elif geo_json [ 'geometry' ][ 'type' ] == 'Point' : # Checks whether it is a point coordinates = geo_json [ 'geometry' ][ 'coordinates' ] longitude = coordinates [ 0 ] latitude = coordinates [ 1 ] geom = ee . Geometry . Point ( longitude , latitude ) else : geom = ee . Geometry ( geo_json [ 'geometry' ], \"\" , geodesic ) return geom else : print ( \"Could not convert the geojson to ee.Geometry()\" ) except Exception as e : print ( \"Could not convert the geojson to ee.Geometry()\" ) print ( e )","title":"geojson_to_ee()"},{"location":"eefolium/#geemap.eefolium.has_transparency","text":"Checks whether an image has transparency. Parameters: Name Type Description Default img object a PIL Image object. required Returns: Type Description bool True if it has transparency, False otherwise. Source code in geemap/eefolium.py def has_transparency ( img ): \"\"\"Checks whether an image has transparency. Args: img (object): a PIL Image object. Returns: bool: True if it has transparency, False otherwise. \"\"\" if img . mode == \"P\" : transparent = img . info . get ( \"transparency\" , - 1 ) for _ , index in img . getcolors (): if index == transparent : return True elif img . mode == \"RGBA\" : extrema = img . getextrema () if extrema [ 3 ][ 0 ] < 255 : return True return False","title":"has_transparency()"},{"location":"eefolium/#geemap.eefolium.hex_to_rgb","text":"Converts hex color to RGB color. Parameters: Name Type Description Default value str Hex color code as a string. Defaults to 'FFFFFF'. 'FFFFFF' Returns: Type Description tuple RGB color as a tuple. Source code in geemap/eefolium.py def hex_to_rgb ( value = 'FFFFFF' ): \"\"\"Converts hex color to RGB color. Args: value (str, optional): Hex color code as a string. Defaults to 'FFFFFF'. Returns: tuple: RGB color as a tuple. \"\"\" value = value . lstrip ( '#' ) lv = len ( value ) return tuple ( int ( value [ i : i + lv // 3 ], 16 ) for i in range ( 0 , lv , lv // 3 ))","title":"hex_to_rgb()"},{"location":"eefolium/#geemap.eefolium.in_colab_shell","text":"Tests if the code is being executed within Google Colab. Source code in geemap/eefolium.py def in_colab_shell (): \"\"\"Tests if the code is being executed within Google Colab.\"\"\" try : import google.colab # pylint: disable=unused-variable return True except ImportError : return False","title":"in_colab_shell()"},{"location":"eefolium/#geemap.eefolium.install_from_github","text":"Install a package from a GitHub repository. Parameters: Name Type Description Default url str The URL of the GitHub repository. required Source code in geemap/eefolium.py def install_from_github ( url ): \"\"\"Install a package from a GitHub repository. Args: url (str): The URL of the GitHub repository. \"\"\" try : download_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) if not os . path . exists ( download_dir ): os . makedirs ( download_dir ) repo_name = os . path . basename ( url ) zip_url = os . path . join ( url , 'archive/master.zip' ) filename = repo_name + '-master.zip' download_from_url ( url = zip_url , out_file_name = filename , out_dir = download_dir , unzip = True ) pkg_dir = os . path . join ( download_dir , repo_name + '-master' ) work_dir = os . getcwd () os . chdir ( pkg_dir ) cmd = 'pip install .' os . system ( cmd ) os . chdir ( work_dir ) print ( \" \\n Please comment out 'install_from_github()' and restart the kernel to take effect: \\n Jupyter menu -> Kernel -> Restart & Clear Output\" ) except Exception as e : print ( e )","title":"install_from_github()"},{"location":"eefolium/#geemap.eefolium.is_drive_mounted","text":"Checks whether Google Drive is mounted in Google Colab. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/eefolium.py def is_drive_mounted (): \"\"\"Checks whether Google Drive is mounted in Google Colab. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" drive_path = '/content/drive/My Drive' if os . path . exists ( drive_path ): return True else : return False","title":"is_drive_mounted()"},{"location":"eefolium/#geemap.eefolium.is_latlon_valid","text":"Checks whether a pair of coordinates is valid. Parameters: Name Type Description Default location str A pair of latlon coordinates separated by comma or space. required Returns: Type Description bool Returns True if valid. Source code in geemap/eefolium.py def is_latlon_valid ( location ): \"\"\"Checks whether a pair of coordinates is valid. Args: location (str): A pair of latlon coordinates separated by comma or space. Returns: bool: Returns True if valid. \"\"\" latlon = [] if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return False try : lat , lon = float ( latlon [ 0 ]), float ( latlon [ 1 ]) if lat >= - 90 and lat <= 90 and lon >= - 180 and lat <= 180 : return True else : return False except Exception as e : print ( e ) return False","title":"is_latlon_valid()"},{"location":"eefolium/#geemap.eefolium.landsat_timeseries","text":"Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Parameters: Name Type Description Default roi [type] [description]. Defaults to None. None start_year int [description]. Defaults to 1984. 1984 end_year int [description]. Defaults to 2019. 2019 start_date str [description]. Defaults to '06-10'. '06-10' end_date str [description]. Defaults to '09-20'. '09-20' roi object Region of interest to create the timelapse. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 1984. 1984 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. '06-10' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. '09-20' Returns: Type Description object Returns an ImageCollection containing annual Landsat images. Source code in geemap/eefolium.py def landsat_timeseries ( roi = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' ): \"\"\"Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Args: roi ([type], optional): [description]. Defaults to None. start_year (int, optional): [description]. Defaults to 1984. end_year (int, optional): [description]. Defaults to 2019. start_date (str, optional): [description]. Defaults to '06-10'. end_date (str, optional): [description]. Defaults to '09-20'. roi (object, optional): Region of interest to create the timelapse. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 1984. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. Returns: object: Returns an ImageCollection containing annual Landsat images. \"\"\" ################################################################################ # Input and output parameters. import re import datetime ee_initialize () if roi is None : # roi = ee.Geometry.Polygon( # [[[-180, -80], # [-180, 80], # [180, 80], # [180, -80], # [-180, -80]]], None, False) roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return ################################################################################ # Setup vars to get dates. if isinstance ( start_year , int ) and ( start_year >= 1984 ) and ( start_year < 2020 ): pass else : print ( 'The start year must be an integer >= 1984.' ) return if isinstance ( end_year , int ) and ( end_year > 1984 ) and ( end_year <= 2020 ): pass else : print ( 'The end year must be an integer <= 2020.' ) return if re . match ( \"[0-9] {2} \\-[0-9] {2} \" , start_date ) and re . match ( \"[0-9] {2} \\-[0-9] {2} \" , end_date ): pass else : print ( 'The start date and end date must be month-day, such as 06-10, 09-20' ) return try : datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) except Exception as e : print ( 'The input dates are invalid.' ) return def days_between ( d1 , d2 ): d1 = datetime . datetime . strptime ( d1 , \"%Y-%m- %d \" ) d2 = datetime . datetime . strptime ( d2 , \"%Y-%m- %d \" ) return abs (( d2 - d1 ) . days ) n_days = days_between ( str ( start_year ) + '-' + start_date , str ( start_year ) + '-' + end_date ) start_month = int ( start_date [: 2 ]) start_day = int ( start_date [ 3 : 5 ]) start_date = str ( start_year ) + '-' + start_date end_date = str ( end_year ) + '-' + end_date # Define a collection filter by date, bounds, and quality. def colFilter ( col , aoi ): # , startDate, endDate): return ( col . filterBounds ( aoi )) # Landsat collection preprocessingEnabled # Get Landsat surface reflectance collections for OLI, ETM+ and TM sensors. LC08col = ee . ImageCollection ( 'LANDSAT/LC08/C01/T1_SR' ) LE07col = ee . ImageCollection ( 'LANDSAT/LE07/C01/T1_SR' ) LT05col = ee . ImageCollection ( 'LANDSAT/LT05/C01/T1_SR' ) LT04col = ee . ImageCollection ( 'LANDSAT/LT04/C01/T1_SR' ) # Define a collection filter by date, bounds, and quality. def colFilter ( col , roi , start_date , end_date ): return ( col . filterBounds ( roi ) . filterDate ( start_date , end_date )) # .filter('CLOUD_COVER < 5') # .filter('GEOMETRIC_RMSE_MODEL < 15') # .filter('IMAGE_QUALITY == 9 || IMAGE_QUALITY_OLI == 9')) # Function to get and rename bands of interest from OLI. def renameOli ( img ): return ( img . select ( [ 'B2' , 'B3' , 'B4' , 'B5' , 'B6' , 'B7' , 'pixel_qa' ], [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ])) # Function to get and rename bands of interest from ETM+. def renameEtm ( img ): return ( img . select ( [ 'B1' , 'B2' , 'B3' , 'B4' , 'B5' , 'B7' , 'pixel_qa' ], [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ])) # Add NBR for LandTrendr segmentation. def calcNbr ( img ): return ( img . addBands ( img . normalizedDifference ([ 'NIR' , 'SWIR2' ]) . multiply ( - 10000 ) . rename ( 'NBR' )) . int16 ()) # Define function to mask out clouds and cloud shadows in images. # Use CFmask band included in USGS Landsat SR image product. def fmask ( img ): cloudShadowBitMask = 1 << 3 cloudsBitMask = 1 << 5 qa = img . select ( 'pixel_qa' ) mask = qa . bitwiseAnd ( cloudShadowBitMask ) . eq ( 0 ) \\ . And ( qa . bitwiseAnd ( cloudsBitMask ) . eq ( 0 )) return ( img . updateMask ( mask )) # Define function to prepare OLI images. def prepOli ( img ): orig = img img = renameOli ( img ) img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Define function to prepare ETM+ images. def prepEtm ( img ): orig = img img = renameEtm ( img ) img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Get annual median collection. def getAnnualComp ( y ): startDate = ee . Date . fromYMD ( ee . Number ( y ), ee . Number ( start_month ), ee . Number ( start_day )) endDate = startDate . advance ( ee . Number ( n_days ), 'day' ) # Filter collections and prepare them for merging. LC08coly = colFilter ( LC08col , roi , startDate , endDate ) . map ( prepOli ) LE07coly = colFilter ( LE07col , roi , startDate , endDate ) . map ( prepEtm ) LT05coly = colFilter ( LT05col , roi , startDate , endDate ) . map ( prepEtm ) LT04coly = colFilter ( LT04col , roi , startDate , endDate ) . map ( prepEtm ) # Merge the collections. col = LC08coly . merge ( LE07coly ) . merge ( LT05coly ) . merge ( LT04coly ) yearImg = col . median () nBands = yearImg . bandNames () . size () yearImg = ee . Image ( ee . Algorithms . If ( nBands , yearImg , dummyImg )) return ( calcNbr ( yearImg ) . set ({ 'year' : y , 'system:time_start' : startDate . millis (), 'nBands' : nBands })) ################################################################################ # Make a dummy image for missing years. bandNames = ee . List ([ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ]) fillerValues = ee . List . repeat ( 0 , bandNames . size ()) dummyImg = ee . Image . constant ( fillerValues ) . rename ( bandNames ) \\ . selfMask () . int16 () ################################################################################ # Get a list of years years = ee . List . sequence ( start_year , end_year ) ################################################################################ # Make list of annual image composites. imgList = years . map ( getAnnualComp ) # Convert image composite list to collection imgCol = ee . ImageCollection . fromImages ( imgList ) imgCol = imgCol . map ( lambda img : img . clip ( roi )) return imgCol","title":"landsat_timeseries()"},{"location":"eefolium/#geemap.eefolium.landsat_ts_gif","text":"Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work. Parameters: Name Type Description Default roi object Region of interest to create the timelapse. Defaults to None. None out_gif [type] File path to the output animated GIF. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 1984. 1984 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. '06-10' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. '09-20' bands list Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. ['NIR', 'Red', 'Green'] vis_params dict Visualization parameters. Defaults to None. None dimensions int a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. 768 frames_per_second int Animation speed. Defaults to 10. 10 Returns: Type Description str File path to the output GIF image. Source code in geemap/eefolium.py def landsat_ts_gif ( roi = None , out_gif = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' , bands = [ 'NIR' , 'Red' , 'Green' ], vis_params = None , dimensions = 768 , frames_per_second = 10 ): \"\"\"Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work. Args: roi (object, optional): Region of interest to create the timelapse. Defaults to None. out_gif ([type], optional): File path to the output animated GIF. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 1984. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. bands (list, optional): Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. vis_params (dict, optional): Visualization parameters. Defaults to None. dimensions (int, optional): a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. frames_per_second (int, optional): Animation speed. Defaults to 10. Returns: str: File path to the output GIF image. \"\"\" ee_initialize () if roi is None : roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) elif isinstance ( roi , ee . Feature ) or isinstance ( roi , ee . FeatureCollection ): roi = roi . geometry () elif isinstance ( roi , ee . Geometry ): pass else : print ( 'The provided roi is invalid. It must be an ee.Geometry' ) return if out_gif is None : out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) filename = 'landsat_ts_' + random_string () + '.gif' out_gif = os . path . join ( out_dir , filename ) elif not out_gif . endswith ( '.gif' ): print ( 'The output file must end with .gif' ) return elif not os . path . isfile ( out_gif ): print ( 'The output file must be a file' ) return else : out_gif = os . path . abspath ( out_gif ) out_dir = os . path . dirname ( out_gif ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) allowed_bands = [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ] if len ( bands ) == 3 and all ( x in allowed_bands for x in bands ): pass else : print ( 'You can only select 3 bands from the following: {} ' . format ( ', ' . join ( allowed_bands ))) return try : col = landsat_timeseries ( roi , start_year , end_year , start_date , end_date ) if vis_params is None : vis_params = {} vis_params [ 'bands' ] = bands vis_params [ 'min' ] = 0 vis_params [ 'max' ] = 4000 vis_params [ 'gamma' ] = [ 1 , 1 , 1 ] video_args = vis_params . copy () video_args [ 'dimensions' ] = dimensions video_args [ 'region' ] = roi video_args [ 'framesPerSecond' ] = frames_per_second video_args [ 'crs' ] = 'EPSG:3857' if 'bands' not in video_args . keys (): video_args [ 'bands' ] = bands if 'min' not in video_args . keys (): video_args [ 'min' ] = 0 if 'max' not in video_args . keys (): video_args [ 'max' ] = 4000 if 'gamma' not in video_args . keys (): video_args [ 'gamma' ] = [ 1 , 1 , 1 ] download_ee_video ( col , video_args , out_gif ) return out_gif except Exception as e : print ( e ) return","title":"landsat_ts_gif()"},{"location":"eefolium/#geemap.eefolium.latlon_from_text","text":"Extracts latlon from text. Parameters: Name Type Description Default location str A pair of latlon coordinates separated by comma or space. required Returns: Type Description bool Returns (lat, lon) if valid. Source code in geemap/eefolium.py def latlon_from_text ( location ): \"\"\"Extracts latlon from text. Args: location (str): A pair of latlon coordinates separated by comma or space. Returns: bool: Returns (lat, lon) if valid. \"\"\" latlon = [] try : if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return None lat , lon = latlon [ 0 ], latlon [ 1 ] if lat >= - 90 and lat <= 90 and lon >= - 180 and lat <= 180 : return lat , lon else : return None except Exception as e : print ( e ) print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return None","title":"latlon_from_text()"},{"location":"eefolium/#geemap.eefolium.legend_from_ee","text":"Extract legend from an Earth Engine class table on the Earth Engine Data Catalog page such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1 Value Color Description 0 1c0dff Water 1 05450a Evergreen needleleaf forest 2 086a10 Evergreen broadleaf forest 3 54a708 Deciduous needleleaf forest 4 78d203 Deciduous broadleaf forest 5 009900 Mixed forest 6 c6b044 Closed shrublands 7 dcd159 Open shrublands 8 dade48 Woody savannas 9 fbff13 Savannas 10 b6ff05 Grasslands 11 27ff87 Permanent wetlands 12 c24f44 Croplands 13 a5a5a5 Urban and built-up 14 ff6d4c Cropland/natural vegetation mosaic 15 69fff8 Snow and ice 16 f9ffa4 Barren or sparsely vegetated 254 ffffff Unclassified Parameters: Name Type Description Default ee_class_table str An Earth Engine class table with triple quotes. required Returns: Type Description dict Returns a legend dictionary that can be used to create a legend. Source code in geemap/eefolium.py def legend_from_ee ( ee_class_table ): \"\"\"Extract legend from an Earth Engine class table on the Earth Engine Data Catalog page such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1 Value Color Description 0 1c0dff Water 1 05450a Evergreen needleleaf forest 2 086a10 Evergreen broadleaf forest 3 54a708 Deciduous needleleaf forest 4 78d203 Deciduous broadleaf forest 5 009900 Mixed forest 6 c6b044 Closed shrublands 7 dcd159 Open shrublands 8 dade48 Woody savannas 9 fbff13 Savannas 10 b6ff05 Grasslands 11 27ff87 Permanent wetlands 12 c24f44 Croplands 13 a5a5a5 Urban and built-up 14 ff6d4c Cropland/natural vegetation mosaic 15 69fff8 Snow and ice 16 f9ffa4 Barren or sparsely vegetated 254 ffffff Unclassified Args: ee_class_table (str): An Earth Engine class table with triple quotes. Returns: dict: Returns a legend dictionary that can be used to create a legend. \"\"\" try : ee_class_table = ee_class_table . strip () lines = ee_class_table . split ( ' \\n ' )[ 1 :] if lines [ 0 ] == 'Value \\t Color \\t Description' : lines = lines [ 1 :] legend_dict = {} for index , line in enumerate ( lines ): items = line . split ( \" \\t \" ) items = [ item . strip () for item in items ] color = items [ 1 ] key = items [ 0 ] + \" \" + items [ 2 ] legend_dict [ key ] = color return legend_dict except Exception as e : print ( e )","title":"legend_from_ee()"},{"location":"eefolium/#geemap.eefolium.minimum_bounding_box","text":"Gets the minimum bounding box for a geojson polygon. Parameters: Name Type Description Default geojson dict A geojson dictionary. required Returns: Type Description tuple Returns a tuple containing the minimum bounding box in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -120)). Source code in geemap/eefolium.py def minimum_bounding_box ( geojson ): \"\"\"Gets the minimum bounding box for a geojson polygon. Args: geojson (dict): A geojson dictionary. Returns: tuple: Returns a tuple containing the minimum bounding box in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -120)). \"\"\" coordinates = [] try : if 'geometry' in geojson . keys (): coordinates = geojson [ 'geometry' ][ 'coordinates' ][ 0 ] else : coordinates = geojson [ 'coordinates' ][ 0 ] lower_left = min ([ x [ 1 ] for x in coordinates ]), min ( [ x [ 0 ] for x in coordinates ]) # (lat, lon) upper_right = max ([ x [ 1 ] for x in coordinates ]), max ([ x [ 0 ] for x in coordinates ]) # (lat, lon) bounds = ( lower_left , upper_right ) return bounds except Exception as e : print ( e ) return","title":"minimum_bounding_box()"},{"location":"eefolium/#geemap.eefolium.naip_timeseries","text":"Creates NAIP annual timeseries Parameters: Name Type Description Default roi object An ee.Geometry representing the region of interest. Defaults to None. None start_year int Starting year for the timeseries. Defaults to2009. 2009 end_year int Ending year for the timeseries. Defaults to 2018. 2018 Returns: Type Description object An ee.ImageCollection representing annual NAIP imagery. Source code in geemap/eefolium.py def naip_timeseries ( roi = None , start_year = 2009 , end_year = 2018 ): \"\"\"Creates NAIP annual timeseries Args: roi (object, optional): An ee.Geometry representing the region of interest. Defaults to None. start_year (int, optional): Starting year for the timeseries. Defaults to2009. end_year (int, optional): Ending year for the timeseries. Defaults to 2018. Returns: object: An ee.ImageCollection representing annual NAIP imagery. \"\"\" ee_initialize () try : def get_annual_NAIP ( year ): try : collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) if roi is not None : collection = collection . filterBounds ( roi ) start_date = ee . Date . fromYMD ( year , 1 , 1 ) end_date = ee . Date . fromYMD ( year , 12 , 31 ) naip = collection . filterDate ( start_date , end_date ) \\ . filter ( ee . Filter . listContains ( \"system:band_names\" , \"N\" )) naip = ee . Image ( ee . ImageCollection ( naip ) . mosaic ()) return naip except Exception as e : print ( e ) years = ee . List . sequence ( start_year , end_year ) collection = years . map ( get_annual_NAIP ) return collection except Exception as e : print ( e )","title":"naip_timeseries()"},{"location":"eefolium/#geemap.eefolium.open_github","text":"Opens the GitHub repository for this package. Parameters: Name Type Description Default subdir str Sub-directory of the repository. Defaults to None. None Source code in geemap/eefolium.py def open_github ( subdir = None ): \"\"\"Opens the GitHub repository for this package. Args: subdir (str, optional): Sub-directory of the repository. Defaults to None. \"\"\" import webbrowser url = 'https://github.com/giswqs/geemap' if subdir == 'source' : url += '/tree/master/geemap/' elif subdir == 'examples' : url += '/tree/master/examples' elif subdir == 'tutorials' : url += '/tree/master/tutorials' webbrowser . open_new_tab ( url )","title":"open_github()"},{"location":"eefolium/#geemap.eefolium.open_image_from_url","text":"Loads an image from the specified URL. Parameters: Name Type Description Default url str URL of the image. required Returns: Type Description object Image object. Source code in geemap/eefolium.py def open_image_from_url ( url ): \"\"\"Loads an image from the specified URL. Args: url (str): URL of the image. Returns: object: Image object. \"\"\" from PIL import Image import requests from io import BytesIO from urllib.parse import urlparse try : # if url.endswith('.gif'): # out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') # if not os.path.exists(out_dir): # os.makedirs(out_dir) # a = urlparse(url) # out_name = os.path.basename(a.path) # out_path = os.path.join(out_dir, out_name) # download_from_url(url, out_name, out_dir, unzip=False) # img = Image.open(out_path) # else: response = requests . get ( url ) img = Image . open ( BytesIO ( response . content )) return img except Exception as e : print ( e )","title":"open_image_from_url()"},{"location":"eefolium/#geemap.eefolium.open_youtube","text":"Opens the YouTube tutorials for geemap. Source code in geemap/eefolium.py def open_youtube (): \"\"\"Opens the YouTube tutorials for geemap. \"\"\" import webbrowser url = 'https://www.youtube.com/playlist?list=PLAxJ4-o7ZoPccOFv1dCwvGI6TYnirRTg3' webbrowser . open_new_tab ( url )","title":"open_youtube()"},{"location":"eefolium/#geemap.eefolium.rgb_to_hex","text":"Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255. Parameters: Name Type Description Default rgb tuple RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255). (255, 255, 255) Returns: Type Description str hex color code Source code in geemap/eefolium.py def rgb_to_hex ( rgb = ( 255 , 255 , 255 )): \"\"\"Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255. Args: rgb (tuple, optional): RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255). Returns: str: hex color code \"\"\" return ' %02x%02x%02x ' % rgb","title":"rgb_to_hex()"},{"location":"eefolium/#geemap.eefolium.search_ee_data","text":"Searches Earth Engine data catalog. Parameters: Name Type Description Default keywords str Keywords to search for can be id, provider, tag and so on required Returns: Type Description list Returns a lit of assets. Source code in geemap/eefolium.py def search_ee_data ( keywords ): \"\"\"Searches Earth Engine data catalog. Args: keywords (str): Keywords to search for can be id, provider, tag and so on Returns: list: Returns a lit of assets. \"\"\" try : cmd = 'geeadd search --keywords \" {} \"' . format ( str ( keywords )) output = os . popen ( cmd ) . read () start_index = output . index ( '[' ) assets = eval ( output [ start_index :]) results = [] for asset in assets : asset_dates = asset [ 'start_date' ] + ' - ' + asset [ 'end_date' ] asset_snippet = asset [ 'ee_id_snippet' ] start_index = asset_snippet . index ( \"'\" ) + 1 end_index = asset_snippet . index ( \"'\" , start_index ) asset_id = asset_snippet [ start_index : end_index ] asset [ 'dates' ] = asset_dates asset [ 'id' ] = asset_id asset [ 'uid' ] = asset_id . replace ( '/' , '_' ) # asset['url'] = 'https://developers.google.com/earth-engine/datasets/catalog/' + asset['uid'] # asset['thumbnail'] = 'https://mw1.google.com/ges/dd/images/{}_sample.png'.format( # asset['uid']) results . append ( asset ) return results except Exception as e : print ( e ) return","title":"search_ee_data()"},{"location":"eefolium/#geemap.eefolium.sentinel2_timeseries","text":"Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Images include both level 1C and level 2A imagery. Parameters: Name Type Description Default roi object Region of interest to create the timelapse. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 2015. 2015 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'. '01-01' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'. '12-31' Returns: Type Description object Returns an ImageCollection containing annual Sentinel 2 images. Source code in geemap/eefolium.py def sentinel2_timeseries ( roi = None , start_year = 2015 , end_year = 2019 , start_date = '01-01' , end_date = '12-31' ): \"\"\"Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Images include both level 1C and level 2A imagery. Args: roi (object, optional): Region of interest to create the timelapse. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 2015. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'. Returns: object: Returns an ImageCollection containing annual Sentinel 2 images. \"\"\" ################################################################################ ################################################################################ # Input and output parameters. import re import datetime ee_initialize () if roi is None : # roi = ee.Geometry.Polygon( # [[[-180, -80], # [-180, 80], # [180, 80], # [180, -80], # [-180, -80]]], None, False) roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return ################################################################################ # Setup vars to get dates. if isinstance ( start_year , int ) and ( start_year >= 2015 ) and ( start_year <= 2020 ): pass else : print ( 'The start year must be an integer >= 2015.' ) return if isinstance ( end_year , int ) and ( end_year >= 2015 ) and ( end_year <= 2020 ): pass else : print ( 'The end year must be an integer <= 2020.' ) return if re . match ( \"[0-9] {2} \\-[0-9] {2} \" , start_date ) and re . match ( \"[0-9] {2} \\-[0-9] {2} \" , end_date ): pass else : print ( 'The start data and end date must be month-day, such as 06-10, 09-20' ) return try : datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) except Exception as e : print ( 'The input dates are invalid.' ) print ( e ) return try : start_test = datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) end_test = datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) if start_test > end_test : raise ValueError ( 'Start date must be prior to end date' ) except Exception as e : print ( e ) return def days_between ( d1 , d2 ): d1 = datetime . datetime . strptime ( d1 , \"%Y-%m- %d \" ) d2 = datetime . datetime . strptime ( d2 , \"%Y-%m- %d \" ) return abs (( d2 - d1 ) . days ) n_days = days_between ( str ( start_year ) + '-' + start_date , str ( start_year ) + '-' + end_date ) start_month = int ( start_date [: 2 ]) start_day = int ( start_date [ 3 : 5 ]) start_date = str ( start_year ) + '-' + start_date end_date = str ( end_year ) + '-' + end_date # Define a collection filter by date, bounds, and quality. def colFilter ( col , aoi ): # , startDate, endDate): return ( col . filterBounds ( aoi )) # Get Sentinel 2 collections, both Level-1C (top of atmophere) and Level-2A (surface reflectance) MSILCcol = ee . ImageCollection ( 'COPERNICUS/S2' ) MSI2Acol = ee . ImageCollection ( 'COPERNICUS/S2_SR' ) # Define a collection filter by date, bounds, and quality. def colFilter ( col , roi , start_date , end_date ): return ( col . filterBounds ( roi ) . filterDate ( start_date , end_date )) # .filter('CLOUD_COVER < 5') # .filter('GEOMETRIC_RMSE_MODEL < 15') # .filter('IMAGE_QUALITY == 9 || IMAGE_QUALITY_OLI == 9')) # Function to get and rename bands of interest from MSI def renameMSI ( img ): return ( img . select ( [ 'B2' , 'B3' , 'B4' , 'B5' , 'B6' , 'B7' , 'B8' , 'B8A' , 'B11' , 'B12' , 'QA60' ], [ 'Blue' , 'Green' , 'Red' , 'Red Edge 1' , 'Red Edge 2' , 'Red Edge 3' , 'NIR' , 'Red Edge 4' , 'SWIR1' , 'SWIR2' , 'QA60' ])) # Add NBR for LandTrendr segmentation. def calcNbr ( img ): return ( img . addBands ( img . normalizedDifference ([ 'NIR' , 'SWIR2' ]) . multiply ( - 10000 ) . rename ( 'NBR' )) . int16 ()) # Define function to mask out clouds and cloud shadows in images. # Use CFmask band included in USGS Landsat SR image product. def fmask ( img ): cloudOpaqueBitMask = 1 << 10 cloudCirrusBitMask = 1 << 11 qa = img . select ( 'QA60' ) mask = qa . bitwiseAnd ( cloudOpaqueBitMask ) . eq ( 0 ) \\ . And ( qa . bitwiseAnd ( cloudCirrusBitMask ) . eq ( 0 )) return ( img . updateMask ( mask )) # Define function to prepare MSI images. def prepMSI ( img ): orig = img img = renameMSI ( img ) img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Get annual median collection. def getAnnualComp ( y ): startDate = ee . Date . fromYMD ( ee . Number ( y ), ee . Number ( start_month ), ee . Number ( start_day )) endDate = startDate . advance ( ee . Number ( n_days ), 'day' ) # Filter collections and prepare them for merging. MSILCcoly = colFilter ( MSILCcol , roi , startDate , endDate ) . map ( prepMSI ) MSI2Acoly = colFilter ( MSI2Acol , roi , startDate , endDate ) . map ( prepMSI ) # Merge the collections. col = MSILCcoly . merge ( MSI2Acoly ) yearImg = col . median () nBands = yearImg . bandNames () . size () yearImg = ee . Image ( ee . Algorithms . If ( nBands , yearImg , dummyImg )) return ( calcNbr ( yearImg ) . set ({ 'year' : y , 'system:time_start' : startDate . millis (), 'nBands' : nBands })) ################################################################################ # Make a dummy image for missing years. bandNames = ee . List ([ 'Blue' , 'Green' , 'Red' , 'Red Edge 1' , 'Red Edge 2' , 'Red Edge 3' , 'NIR' , 'Red Edge 4' , 'SWIR1' , 'SWIR2' , 'QA60' ]) fillerValues = ee . List . repeat ( 0 , bandNames . size ()) dummyImg = ee . Image . constant ( fillerValues ) . rename ( bandNames ) \\ . selfMask () . int16 () ################################################################################ # Get a list of years years = ee . List . sequence ( start_year , end_year ) ################################################################################ # Make list of annual image composites. imgList = years . map ( getAnnualComp ) # Convert image composite list to collection imgCol = ee . ImageCollection . fromImages ( imgList ) imgCol = imgCol . map ( lambda img : img . clip ( roi )) return imgCol","title":"sentinel2_timeseries()"},{"location":"eefolium/#geemap.eefolium.show_image","text":"Shows an image within Jupyter notebook. Parameters: Name Type Description Default img_path str The image file path. required width int Width of the image in pixels. Defaults to None. None height int Height of the image in pixels. Defaults to None. None Source code in geemap/eefolium.py def show_image ( img_path , width = None , height = None ): \"\"\"Shows an image within Jupyter notebook. Args: img_path (str): The image file path. width (int, optional): Width of the image in pixels. Defaults to None. height (int, optional): Height of the image in pixels. Defaults to None. \"\"\" from IPython.display import display try : out = widgets . Output () # layout={'border': '1px solid black'}) # layout={'border': '1px solid black', 'width': str(width + 20) + 'px', 'height': str(height + 10) + 'px'},) out . clear_output ( wait = True ) display ( out ) with out : file = open ( img_path , \"rb\" ) image = file . read () if ( width is None ) and ( height is None ): display ( widgets . Image ( value = image )) elif ( width is not None ) and ( height is not None ): display ( widgets . Image ( value = image , width = width , height = height )) else : print ( 'You need set both width and height.' ) return except Exception as e : print ( e )","title":"show_image()"},{"location":"eefolium/#geemap.eefolium.show_youtube","text":"Displays a YouTube video within Jupyter notebooks. Parameters: Name Type Description Default id str Unique ID of the video. Defaults to 'h0pz3S6Tvx0'. 'h0pz3S6Tvx0' Source code in geemap/eefolium.py def show_youtube ( id = 'h0pz3S6Tvx0' ): \"\"\"Displays a YouTube video within Jupyter notebooks. Args: id (str, optional): Unique ID of the video. Defaults to 'h0pz3S6Tvx0'. \"\"\" from IPython.display import YouTubeVideo , display try : out = widgets . Output ( layout = { 'width' : '815px' }) # layout={'border': '1px solid black', 'width': '815px'}) out . clear_output ( wait = True ) display ( out ) with out : display ( YouTubeVideo ( id , width = 800 , height = 450 )) except Exception as e : print ( e )","title":"show_youtube()"},{"location":"eefolium/#geemap.eefolium.shp_to_ee","text":"Converts a shapefile to Earth Engine objects. Parameters: Name Type Description Default in_shp str File path to a shapefile. required Returns: Type Description object Earth Engine objects representing the shapefile. Source code in geemap/eefolium.py def shp_to_ee ( in_shp ): \"\"\"Converts a shapefile to Earth Engine objects. Args: in_shp (str): File path to a shapefile. Returns: object: Earth Engine objects representing the shapefile. \"\"\" ee_initialize () try : json_data = shp_to_geojson ( in_shp ) ee_object = geojson_to_ee ( json_data ) return ee_object except Exception as e : print ( e )","title":"shp_to_ee()"},{"location":"eefolium/#geemap.eefolium.shp_to_geojson","text":"Converts a shapefile to GeoJSON. Parameters: Name Type Description Default in_shp str File path of the input shapefile. required out_json str File path of the output GeoJSON. Defaults to None. None Returns: Type Description object The json object representing the shapefile. Source code in geemap/eefolium.py def shp_to_geojson ( in_shp , out_json = None ): \"\"\"Converts a shapefile to GeoJSON. Args: in_shp (str): File path of the input shapefile. out_json (str, optional): File path of the output GeoJSON. Defaults to None. Returns: object: The json object representing the shapefile. \"\"\" # check_install('pyshp') ee_initialize () try : import json import shapefile in_shp = os . path . abspath ( in_shp ) if out_json is None : out_json = os . path . splitext ( in_shp )[ 0 ] + \".json\" if os . path . exists ( out_json ): out_json = out_json . replace ( '.json' , '_bk.json' ) elif not os . path . exists ( os . path . dirname ( out_json )): os . makedirs ( os . path . dirname ( out_json )) reader = shapefile . Reader ( in_shp ) fields = reader . fields [ 1 :] field_names = [ field [ 0 ] for field in fields ] buffer = [] for sr in reader . shapeRecords (): atr = dict ( zip ( field_names , sr . record )) geom = sr . shape . __geo_interface__ buffer . append ( dict ( type = \"Feature\" , geometry = geom , properties = atr )) from json import dumps geojson = open ( out_json , \"w\" ) geojson . write ( dumps ({ \"type\" : \"FeatureCollection\" , \"features\" : buffer }, indent = 2 ) + \" \\n \" ) geojson . close () with open ( out_json ) as f : json_data = json . load ( f ) return json_data except Exception as e : print ( e )","title":"shp_to_geojson()"},{"location":"eefolium/#geemap.eefolium.system_fonts","text":"Gets a list of system fonts. # Common font locations: # Linux: /usr/share/fonts/TTF/ # Windows: C:\\Windows\\Fonts # macOS: System > Library > Fonts Parameters: Name Type Description Default show_full_path bool Whether to show the full path of each system font. Defaults to False. False Returns: Type Description list A list of system fonts. Source code in geemap/eefolium.py def system_fonts ( show_full_path = False ): \"\"\"Gets a list of system fonts. # Common font locations: # Linux: /usr/share/fonts/TTF/ # Windows: C:\\Windows\\Fonts # macOS: System > Library > Fonts Args: show_full_path (bool, optional): Whether to show the full path of each system font. Defaults to False. Returns: list: A list of system fonts. \"\"\" try : import matplotlib.font_manager font_list = matplotlib . font_manager . findSystemFonts ( fontpaths = None , fontext = 'ttf' ) font_list . sort () font_names = [ os . path . basename ( f ) for f in font_list ] font_names . sort () if show_full_path : return font_list else : return font_names except Exception as e : print ( e )","title":"system_fonts()"},{"location":"eefolium/#geemap.eefolium.update_package","text":"Updates the geemap package from the geemap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. Source code in geemap/eefolium.py def update_package (): \"\"\"Updates the geemap package from the geemap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. \"\"\" try : download_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) if not os . path . exists ( download_dir ): os . makedirs ( download_dir ) clone_repo ( out_dir = download_dir ) pkg_dir = os . path . join ( download_dir , 'geemap-master' ) work_dir = os . getcwd () os . chdir ( pkg_dir ) cmd = 'pip install .' os . system ( cmd ) os . chdir ( work_dir ) print ( \" \\n Please comment out 'geemap.update_package()' and restart the kernel to take effect: \\n Jupyter menu -> Kernel -> Restart & Clear Output\" ) except Exception as e : print ( e )","title":"update_package()"},{"location":"eefolium/#geemap.eefolium.zonal_statistics","text":"Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Parameters: Name Type Description Default in_value_raster object An ee.Image that contains the values on which to calculate a statistic. required in_zone_vector object An ee.FeatureCollection that defines the zones. required out_file_path str Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz required statistics_type str Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps. 'MEAN' scale float A nominal scale in meters of the projection to work in. Defaults to None. None crs str The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. None tile_scale float A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. 1.0 Source code in geemap/eefolium.py def zonal_statistics ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'MEAN' , scale = None , crs = None , tile_scale = 1.0 , ** kwargs ): \"\"\"Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Args: in_value_raster (object): An ee.Image that contains the values on which to calculate a statistic. in_zone_vector (object): An ee.FeatureCollection that defines the zones. out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz statistics_type (str, optional): Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. \"\"\" if not isinstance ( in_value_raster , ee . Image ): print ( 'The input raster must be an ee.Image.' ) return if not isinstance ( in_zone_vector , ee . FeatureCollection ): print ( 'The input zone data must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' ] filename = os . path . abspath ( out_file_path ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () if not ( filetype in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return # Parameters for histogram # The maximum number of buckets to use when building a histogram; will be rounded up to a power of 2. max_buckets = None # The minimum histogram bucket width, or null to allow any power of 2. min_bucket_width = None # The number of values to accumulate before building the initial histogram. max_raw = None hist_min = 1.0 # The lower (inclusive) bound of the first bucket. hist_max = 100.0 # The upper (exclusive) bound of the last bucket. hist_steps = 10 # The number of buckets to use. if 'max_buckets' in kwargs . keys (): max_buckets = kwargs [ 'max_buckets' ] if 'min_bucket_width' in kwargs . keys (): min_bucket_width = kwargs [ 'min_bucket' ] if 'max_raw' in kwargs . keys (): max_raw = kwargs [ 'max_raw' ] if statistics_type . upper () == 'FIXED_HIST' and ( 'hist_min' in kwargs . keys ()) and ( 'hist_max' in kwargs . keys ()) and ( 'hist_steps' in kwargs . keys ()): hist_min = kwargs [ 'hist_min' ] hist_max = kwargs [ 'hist_max' ] hist_steps = kwargs [ 'hist_steps' ] elif statistics_type . upper () == 'FIXED_HIST' : print ( 'To use fixedHistogram, please provide these three parameters: hist_min, hist_max, and hist_steps.' ) return allowed_statistics = { 'MEAN' : ee . Reducer . mean (), 'MAXIMUM' : ee . Reducer . max (), 'MEDIAN' : ee . Reducer . median (), 'MINIMUM' : ee . Reducer . min (), 'STD' : ee . Reducer . stdDev (), 'MIN_MAX' : ee . Reducer . minMax (), 'SUM' : ee . Reducer . sum (), 'VARIANCE' : ee . Reducer . variance (), 'HIST' : ee . Reducer . histogram ( maxBuckets = max_buckets , minBucketWidth = min_bucket_width , maxRaw = max_raw ), 'FIXED_HIST' : ee . Reducer . fixedHistogram ( hist_min , hist_max , hist_steps ) } if not ( statistics_type . upper () in allowed_statistics . keys ()): print ( 'The statistics type must be one of the following: {} ' . format ( ', ' . join ( list ( allowed_statistics . keys ())))) return if scale is None : scale = in_value_raster . projection () . nominalScale () . multiply ( 10 ) try : print ( 'Computing statistics ...' ) result = in_value_raster . reduceRegions ( collection = in_zone_vector , reducer = allowed_statistics [ statistics_type ], scale = scale , crs = crs , tileScale = tile_scale ) ee_export_vector ( result , filename ) except Exception as e : print ( e )","title":"zonal_statistics()"},{"location":"eefolium/#geemap.eefolium.zonal_statistics_by_group","text":"Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Parameters: Name Type Description Default in_value_raster object An integer Image that contains the values on which to calculate area/percentage. required in_zone_vector object An ee.FeatureCollection that defines the zones. required out_file_path str Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz required statistics_type str Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'. 'SUM' decimal_places int The number of decimal places to use. Defaults to 0. 0 denominator float To covert area units (e.g., from square meters to square kilometers). Defaults to 1.0. 1.0 scale float A nominal scale in meters of the projection to work in. Defaults to None. None crs str The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. None tile_scale float A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. 1.0 Source code in geemap/eefolium.py def zonal_statistics_by_group ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'SUM' , decimal_places = 0 , denominator = 1.0 , scale = None , crs = None , tile_scale = 1.0 ): \"\"\"Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Args: in_value_raster (object): An integer Image that contains the values on which to calculate area/percentage. in_zone_vector (object): An ee.FeatureCollection that defines the zones. out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz statistics_type (str, optional): Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'. decimal_places (int, optional): The number of decimal places to use. Defaults to 0. denominator (float, optional): To covert area units (e.g., from square meters to square kilometers). Defaults to 1.0. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. \"\"\" if not isinstance ( in_value_raster , ee . Image ): print ( 'The input raster must be an ee.Image.' ) return band_count = in_value_raster . bandNames () . size () . getInfo () band_name = '' if band_count == 1 : band_name = in_value_raster . bandNames () . get ( 0 ) else : print ( 'The input image can only have one band.' ) return band_types = in_value_raster . bandTypes () . get ( band_name ) . getInfo () band_type = band_types . get ( 'precision' ) if band_type != 'int' : print ( 'The input image band must be integer type.' ) return if not isinstance ( in_zone_vector , ee . FeatureCollection ): print ( 'The input zone data must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' ] filename = os . path . abspath ( out_file_path ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] if not ( filetype . lower () in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return out_dir = os . path . dirname ( filename ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) allowed_statistics = [ 'SUM' , 'PERCENTAGE' ] if not ( statistics_type . upper () in allowed_statistics ): print ( 'The statistics type can only be one of {} ' . format ( ', ' . join ( allowed_statistics ))) return if scale is None : scale = in_value_raster . projection () . nominalScale () . multiply ( 10 ) try : print ( 'Computing ... ' ) geometry = in_zone_vector . geometry () hist = in_value_raster . reduceRegion ( ee . Reducer . frequencyHistogram ( ), geometry = geometry , bestEffort = True , scale = scale ) class_values = ee . Dictionary ( hist . get ( band_name )) . keys () . map ( lambda v : ee . Number . parse ( v )) . sort () class_names = class_values . map ( lambda c : ee . String ( 'Class_' ) . cat ( ee . Number ( c ) . format ())) class_count = class_values . size () . getInfo () dataset = ee . Image . pixelArea () . divide ( denominator ) . addBands ( in_value_raster ) init_result = dataset . reduceRegions ( ** { 'collection' : in_zone_vector , 'reducer' : ee . Reducer . sum () . group ( ** { 'groupField' : 1 , 'groupName' : 'group' , }), 'scale' : scale }) def build_dict ( input_list ): decimal_format = '%. {} f' . format ( decimal_places ) in_dict = input_list . map ( lambda x : ee . Dictionary () . set ( ee . String ( 'Class_' ) . cat ( ee . Number ( ee . Dictionary ( x ) . get ( 'group' )) . format ()), ee . Number . parse ( ee . Number ( ee . Dictionary ( x ) . get ( 'sum' )) . format ( decimal_format )))) return in_dict def get_keys ( input_list ): return input_list . map ( lambda x : ee . String ( 'Class_' ) . cat ( ee . Number ( ee . Dictionary ( x ) . get ( 'group' )) . format ())) def get_values ( input_list ): decimal_format = '%. {} f' . format ( decimal_places ) return input_list . map ( lambda x : ee . Number . parse ( ee . Number ( ee . Dictionary ( x ) . get ( 'sum' )) . format ( decimal_format ))) def set_attribute ( f ): groups = ee . List ( f . get ( 'groups' )) keys = get_keys ( groups ) values = get_values ( groups ) total_area = ee . List ( values ) . reduce ( ee . Reducer . sum ()) def get_class_values ( x ): cls_value = ee . Algorithms . If ( keys . contains ( x ), values . get ( keys . indexOf ( x )), 0 ) cls_value = ee . Algorithms . If ( ee . String ( statistics_type ) . compareTo ( ee . String ( 'SUM' )), ee . Number ( cls_value ) . divide ( ee . Number ( total_area )), cls_value ) return cls_value full_values = class_names . map ( lambda x : get_class_values ( x )) attr_dict = ee . Dictionary . fromLists ( class_names , full_values ) attr_dict = attr_dict . set ( 'Class_sum' , total_area ) return f . set ( attr_dict ) . set ( 'groups' , None ) final_result = init_result . map ( set_attribute ) ee_export_vector ( final_result , filename ) except Exception as e : print ( e )","title":"zonal_statistics_by_group()"},{"location":"faq/","text":"FAQ How do I report an issue or make a feature request? Please go to https://github.com/giswqs/geemap/issues . How do I cite geemap in publications? Wu, Q., (2020). geemap: A Python package for interactive mapping with Google Earth Engine. The Journal of Open Source Software , 5(51), 2305. https://doi.org/10.21105/joss.02305 Bibtex: @article{wu2020geemap, title={geemap: A Python package for interactive mapping with Google Earth Engine}, author={Wu, Qiusheng}, journal={Journal of Open Source Software}, volume={5}, number={51}, pages={2305}, year={2020} } Why does geemap use two plotting backends: folium and ipyleaflet? A key difference between ipyleaflet and folium is that ipyleaflet is built upon ipywidgets and allows bidirectional communication between the front-end and the backend enabling the use of the map to capture user input, while folium is meant for displaying static data only ( source ). Note that Google Colab currently does not support ipyleaflet ( source ). Therefore, if you are using geemap with Google Colab, you should use import geemap.eefolium as geemap . If you are using geemap with a local Jupyter notebook server, you can use import geemap , which provides more functionalities for capturing user input (e.g., mouse-clicking and moving).","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#how-do-i-report-an-issue-or-make-a-feature-request","text":"Please go to https://github.com/giswqs/geemap/issues .","title":"How do I report an issue or make a feature request?"},{"location":"faq/#how-do-i-cite-geemap-in-publications","text":"Wu, Q., (2020). geemap: A Python package for interactive mapping with Google Earth Engine. The Journal of Open Source Software , 5(51), 2305. https://doi.org/10.21105/joss.02305 Bibtex: @article{wu2020geemap, title={geemap: A Python package for interactive mapping with Google Earth Engine}, author={Wu, Qiusheng}, journal={Journal of Open Source Software}, volume={5}, number={51}, pages={2305}, year={2020} }","title":"How do I cite geemap in publications?"},{"location":"faq/#why-does-geemap-use-two-plotting-backends-folium-and-ipyleaflet","text":"A key difference between ipyleaflet and folium is that ipyleaflet is built upon ipywidgets and allows bidirectional communication between the front-end and the backend enabling the use of the map to capture user input, while folium is meant for displaying static data only ( source ). Note that Google Colab currently does not support ipyleaflet ( source ). Therefore, if you are using geemap with Google Colab, you should use import geemap.eefolium as geemap . If you are using geemap with a local Jupyter notebook server, you can use import geemap , which provides more functionalities for capturing user input (e.g., mouse-clicking and moving).","title":"Why does geemap use two plotting backends: folium and ipyleaflet?"},{"location":"geemap/","text":"geemap module Main module for interactive mapping using Google Earth Engine Python API and ipyleaflet. Keep in mind that Earth Engine functions use both camel case and snake case, such as setOptions(), setCenter(), centerObject(), addLayer(). ipyleaflet functions use snake case, such as add_tile_layer(), add_wms_layer(), add_minimap(). Map The Map class inherits from ipyleaflet.Map. The arguments you can pass to the Map can be found at https://ipyleaflet.readthedocs.io/en/latest/api_reference/map.html. By default, the Map will add Google Maps as the basemap. Set add_google_map = False to use OpenStreetMap as the basemap. Returns: Type Description object ipyleaflet map object. add_basemap ( self , basemap = 'HYBRID' ) Adds a basemap to the map. Parameters: Name Type Description Default basemap str Can be one of string from ee_basemaps. Defaults to 'HYBRID'. 'HYBRID' Source code in geemap/geemap.py def add_basemap ( self , basemap = 'HYBRID' ): \"\"\"Adds a basemap to the map. Args: basemap (str, optional): Can be one of string from ee_basemaps. Defaults to 'HYBRID'. \"\"\" try : self . add_layer ( ee_basemaps [ basemap ]) except Exception as e : print ( e ) print ( 'Basemap can only be one of the following: \\n {} ' . format ( ' \\n ' . join ( ee_basemaps . keys ()))) add_ee_layer ( self , ee_object , vis_params = {}, name = None , shown = True , opacity = 1.0 ) Adds a given EE object to the map as a layer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer N'. None shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/geemap.py def add_ee_layer ( self , ee_object , vis_params = {}, name = None , shown = True , opacity = 1.0 ): \"\"\"Adds a given EE object to the map as a layer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer N'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" image = None if name is None : layer_count = len ( self . layers ) name = 'Layer ' + str ( layer_count + 1 ) if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) tile_layer = ipyleaflet . TileLayer ( url = map_id_dict [ 'tile_fetcher' ] . url_format , attribution = 'Google Earth Engine' , name = name , opacity = opacity , visible = True # visible=shown ) layer = self . find_layer ( name = name ) if layer is not None : existing_object = self . ee_layer_dict [ name ][ 'ee_object' ] if isinstance ( existing_object , ee . Image ) or isinstance ( existing_object , ee . ImageCollection ): self . ee_raster_layers . remove ( existing_object ) self . ee_raster_layer_names . remove ( name ) if self . plot_dropdown_widget is not None : self . plot_dropdown_widget . options = list ( self . ee_raster_layer_names ) self . ee_layers . remove ( existing_object ) self . ee_layer_names . remove ( name ) self . remove_layer ( layer ) self . ee_layers . append ( ee_object ) self . ee_layer_names . append ( name ) self . ee_layer_dict [ name ] = { 'ee_object' : ee_object , 'ee_layer' : tile_layer } self . add_layer ( tile_layer ) if isinstance ( ee_object , ee . Image ) or isinstance ( ee_object , ee . ImageCollection ): self . ee_raster_layers . append ( ee_object ) self . ee_raster_layer_names . append ( name ) if self . plot_dropdown_widget is not None : self . plot_dropdown_widget . options = list ( self . ee_raster_layer_names ) add_landsat_ts_gif ( self , layer_name = 'Timelapse' , roi = None , label = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' , bands = [ 'NIR' , 'Red' , 'Green' ], vis_params = None , dimensions = 768 , frames_per_second = 10 , font_size = 30 , font_color = 'white' , add_progress_bar = True , progress_bar_color = 'white' , progress_bar_height = 5 , out_gif = None , download = False , apply_fmask = True , nd_bands = None , nd_threshold = 0 , nd_palette = [ 'black' , 'blue' ]) Adds a Landsat timelapse to the map. Parameters: Name Type Description Default layer_name str Layer name to show under the layer control. Defaults to 'Timelapse'. 'Timelapse' roi object Region of interest to create the timelapse. Defaults to None. None label str A label to shown on the GIF, such as place name. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 1984. 1984 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. '06-10' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. '09-20' bands list Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. ['NIR', 'Red', 'Green'] vis_params dict Visualization parameters. Defaults to None. None dimensions int a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. 768 frames_per_second int Animation speed. Defaults to 10. 10 font_size int Font size of the animated text and label. Defaults to 30. 30 font_color str Font color of the animated text and label. Defaults to 'black'. 'white' add_progress_bar bool Whether to add a progress bar at the bottom of the GIF. Defaults to True. True progress_bar_color str Color for the progress bar. Defaults to 'white'. 'white' progress_bar_height int Height of the progress bar. Defaults to 5. 5 out_gif str File path to the output animated GIF. Defaults to None. None download bool Whether to download the gif. Defaults to False. False apply_fmask bool Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. True nd_bands list A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1). None nd_threshold float The threshold for extacting pixels from the normalized difference band. 0 nd_palette str The color palette to use for displaying the normalized difference band. ['black', 'blue'] Source code in geemap/geemap.py def add_landsat_ts_gif ( self , layer_name = 'Timelapse' , roi = None , label = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' , bands = [ 'NIR' , 'Red' , 'Green' ], vis_params = None , dimensions = 768 , frames_per_second = 10 , font_size = 30 , font_color = 'white' , add_progress_bar = True , progress_bar_color = 'white' , progress_bar_height = 5 , out_gif = None , download = False , apply_fmask = True , nd_bands = None , nd_threshold = 0 , nd_palette = [ 'black' , 'blue' ]): \"\"\"Adds a Landsat timelapse to the map. Args: layer_name (str, optional): Layer name to show under the layer control. Defaults to 'Timelapse'. roi (object, optional): Region of interest to create the timelapse. Defaults to None. label (str, optional): A label to shown on the GIF, such as place name. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 1984. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. bands (list, optional): Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. vis_params (dict, optional): Visualization parameters. Defaults to None. dimensions (int, optional): a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. frames_per_second (int, optional): Animation speed. Defaults to 10. font_size (int, optional): Font size of the animated text and label. Defaults to 30. font_color (str, optional): Font color of the animated text and label. Defaults to 'black'. add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True. progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'. progress_bar_height (int, optional): Height of the progress bar. Defaults to 5. out_gif (str, optional): File path to the output animated GIF. Defaults to None. download (bool, optional): Whether to download the gif. Defaults to False. apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. nd_bands (list, optional): A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1). nd_threshold (float, optional): The threshold for extacting pixels from the normalized difference band. nd_palette (str, optional): The color palette to use for displaying the normalized difference band. \"\"\" try : if roi is None : if self . draw_last_feature is not None : feature = self . draw_last_feature roi = feature . geometry () else : roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) elif isinstance ( roi , ee . Feature ) or isinstance ( roi , ee . FeatureCollection ): roi = roi . geometry () elif isinstance ( roi , ee . Geometry ): pass else : print ( 'The provided roi is invalid. It must be an ee.Geometry' ) return geojson = ee_to_geojson ( roi ) bounds = minimum_bounding_box ( geojson ) geojson = adjust_longitude ( geojson ) roi = ee . Geometry ( geojson ) in_gif = landsat_ts_gif ( roi = roi , out_gif = out_gif , start_year = start_year , end_year = end_year , start_date = start_date , end_date = end_date , bands = bands , vis_params = vis_params , dimensions = dimensions , frames_per_second = frames_per_second , apply_fmask = apply_fmask , nd_bands = nd_bands , nd_threshold = nd_threshold , nd_palette = nd_palette ) in_nd_gif = in_gif . replace ( '.gif' , '_nd.gif' ) print ( 'Adding animated text to GIF ...' ) add_text_to_gif ( in_gif , in_gif , xy = ( '2%' , '2%' ), text_sequence = start_year , font_size = font_size , font_color = font_color , duration = int ( 1000 / frames_per_second ), add_progress_bar = add_progress_bar , progress_bar_color = progress_bar_color , progress_bar_height = progress_bar_height ) if nd_bands is not None : add_text_to_gif ( in_nd_gif , in_nd_gif , xy = ( '2%' , '2%' ), text_sequence = start_year , font_size = font_size , font_color = font_color , duration = int ( 1000 / frames_per_second ), add_progress_bar = add_progress_bar , progress_bar_color = progress_bar_color , progress_bar_height = progress_bar_height ) if label is not None : add_text_to_gif ( in_gif , in_gif , xy = ( '2%' , '90%' ), text_sequence = label , font_size = font_size , font_color = font_color , duration = int ( 1000 / frames_per_second ), add_progress_bar = add_progress_bar , progress_bar_color = progress_bar_color , progress_bar_height = progress_bar_height ) # if nd_bands is not None: # add_text_to_gif(in_nd_gif, in_nd_gif, xy=('2%', '90%'), text_sequence=label, # font_size=font_size, font_color=font_color, duration=int(1000 / frames_per_second), add_progress_bar=add_progress_bar, progress_bar_color=progress_bar_color, progress_bar_height=progress_bar_height) if is_tool ( 'ffmpeg' ): reduce_gif_size ( in_gif ) if nd_bands is not None : reduce_gif_size ( in_nd_gif ) print ( 'Adding GIF to the map ...' ) self . image_overlay ( url = in_gif , bounds = bounds , name = layer_name ) if nd_bands is not None : self . image_overlay ( url = in_nd_gif , bounds = bounds , name = layer_name + ' ND' ) print ( 'The timelapse has been added to the map.' ) if download : link = create_download_link ( in_gif , title = \"Click here to download the Landsat timelapse: \" ) display ( link ) if nd_bands is not None : link2 = create_download_link ( in_nd_gif , title = \"Click here to download the Normalized Difference Index timelapse: \" ) display ( link2 ) except Exception as e : print ( e ) add_layer_control ( self ) Adds the layer control to the map. Source code in geemap/geemap.py def add_layer_control ( self ): \"\"\"Adds the layer control to the map. \"\"\" pass add_legend ( self , legend_title = 'Legend' , legend_dict = None , legend_keys = None , legend_colors = None , position = 'bottomright' , builtin_legend = None , ** kwargs ) Adds a customized basemap to the map. Parameters: Name Type Description Default legend_title str Title of the legend. Defaults to 'Legend'. 'Legend' legend_dict dict A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None. None legend_keys list A list of legend keys. Defaults to None. None legend_colors list A list of legend colors. Defaults to None. None position str Position of the legend. Defaults to 'bottomright'. 'bottomright' builtin_legend str Name of the builtin legend to add to the map. Defaults to None. None Source code in geemap/geemap.py def add_legend ( self , legend_title = 'Legend' , legend_dict = None , legend_keys = None , legend_colors = None , position = 'bottomright' , builtin_legend = None , ** kwargs ): \"\"\"Adds a customized basemap to the map. Args: legend_title (str, optional): Title of the legend. Defaults to 'Legend'. legend_dict (dict, optional): A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None. legend_keys (list, optional): A list of legend keys. Defaults to None. legend_colors (list, optional): A list of legend colors. Defaults to None. position (str, optional): Position of the legend. Defaults to 'bottomright'. builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None. \"\"\" import pkg_resources from IPython.display import display pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) legend_template = os . path . join ( pkg_dir , 'data/template/legend.html' ) # print(kwargs['min_height']) if 'min_width' not in kwargs . keys (): min_width = None else : min_wdith = kwargs [ 'min_width' ] if 'max_width' not in kwargs . keys (): max_width = None else : max_width = kwargs [ 'max_width' ] if 'min_height' not in kwargs . keys (): min_height = None else : min_height = kwargs [ 'min_height' ] if 'max_height' not in kwargs . keys (): max_height = None else : max_height = kwargs [ 'max_height' ] if 'height' not in kwargs . keys (): height = None else : height = kwargs [ 'height' ] if 'width' not in kwargs . keys (): width = None else : width = kwargs [ 'width' ] if width is None : max_width = '300px' if height is None : max_height = '400px' if not os . path . exists ( legend_template ): print ( 'The legend template does not exist.' ) return if legend_keys is not None : if not isinstance ( legend_keys , list ): print ( 'The legend keys must be a list.' ) return else : legend_keys = [ 'One' , 'Two' , 'Three' , 'Four' , 'ect' ] if legend_colors is not None : if not isinstance ( legend_colors , list ): print ( 'The legend colors must be a list.' ) return elif all ( isinstance ( item , tuple ) for item in legend_colors ): try : legend_colors = [ rgb_to_hex ( x ) for x in legend_colors ] except Exception as e : print ( e ) elif all (( item . startswith ( '#' ) and len ( item ) == 7 ) for item in legend_colors ): pass elif all (( len ( item ) == 6 ) for item in legend_colors ): pass else : print ( 'The legend colors must be a list of tuples.' ) return else : legend_colors = [ '#8DD3C7' , '#FFFFB3' , '#BEBADA' , '#FB8072' , '#80B1D3' ] if len ( legend_keys ) != len ( legend_colors ): print ( 'The legend keys and values must be the same length.' ) return allowed_builtin_legends = builtin_legends . keys () if builtin_legend is not None : # builtin_legend = builtin_legend.upper() if builtin_legend not in allowed_builtin_legends : print ( 'The builtin legend must be one of the following: {} ' . format ( ', ' . join ( allowed_builtin_legends ))) return else : legend_dict = builtin_legends [ builtin_legend ] legend_keys = list ( legend_dict . keys ()) legend_colors = list ( legend_dict . values ()) if legend_dict is not None : if not isinstance ( legend_dict , dict ): print ( 'The legend dict must be a dictionary.' ) return else : legend_keys = list ( legend_dict . keys ()) legend_colors = list ( legend_dict . values ()) if all ( isinstance ( item , tuple ) for item in legend_colors ): try : legend_colors = [ rgb_to_hex ( x ) for x in legend_colors ] except Exception as e : print ( e ) allowed_positions = [ 'topleft' , 'topright' , 'bottomleft' , 'bottomright' ] if position not in allowed_positions : print ( 'The position must be one of the following: {} ' . format ( ', ' . join ( allowed_positions ))) return header = [] content = [] footer = [] with open ( legend_template ) as f : lines = f . readlines () lines [ 3 ] = lines [ 3 ] . replace ( 'Legend' , legend_title ) header = lines [: 6 ] footer = lines [ 11 :] for index , key in enumerate ( legend_keys ): color = legend_colors [ index ] if not color . startswith ( '#' ): color = '#' + color item = \" <li><span style='background: {} ;'></span> {} </li> \\n \" . format ( color , key ) content . append ( item ) legend_html = header + content + footer legend_text = '' . join ( legend_html ) try : if self . legend_control is not None : legend_widget = self . legend_widget legend_widget . close () self . remove_control ( self . legend_control ) legend_output_widget = widgets . Output ( layout = { 'border' : '1px solid black' , 'max_width' : max_width , 'min_width' : min_width , 'max_height' : max_height , 'min_height' : min_height , 'height' : height , 'width' : width , 'overflow' : 'scroll' }) legend_control = WidgetControl ( widget = legend_output_widget , position = position ) legend_widget = widgets . HTML ( value = legend_text ) with legend_output_widget : display ( legend_widget ) self . legend_widget = legend_output_widget self . legend_control = legend_control self . add_control ( legend_control ) except Exception as e : print ( e ) add_maker_cluster ( self , event = 'click' , add_marker = True ) Captures user inputs and add markers to the map. Parameters: Name Type Description Default event str [description]. Defaults to 'click'. 'click' add_marker bool If True, add markers to the map. Defaults to True. True Returns: Type Description object a marker cluster. Source code in geemap/geemap.py def add_maker_cluster ( self , event = 'click' , add_marker = True ): \"\"\"Captures user inputs and add markers to the map. Args: event (str, optional): [description]. Defaults to 'click'. add_marker (bool, optional): If True, add markers to the map. Defaults to True. Returns: object: a marker cluster. \"\"\" coordinates = [] markers = [] marker_cluster = MarkerCluster ( name = \"Marker Cluster\" ) self . last_click = [] self . all_clicks = [] if add_marker : self . add_layer ( marker_cluster ) def handle_interaction ( ** kwargs ): latlon = kwargs . get ( 'coordinates' ) if event == 'click' and kwargs . get ( 'type' ) == 'click' : coordinates . append ( latlon ) self . last_click = latlon self . all_clicks = coordinates if add_marker : markers . append ( Marker ( location = latlon )) marker_cluster . markers = markers elif kwargs . get ( 'type' ) == 'mousemove' : pass # cursor style: https://www.w3schools.com/cssref/pr_class_cursor.asp self . default_style = { 'cursor' : 'crosshair' } self . on_interaction ( handle_interaction ) add_minimap ( self , zoom = 5 , position = 'bottomright' ) Adds a minimap (overview) to the ipyleaflet map. Parameters: Name Type Description Default zoom int Initial map zoom level. Defaults to 5. 5 position str Position of the minimap. Defaults to \"bottomright\". 'bottomright' Source code in geemap/geemap.py def add_minimap ( self , zoom = 5 , position = \"bottomright\" ): \"\"\"Adds a minimap (overview) to the ipyleaflet map. Args: zoom (int, optional): Initial map zoom level. Defaults to 5. position (str, optional): Position of the minimap. Defaults to \"bottomright\". \"\"\" minimap = ipyleaflet . Map ( zoom_control = False , attribution_control = False , zoom = 5 , center = self . center , layers = [ ee_basemaps [ 'ROADMAP' ]] ) minimap . layout . width = '150px' minimap . layout . height = '150px' link (( minimap , 'center' ), ( self , 'center' )) minimap_control = WidgetControl ( widget = minimap , position = position ) self . add_control ( minimap_control ) add_raster ( self , image , bands = None , layer_name = None , colormap = None , x_dim = 'x' , y_dim = 'y' ) Adds a local raster dataset to the map. Parameters: Name Type Description Default image str The image file path. required bands int or list The image bands to use. It can be either a nubmer (e.g., 1) or a list (e.g., [3, 2, 1]). Defaults to None. None layer_name str The layer name to use for the raster. Defaults to None. None colormap str The name of the colormap to use for the raster, such as 'gray' and 'terrain'. More can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html. Defaults to None. None x_dim str The x dimension. Defaults to 'x'. 'x' y_dim str The y dimension. Defaults to 'y'. 'y' Source code in geemap/geemap.py def add_raster ( self , image , bands = None , layer_name = None , colormap = None , x_dim = 'x' , y_dim = 'y' ): \"\"\"Adds a local raster dataset to the map. Args: image (str): The image file path. bands (int or list, optional): The image bands to use. It can be either a nubmer (e.g., 1) or a list (e.g., [3, 2, 1]). Defaults to None. layer_name (str, optional): The layer name to use for the raster. Defaults to None. colormap (str, optional): The name of the colormap to use for the raster, such as 'gray' and 'terrain'. More can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html. Defaults to None. x_dim (str, optional): The x dimension. Defaults to 'x'. y_dim (str, optional): The y dimension. Defaults to 'y'. \"\"\" try : import xarray_leaflet except : # import platform # if platform.system() != \"Windows\": # # install_from_github( # # url='https://github.com/davidbrochart/xarray_leaflet') # check_install('xarray_leaflet') # import xarray_leaflet # else: print ( 'You need to install xarray_leaflet first. See https://github.com/davidbrochart/xarray_leaflet' ) print ( 'Try the following to install xarray_leaflet: \\n\\n conda install -c conda-forge xarray_leaflet' ) return import warnings import numpy as np import rioxarray import xarray as xr import matplotlib.pyplot as plt warnings . simplefilter ( 'ignore' ) if not os . path . exists ( image ): print ( 'The image file does not exist.' ) return if colormap is None : colormap = plt . cm . inferno if layer_name is None : layer_name = 'Layer_' + random_string () if isinstance ( colormap , str ): colormap = plt . cm . get_cmap ( name = colormap ) da = rioxarray . open_rasterio ( image , masked = True ) # print(da.rio.nodata) multi_band = False if len ( da . band ) > 1 : multi_band = True if bands is None : bands = [ 3 , 2 , 1 ] else : bands = 1 if multi_band : da = da . rio . write_nodata ( 0 ) else : da = da . rio . write_nodata ( np . nan ) da = da . sel ( band = bands ) # crs = da.rio.crs # nan = da.attrs['nodatavals'][0] # da = da / da.max() # # if multi_band: # da = xr.where(da == nan, np.nan, da) # da = da.rio.write_nodata(0) # da = da.rio.write_crs(crs) if multi_band : layer = da . leaflet . plot ( self , x_dim = x_dim , y_dim = y_dim , rgb_dim = 'band' ) else : layer = da . leaflet . plot ( self , x_dim = x_dim , y_dim = y_dim , colormap = colormap ) layer . name = layer_name add_tile_layer ( self , url = 'https:// {s} .tile.openstreetmap.org/ {z} / {x} / {y} .png' , name = None , attribution = '' , opacity = 1.0 , shown = True ) Adds a TileLayer to the map. Parameters: Name Type Description Default url str The URL of the tile layer. Defaults to 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'. 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png' name str The layer name to use for the layer. Defaults to None. None attribution str The attribution to use. Defaults to ''. '' opacity float The opacity of the layer. Defaults to 1. 1.0 shown bool A flag indicating whether the layer should be on by default. Defaults to True. True Source code in geemap/geemap.py def add_tile_layer ( self , url = 'https:// {s} .tile.openstreetmap.org/ {z} / {x} / {y} .png' , name = None , attribution = '' , opacity = 1.0 , shown = True ): \"\"\"Adds a TileLayer to the map. Args: url (str, optional): The URL of the tile layer. Defaults to 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'. name (str, optional): The layer name to use for the layer. Defaults to None. attribution (str, optional): The attribution to use. Defaults to ''. opacity (float, optional): The opacity of the layer. Defaults to 1. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. \"\"\" try : tile_layer = ipyleaflet . TileLayer ( url = url , name = name , attribution = attribution , opacity = opacity , visible = True # visible=shown ) self . add_layer ( tile_layer ) except Exception as e : print ( e ) print ( \"Failed to add the specified TileLayer.\" ) add_wms_layer ( self , url , layers , name = None , attribution = '' , format = 'image/jpeg' , transparent = False , opacity = 1.0 , shown = True ) Add a WMS layer to the map. Parameters: Name Type Description Default url str The URL of the WMS web service. required layers str Comma-separated list of WMS layers to show. required name str The layer name to use on the layer control. Defaults to None. None attribution str The attribution of the data layer. Defaults to ''. '' format str WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/jpeg'. 'image/jpeg' transparent bool If True, the WMS service will return images with transparency. Defaults to False. False opacity float The opacity of the layer. Defaults to 1.0. 1.0 shown bool A flag indicating whether the layer should be on by default. Defaults to True. True Source code in geemap/geemap.py def add_wms_layer ( self , url , layers , name = None , attribution = '' , format = 'image/jpeg' , transparent = False , opacity = 1.0 , shown = True ): \"\"\"Add a WMS layer to the map. Args: url (str): The URL of the WMS web service. layers (str): Comma-separated list of WMS layers to show. name (str, optional): The layer name to use on the layer control. Defaults to None. attribution (str, optional): The attribution of the data layer. Defaults to ''. format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/jpeg'. transparent (bool, optional): If True, the WMS service will return images with transparency. Defaults to False. opacity (float, optional): The opacity of the layer. Defaults to 1.0. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. \"\"\" if name is None : name = str ( layers ) try : wms_layer = ipyleaflet . WMSLayer ( url = url , layers = layers , name = name , attribution = attribution , format = format , transparent = transparent , opacity = opacity , visible = True # visible=shown ) self . add_layer ( wms_layer ) except Exception as e : print ( e ) print ( \"Failed to add the specified WMS TileLayer.\" ) addLayer ( self , ee_object , vis_params = {}, name = None , shown = True , opacity = 1.0 ) Adds a given EE object to the map as a layer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer N'. None shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/geemap.py def add_ee_layer ( self , ee_object , vis_params = {}, name = None , shown = True , opacity = 1.0 ): \"\"\"Adds a given EE object to the map as a layer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer N'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" image = None if name is None : layer_count = len ( self . layers ) name = 'Layer ' + str ( layer_count + 1 ) if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) tile_layer = ipyleaflet . TileLayer ( url = map_id_dict [ 'tile_fetcher' ] . url_format , attribution = 'Google Earth Engine' , name = name , opacity = opacity , visible = True # visible=shown ) layer = self . find_layer ( name = name ) if layer is not None : existing_object = self . ee_layer_dict [ name ][ 'ee_object' ] if isinstance ( existing_object , ee . Image ) or isinstance ( existing_object , ee . ImageCollection ): self . ee_raster_layers . remove ( existing_object ) self . ee_raster_layer_names . remove ( name ) if self . plot_dropdown_widget is not None : self . plot_dropdown_widget . options = list ( self . ee_raster_layer_names ) self . ee_layers . remove ( existing_object ) self . ee_layer_names . remove ( name ) self . remove_layer ( layer ) self . ee_layers . append ( ee_object ) self . ee_layer_names . append ( name ) self . ee_layer_dict [ name ] = { 'ee_object' : ee_object , 'ee_layer' : tile_layer } self . add_layer ( tile_layer ) if isinstance ( ee_object , ee . Image ) or isinstance ( ee_object , ee . ImageCollection ): self . ee_raster_layers . append ( ee_object ) self . ee_raster_layer_names . append ( name ) if self . plot_dropdown_widget is not None : self . plot_dropdown_widget . options = list ( self . ee_raster_layer_names ) addLayerControl ( self ) Adds the layer control to the map. Source code in geemap/geemap.py def add_layer_control ( self ): \"\"\"Adds the layer control to the map. \"\"\" pass basemap_demo ( self ) A demo for using geemap basemaps. Source code in geemap/geemap.py def basemap_demo ( self ): \"\"\"A demo for using geemap basemaps. \"\"\" dropdown = widgets . Dropdown ( options = list ( ee_basemaps . keys ()), value = 'HYBRID' , description = 'Basemaps' ) def on_click ( change ): basemap_name = change [ 'new' ] old_basemap = self . layers [ - 1 ] self . substitute_layer ( old_basemap , ee_basemaps [ basemap_name ]) dropdown . observe ( on_click , 'value' ) basemap_control = WidgetControl ( widget = dropdown , position = 'topright' ) self . remove_control ( self . inspector_control ) # self.remove_control(self.layer_control) self . add_control ( basemap_control ) center_object ( self , ee_object , zoom = None ) Centers the map view on a given object. Parameters: Name Type Description Default ee_object Element|Geometry An Earth Engine object to center on - a geometry, image or feature. required zoom int The zoom level, from 1 to 24. Defaults to None. None Source code in geemap/geemap.py def center_object ( self , ee_object , zoom = None ): \"\"\"Centers the map view on a given object. Args: ee_object (Element|Geometry): An Earth Engine object to center on - a geometry, image or feature. zoom (int, optional): The zoom level, from 1 to 24. Defaults to None. \"\"\" lat = 0 lon = 0 bounds = [[ lat , lon ], [ lat , lon ]] if isinstance ( ee_object , ee . geometry . Geometry ): centroid = ee_object . centroid ( 1 ) lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . feature . Feature ): centroid = ee_object . geometry () . centroid ( 1 ) lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . featurecollection . FeatureCollection ): centroid = ee_object . geometry () . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . image . Image ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] else : bounds = [[ 0 , 0 ], [ 0 , 0 ]] lat = bounds [ 0 ][ 0 ] lon = bounds [ 0 ][ 1 ] self . setCenter ( lon , lat , zoom ) centerObject ( self , ee_object , zoom = None ) Centers the map view on a given object. Parameters: Name Type Description Default ee_object Element|Geometry An Earth Engine object to center on - a geometry, image or feature. required zoom int The zoom level, from 1 to 24. Defaults to None. None Source code in geemap/geemap.py def center_object ( self , ee_object , zoom = None ): \"\"\"Centers the map view on a given object. Args: ee_object (Element|Geometry): An Earth Engine object to center on - a geometry, image or feature. zoom (int, optional): The zoom level, from 1 to 24. Defaults to None. \"\"\" lat = 0 lon = 0 bounds = [[ lat , lon ], [ lat , lon ]] if isinstance ( ee_object , ee . geometry . Geometry ): centroid = ee_object . centroid ( 1 ) lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . feature . Feature ): centroid = ee_object . geometry () . centroid ( 1 ) lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . featurecollection . FeatureCollection ): centroid = ee_object . geometry () . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . image . Image ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] else : bounds = [[ 0 , 0 ], [ 0 , 0 ]] lat = bounds [ 0 ][ 0 ] lon = bounds [ 0 ][ 1 ] self . setCenter ( lon , lat , zoom ) extract_values_to_points ( self , filename ) Exports pixel values to a csv file based on user-drawn geometries. Parameters: Name Type Description Default filename str The output file path to the csv file or shapefile. required Source code in geemap/geemap.py def extract_values_to_points ( self , filename ): \"\"\"Exports pixel values to a csv file based on user-drawn geometries. Args: filename (str): The output file path to the csv file or shapefile. \"\"\" import csv filename = os . path . abspath ( filename ) allowed_formats = [ 'csv' , 'shp' ] ext = filename [ - 3 :] if ext not in allowed_formats : print ( 'The output file must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return out_dir = os . path . dirname ( filename ) out_csv = filename [: - 3 ] + 'csv' out_shp = filename [: - 3 ] + 'shp' if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) count = len ( self . chart_points ) out_list = [] if count > 0 : header = [ 'id' , 'longitude' , 'latitude' ] + self . chart_labels out_list . append ( header ) for i in range ( 0 , count ): id = i + 1 line = [ id ] + self . chart_points [ i ] + self . chart_values [ i ] out_list . append ( line ) with open ( out_csv , \"w\" , newline = \"\" ) as f : writer = csv . writer ( f ) writer . writerows ( out_list ) if ext == 'csv' : print ( 'The csv file has been saved to: {} ' . format ( out_csv )) else : csv_to_shp ( out_csv , out_shp ) print ( 'The shapefile has been saved to: {} ' . format ( out_shp )) find_layer ( self , name ) Finds layer by name Parameters: Name Type Description Default name str Name of the layer to find. required Returns: Type Description object ipyleaflet layer object. Source code in geemap/geemap.py def find_layer ( self , name ): \"\"\"Finds layer by name Args: name (str): Name of the layer to find. Returns: object: ipyleaflet layer object. \"\"\" layers = self . layers for layer in layers : if layer . name == name : return layer return None get_scale ( self ) Returns the approximate pixel scale of the current map view, in meters. Returns: Type Description float Map resolution in meters. Source code in geemap/geemap.py def get_scale ( self ): \"\"\"Returns the approximate pixel scale of the current map view, in meters. Returns: float: Map resolution in meters. \"\"\" zoom_level = self . zoom # Reference: https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution resolution = 156543.04 * math . cos ( 0 ) / math . pow ( 2 , zoom_level ) return resolution getScale ( self ) Returns the approximate pixel scale of the current map view, in meters. Returns: Type Description float Map resolution in meters. Source code in geemap/geemap.py def get_scale ( self ): \"\"\"Returns the approximate pixel scale of the current map view, in meters. Returns: float: Map resolution in meters. \"\"\" zoom_level = self . zoom # Reference: https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution resolution = 156543.04 * math . cos ( 0 ) / math . pow ( 2 , zoom_level ) return resolution image_overlay ( self , url , bounds , name ) Overlays an image from the Internet or locally on the map. Parameters: Name Type Description Default url str http URL or local file path to the image. required bounds tuple bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)). required name str name of the layer to show on the layer control. required Source code in geemap/geemap.py def image_overlay ( self , url , bounds , name ): \"\"\"Overlays an image from the Internet or locally on the map. Args: url (str): http URL or local file path to the image. bounds (tuple): bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)). name (str): name of the layer to show on the layer control. \"\"\" from base64 import b64encode from PIL import Image , ImageSequence from io import BytesIO try : if not url . startswith ( 'http' ): if not os . path . exists ( url ): print ( 'The provided file does not exist.' ) return ext = os . path . splitext ( url )[ 1 ][ 1 :] # file extension image = Image . open ( url ) f = BytesIO () if ext . lower () == 'gif' : frames = [] # Loop over each frame in the animated image for frame in ImageSequence . Iterator ( image ): frame = frame . convert ( 'RGBA' ) b = BytesIO () frame . save ( b , format = \"gif\" ) frame = Image . open ( b ) frames . append ( frame ) frames [ 0 ] . save ( f , format = 'GIF' , save_all = True , append_images = frames [ 1 :], loop = 0 ) else : image . save ( f , ext ) data = b64encode ( f . getvalue ()) data = data . decode ( 'ascii' ) url = 'data:image/ {} ;base64,' . format ( ext ) + data img = ipyleaflet . ImageOverlay ( url = url , bounds = bounds , name = name ) self . add_layer ( img ) except Exception as e : print ( e ) layer_opacity ( self , name , value = 1.0 ) Changes layer opacity. Parameters: Name Type Description Default name str The name of the layer to change opacity. required value float The opacity value to set. Defaults to 1.0. 1.0 Source code in geemap/geemap.py def layer_opacity ( self , name , value = 1.0 ): \"\"\"Changes layer opacity. Args: name (str): The name of the layer to change opacity. value (float, optional): The opacity value to set. Defaults to 1.0. \"\"\" layer = self . find_layer ( name ) try : layer . opacity = value # layer.interact(opacity=(0, 1, 0.1)) # to change layer opacity interactively except Exception as e : print ( e ) marker_cluster ( self ) Adds a marker cluster to the map and returns a list of ee.Feature, which can be accessed using Map.ee_marker_cluster. Returns: Type Description object a list of ee.Feature Source code in geemap/geemap.py def marker_cluster ( self ): \"\"\"Adds a marker cluster to the map and returns a list of ee.Feature, which can be accessed using Map.ee_marker_cluster. Returns: object: a list of ee.Feature \"\"\" coordinates = [] markers = [] marker_cluster = MarkerCluster ( name = \"Marker Cluster\" ) self . last_click = [] self . all_clicks = [] self . ee_markers = [] self . add_layer ( marker_cluster ) def handle_interaction ( ** kwargs ): latlon = kwargs . get ( 'coordinates' ) if kwargs . get ( 'type' ) == 'click' : coordinates . append ( latlon ) geom = ee . Geometry . Point ( latlon [ 1 ], latlon [ 0 ]) feature = ee . Feature ( geom ) self . ee_markers . append ( feature ) self . last_click = latlon self . all_clicks = coordinates markers . append ( Marker ( location = latlon )) marker_cluster . markers = markers elif kwargs . get ( 'type' ) == 'mousemove' : pass # cursor style: https://www.w3schools.com/cssref/pr_class_cursor.asp self . default_style = { 'cursor' : 'crosshair' } self . on_interaction ( handle_interaction ) plot ( self , x , y , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ) Creates a plot based on x-array and y-array data. Parameters: Name Type Description Default x numpy.ndarray or list The x-coordinates of the plotted line. required y numpy.ndarray or list The y-coordinates of the plotted line. required plot_type str The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. None overlay bool Whether to overlay plotted lines on the figure. Defaults to False. False position str Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. 'bottomright' min_width int Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_width int Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. None min_height int Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_height int Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. None Source code in geemap/geemap.py def plot ( self , x , y , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ): \"\"\"Creates a plot based on x-array and y-array data. Args: x (numpy.ndarray or list): The x-coordinates of the plotted line. y (numpy.ndarray or list): The y-coordinates of the plotted line. plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False. position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. \"\"\" if self . plot_widget is not None : plot_widget = self . plot_widget else : plot_widget = widgets . Output ( layout = { 'border' : '1px solid black' }) plot_control = WidgetControl ( widget = plot_widget , position = position , min_width = min_width , max_width = max_width , min_height = min_height , max_height = max_height ) self . plot_widget = plot_widget self . plot_control = plot_control self . add_control ( plot_control ) if max_width is None : max_width = 500 if max_height is None : max_height = 300 if ( plot_type is None ) and ( 'markers' not in kwargs . keys ()): kwargs [ 'markers' ] = 'circle' with plot_widget : try : fig = plt . figure ( 1 , ** kwargs ) if max_width is not None : fig . layout . width = str ( max_width ) + 'px' if max_height is not None : fig . layout . height = str ( max_height ) + 'px' plot_widget . clear_output ( wait = True ) if not overlay : plt . clear () if plot_type is None : if 'marker' not in kwargs . keys (): kwargs [ 'marker' ] = 'circle' plt . plot ( x , y , ** kwargs ) elif plot_type == 'bar' : plt . bar ( x , y , ** kwargs ) elif plot_type == 'scatter' : plt . scatter ( x , y , ** kwargs ) elif plot_type == 'hist' : plt . hist ( y , ** kwargs ) plt . show () except Exception as e : print ( e ) print ( \"Failed to create plot.\" ) plot_demo ( self , iterations = 20 , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ) A demo of interactive plotting using random pixel coordinates. Parameters: Name Type Description Default iterations int How many iterations to run for the demo. Defaults to 20. 20 plot_type str The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. None overlay bool Whether to overlay plotted lines on the figure. Defaults to False. False position str Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. 'bottomright' min_width int Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_width int Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. None min_height int Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_height int Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. None Source code in geemap/geemap.py def plot_demo ( self , iterations = 20 , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ): \"\"\"A demo of interactive plotting using random pixel coordinates. Args: iterations (int, optional): How many iterations to run for the demo. Defaults to 20. plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False. position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. \"\"\" import numpy as np import time if self . random_marker is not None : self . remove_layer ( self . random_marker ) image = ee . Image ( 'LE7_TOA_5YEAR/1999_2003' ) . select ([ 0 , 1 , 2 , 3 , 4 , 6 ]) self . addLayer ( image , { 'bands' : [ 'B4' , 'B3' , 'B2' ], 'gamma' : 1.4 }, \"LE7_TOA_5YEAR/1999_2003\" ) self . setCenter ( - 50.078877 , 25.190030 , 3 ) band_names = image . bandNames () . getInfo () band_count = len ( band_names ) latitudes = np . random . uniform ( 30 , 48 , size = iterations ) longitudes = np . random . uniform ( - 121 , - 76 , size = iterations ) marker = Marker ( location = ( 0 , 0 )) self . random_marker = marker self . add_layer ( marker ) for i in range ( iterations ): try : coordinate = ee . Geometry . Point ([ longitudes [ i ], latitudes [ i ]]) dict_values = image . sample ( coordinate ) . first () . toDictionary () . getInfo () band_values = list ( dict_values . values ()) title = ' {} / {} : Spectral signature at ( {} , {} )' . format ( i + 1 , iterations , round ( latitudes [ i ], 2 ), round ( longitudes [ i ], 2 )) marker . location = ( latitudes [ i ], longitudes [ i ]) self . plot ( band_names , band_values , plot_type = plot_type , overlay = overlay , min_width = min_width , max_width = max_width , min_height = min_height , max_height = max_height , title = title , ** kwargs ) time . sleep ( 0.3 ) except Exception as e : print ( e ) plot_raster ( self , ee_object = None , sample_scale = None , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ) Interactive plotting of Earth Engine data by clicking on the map. Parameters: Name Type Description Default ee_object object The ee.Image or ee.ImageCollection to sample. Defaults to None. None sample_scale float A nominal scale in meters of the projection to sample in. Defaults to None. None plot_type str The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. None overlay bool Whether to overlay plotted lines on the figure. Defaults to False. False position str Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. 'bottomright' min_width int Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_width int Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. None min_height int Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_height int Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. None Source code in geemap/geemap.py def plot_raster ( self , ee_object = None , sample_scale = None , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ): \"\"\"Interactive plotting of Earth Engine data by clicking on the map. Args: ee_object (object, optional): The ee.Image or ee.ImageCollection to sample. Defaults to None. sample_scale (float, optional): A nominal scale in meters of the projection to sample in. Defaults to None. plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False. position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. \"\"\" if self . plot_control is not None : del self . plot_widget self . remove_control ( self . plot_control ) if self . random_marker is not None : self . remove_layer ( self . random_marker ) plot_widget = widgets . Output ( layout = { 'border' : '1px solid black' }) plot_control = WidgetControl ( widget = plot_widget , position = position , min_width = min_width , max_width = max_width , min_height = min_height , max_height = max_height ) self . plot_widget = plot_widget self . plot_control = plot_control self . add_control ( plot_control ) self . default_style = { 'cursor' : 'crosshair' } msg = \"The plot function can only be used on ee.Image or ee.ImageCollection with more than one band.\" if ( ee_object is None ) and len ( self . ee_raster_layers ) > 0 : ee_object = self . ee_raster_layers [ - 1 ] if isinstance ( ee_object , ee . ImageCollection ): ee_object = ee_object . mosaic () elif isinstance ( ee_object , ee . ImageCollection ): ee_object = ee_object . mosaic () elif not isinstance ( ee_object , ee . Image ): print ( msg ) return if sample_scale is None : sample_scale = self . getScale () if max_width is None : max_width = 500 band_names = ee_object . bandNames () . getInfo () coordinates = [] markers = [] marker_cluster = MarkerCluster ( name = \"Marker Cluster\" ) self . last_click = [] self . all_clicks = [] self . add_layer ( marker_cluster ) def handle_interaction ( ** kwargs2 ): latlon = kwargs2 . get ( 'coordinates' ) if kwargs2 . get ( 'type' ) == 'click' : try : coordinates . append ( latlon ) self . last_click = latlon self . all_clicks = coordinates markers . append ( Marker ( location = latlon )) marker_cluster . markers = markers self . default_style = { 'cursor' : 'wait' } xy = ee . Geometry . Point ( latlon [:: - 1 ]) dict_values = ee_object . sample ( xy , scale = sample_scale ) . first () . toDictionary () . getInfo () band_values = list ( dict_values . values ()) self . plot ( band_names , band_values , plot_type = plot_type , overlay = overlay , min_width = min_width , max_width = max_width , min_height = min_height , max_height = max_height , ** kwargs ) self . default_style = { 'cursor' : 'crosshair' } except Exception as e : if self . plot_widget is not None : with self . plot_widget : self . plot_widget . clear_output () print ( \"No data for the clicked location.\" ) else : print ( e ) self . default_style = { 'cursor' : 'crosshair' } self . on_interaction ( handle_interaction ) remove_drawn_features ( self ) Removes user-drawn geometries from the map Source code in geemap/geemap.py def remove_drawn_features ( self ): \"\"\"Removes user-drawn geometries from the map \"\"\" if self . draw_layer is not None : self . remove_layer ( self . draw_layer ) self . draw_count = 0 self . draw_features = [] self . draw_last_feature = None self . draw_layer = None self . draw_last_json = None self . draw_last_bounds = None self . user_roi = None self . user_rois = None self . chart_values = [] self . chart_points = [] self . chart_labels = None set_center ( self , lon , lat , zoom = None ) Centers the map view at a given coordinates with the given zoom level. Parameters: Name Type Description Default lon float The longitude of the center, in degrees. required lat float The latitude of the center, in degrees. required zoom int The zoom level, from 1 to 24. Defaults to None. None Source code in geemap/geemap.py def set_center ( self , lon , lat , zoom = None ): \"\"\"Centers the map view at a given coordinates with the given zoom level. Args: lon (float): The longitude of the center, in degrees. lat (float): The latitude of the center, in degrees. zoom (int, optional): The zoom level, from 1 to 24. Defaults to None. \"\"\" self . center = ( lat , lon ) if zoom is not None : self . zoom = zoom set_control_visibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ) Sets the visibility of the controls on the map. Parameters: Name Type Description Default layerControl bool Whether to show the control that allows the user to toggle layers on/off. Defaults to True. True fullscreenControl bool Whether to show the control that allows the user to make the map full-screen. Defaults to True. True latLngPopup bool Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. True Source code in geemap/geemap.py def set_control_visibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ): \"\"\"Sets the visibility of the controls on the map. Args: layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True. fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True. latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. \"\"\" pass set_options ( self , mapTypeId = 'HYBRID' , styles = None , types = None ) Adds Google basemap and controls to the ipyleaflet map. Parameters: Name Type Description Default mapTypeId str A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. 'HYBRID' styles object A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. None types list A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. None Source code in geemap/geemap.py def set_options ( self , mapTypeId = 'HYBRID' , styles = None , types = None ): \"\"\"Adds Google basemap and controls to the ipyleaflet map. Args: mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. styles (object, optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. types (list, optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. \"\"\" self . clear_layers () self . clear_controls () self . scroll_wheel_zoom = True self . add_control ( ZoomControl ( position = 'topleft' )) self . add_control ( LayersControl ( position = 'topright' )) self . add_control ( ScaleControl ( position = 'bottomleft' )) self . add_control ( FullScreenControl ()) self . add_control ( DrawControl ()) measure = MeasureControl ( position = 'bottomleft' , active_color = 'orange' , primary_length_unit = 'kilometers' ) self . add_control ( measure ) try : self . add_layer ( ee_basemaps [ mapTypeId ]) except Exception as e : print ( e ) print ( 'Google basemaps can only be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\".' ) set_plot_options ( self , add_marker_cluster = False , sample_scale = None , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ) Sets plotting options. Parameters: Name Type Description Default add_marker_cluster bool Whether to add a marker cluster. Defaults to False. False sample_scale float A nominal scale in meters of the projection to sample in . Defaults to None. None plot_type str The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. None overlay bool Whether to overlay plotted lines on the figure. Defaults to False. False position str Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. 'bottomright' min_width int Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_width int Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. None min_height int Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_height int Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. None Source code in geemap/geemap.py def set_plot_options ( self , add_marker_cluster = False , sample_scale = None , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ): \"\"\"Sets plotting options. Args: add_marker_cluster (bool, optional): Whether to add a marker cluster. Defaults to False. sample_scale (float, optional): A nominal scale in meters of the projection to sample in . Defaults to None. plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False. position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. \"\"\" plot_options_dict = {} plot_options_dict [ 'add_marker_cluster' ] = add_marker_cluster plot_options_dict [ 'sample_scale' ] = sample_scale plot_options_dict [ 'plot_type' ] = plot_type plot_options_dict [ 'overlay' ] = overlay plot_options_dict [ 'position' ] = position plot_options_dict [ 'min_width' ] = min_width plot_options_dict [ 'max_width' ] = max_width plot_options_dict [ 'min_height' ] = min_height plot_options_dict [ 'max_height' ] = max_height for key in kwargs . keys (): plot_options_dict [ key ] = kwargs [ key ] self . plot_options = plot_options_dict if add_marker_cluster and ( self . plot_marker_cluster not in self . layers ): self . add_layer ( self . plot_marker_cluster ) setCenter ( self , lon , lat , zoom = None ) Centers the map view at a given coordinates with the given zoom level. Parameters: Name Type Description Default lon float The longitude of the center, in degrees. required lat float The latitude of the center, in degrees. required zoom int The zoom level, from 1 to 24. Defaults to None. None Source code in geemap/geemap.py def set_center ( self , lon , lat , zoom = None ): \"\"\"Centers the map view at a given coordinates with the given zoom level. Args: lon (float): The longitude of the center, in degrees. lat (float): The latitude of the center, in degrees. zoom (int, optional): The zoom level, from 1 to 24. Defaults to None. \"\"\" self . center = ( lat , lon ) if zoom is not None : self . zoom = zoom setControlVisibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ) Sets the visibility of the controls on the map. Parameters: Name Type Description Default layerControl bool Whether to show the control that allows the user to toggle layers on/off. Defaults to True. True fullscreenControl bool Whether to show the control that allows the user to make the map full-screen. Defaults to True. True latLngPopup bool Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. True Source code in geemap/geemap.py def set_control_visibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ): \"\"\"Sets the visibility of the controls on the map. Args: layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True. fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True. latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. \"\"\" pass setOptions ( self , mapTypeId = 'HYBRID' , styles = None , types = None ) Adds Google basemap and controls to the ipyleaflet map. Parameters: Name Type Description Default mapTypeId str A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. 'HYBRID' styles object A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. None types list A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. None Source code in geemap/geemap.py def set_options ( self , mapTypeId = 'HYBRID' , styles = None , types = None ): \"\"\"Adds Google basemap and controls to the ipyleaflet map. Args: mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. styles (object, optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. types (list, optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. \"\"\" self . clear_layers () self . clear_controls () self . scroll_wheel_zoom = True self . add_control ( ZoomControl ( position = 'topleft' )) self . add_control ( LayersControl ( position = 'topright' )) self . add_control ( ScaleControl ( position = 'bottomleft' )) self . add_control ( FullScreenControl ()) self . add_control ( DrawControl ()) measure = MeasureControl ( position = 'bottomleft' , active_color = 'orange' , primary_length_unit = 'kilometers' ) self . add_control ( measure ) try : self . add_layer ( ee_basemaps [ mapTypeId ]) except Exception as e : print ( e ) print ( 'Google basemaps can only be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\".' ) split_map ( self , left_layer = 'HYBRID' , right_layer = 'ESRI' ) Adds split map. Parameters: Name Type Description Default left_layer str The layer tile layer. Defaults to 'HYBRID'. 'HYBRID' right_layer str The right tile layer. Defaults to 'ESRI'. 'ESRI' Source code in geemap/geemap.py def split_map ( self , left_layer = 'HYBRID' , right_layer = 'ESRI' ): \"\"\"Adds split map. Args: left_layer (str, optional): The layer tile layer. Defaults to 'HYBRID'. right_layer (str, optional): The right tile layer. Defaults to 'ESRI'. \"\"\" try : self . remove_control ( self . layer_control ) self . remove_control ( self . inspector_control ) if left_layer in ee_basemaps . keys (): left_layer = ee_basemaps [ left_layer ] if right_layer in ee_basemaps . keys (): right_layer = ee_basemaps [ right_layer ] control = ipyleaflet . SplitMapControl ( left_layer = left_layer , right_layer = right_layer ) self . add_control ( control ) except Exception as e : print ( e ) print ( 'The provided layers are invalid!' ) to_html ( self , outfile , title = 'My Map' , width = '100%' , height = '880px' ) Saves the map as a HTML file. Parameters: Name Type Description Default outfile str The output file path to the HTML file. required title str The title of the HTML file. Defaults to 'My Map'. 'My Map' width str The width of the map in pixels or percentage. Defaults to '100%'. '100%' height str The height of the map in pixels. Defaults to '880px'. '880px' Source code in geemap/geemap.py def to_html ( self , outfile , title = 'My Map' , width = '100%' , height = '880px' ): \"\"\"Saves the map as a HTML file. Args: outfile (str): The output file path to the HTML file. title (str, optional): The title of the HTML file. Defaults to 'My Map'. width (str, optional): The width of the map in pixels or percentage. Defaults to '100%'. height (str, optional): The height of the map in pixels. Defaults to '880px'. \"\"\" try : if not outfile . endswith ( '.html' ): print ( 'The output file must end with .html' ) return out_dir = os . path . dirname ( outfile ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) before_width = self . layout . width before_height = self . layout . height if not isinstance ( width , str ): print ( \"width must be a string.\" ) return elif width . endswith ( 'px' ) or width . endswith ( '%' ): pass else : print ( 'width must end with px or %' ) return if not isinstance ( height , str ): print ( \"height must be a string.\" ) return elif not height . endswith ( 'px' ): print ( 'height must end with px' ) return self . layout . width = width self . layout . height = height self . save ( outfile , title = title ) self . layout . width = before_width self . layout . height = before_height except Exception as e : print ( e ) to_image ( self , outfile = None , monitor = 1 ) Saves the map as a PNG or JPG image. Parameters: Name Type Description Default outfile str The output file path to the image. Defaults to None. None monitor int The monitor to take the screenshot. Defaults to 1. 1 Source code in geemap/geemap.py def to_image ( self , outfile = None , monitor = 1 ): \"\"\"Saves the map as a PNG or JPG image. Args: outfile (str, optional): The output file path to the image. Defaults to None. monitor (int, optional): The monitor to take the screenshot. Defaults to 1. \"\"\" if outfile is None : outfile = os . path . join ( os . getcwd (), 'my_map.png' ) if outfile . endswith ( '.png' ) or outfile . endswith ( '.jpg' ): pass else : print ( 'The output file must be a PNG or JPG image.' ) return work_dir = os . path . dirname ( outfile ) if not os . path . exists ( work_dir ): os . makedirs ( work_dir ) screenshot = screen_capture ( outfile , monitor ) self . screenshot = screenshot toolbar_reset ( self ) Reset the toolbar so that no tool is selected. Source code in geemap/geemap.py def toolbar_reset ( self ): \"\"\"Reset the toolbar so that no tool is selected. \"\"\" toolbar_grid = self . toolbar for tool in toolbar_grid . children : tool . value = False ts_inspector ( self , left_ts , right_ts , left_names , right_names , left_vis = {}, right_vis = {}) Creates a split-panel map for inspecting timeseries images. Parameters: Name Type Description Default left_ts object An ee.ImageCollection to show on the left panel. required right_ts object An ee.ImageCollection to show on the right panel. required left_names list A list of names to show under the left dropdown. required right_names list A list of names to show under the right dropdown. required left_vis dict Visualization parameters for the left layer. Defaults to {}. {} right_vis dict Visualization parameters for the right layer. Defaults to {}. {} Source code in geemap/geemap.py def ts_inspector ( self , left_ts , right_ts , left_names , right_names , left_vis = {}, right_vis = {}): \"\"\"Creates a split-panel map for inspecting timeseries images. Args: left_ts (object): An ee.ImageCollection to show on the left panel. right_ts (object): An ee.ImageCollection to show on the right panel. left_names (list): A list of names to show under the left dropdown. right_names (list): A list of names to show under the right dropdown. left_vis (dict, optional): Visualization parameters for the left layer. Defaults to {}. right_vis (dict, optional): Visualization parameters for the right layer. Defaults to {}. \"\"\" left_count = int ( left_ts . size () . getInfo ()) right_count = int ( right_ts . size () . getInfo ()) if left_count != len ( left_names ): print ( 'The number of images in left_ts must match the number of layer names in left_names.' ) return if right_count != len ( right_names ): print ( 'The number of images in right_ts must match the number of layer names in right_names.' ) return left_layer = TileLayer ( url = 'https://mt1.google.com/vt/lyrs=m&x= {x} &y= {y} &z= {z} ' , attribution = 'Google' , name = 'Google Maps' ) right_layer = TileLayer ( url = 'https://mt1.google.com/vt/lyrs=m&x= {x} &y= {y} &z= {z} ' , attribution = 'Google' , name = 'Google Maps' ) self . clear_controls () left_dropdown = widgets . Dropdown ( options = left_names , value = None ) right_dropdown = widgets . Dropdown ( options = right_names , value = None ) left_dropdown . layout . max_width = '130px' right_dropdown . layout . max_width = '130px' left_control = WidgetControl ( widget = left_dropdown , position = 'topleft' ) right_control = WidgetControl ( widget = right_dropdown , position = 'topright' ) self . add_control ( control = left_control ) self . add_control ( control = right_control ) self . add_control ( ZoomControl ( position = 'topleft' )) self . add_control ( ScaleControl ( position = 'bottomleft' )) self . add_control ( FullScreenControl ()) def left_dropdown_change ( change ): left_dropdown_index = left_dropdown . index if left_dropdown_index is not None and left_dropdown_index >= 0 : try : if isinstance ( left_ts , ee . ImageCollection ): left_image = left_ts . toList ( left_ts . size ()) . get ( left_dropdown_index ) elif isinstance ( left_ts , ee . List ): left_image = left_ts . get ( left_dropdown_index ) else : print ( 'The left_ts argument must be an ImageCollection.' ) return if isinstance ( left_image , ee . ImageCollection ): left_image = ee . Image ( left_image . mosaic ()) elif isinstance ( left_image , ee . Image ): pass else : left_image = ee . Image ( left_image ) left_image = ee_tile_layer ( left_image , left_vis , left_names [ left_dropdown_index ]) left_layer . url = left_image . url except Exception as e : print ( e ) return left_dropdown . observe ( left_dropdown_change , names = 'value' ) def right_dropdown_change ( change ): right_dropdown_index = right_dropdown . index if right_dropdown_index is not None and right_dropdown_index >= 0 : try : if isinstance ( right_ts , ee . ImageCollection ): right_image = right_ts . toList ( left_ts . size ()) . get ( right_dropdown_index ) elif isinstance ( right_ts , ee . List ): right_image = right_ts . get ( right_dropdown_index ) else : print ( 'The left_ts argument must be an ImageCollection.' ) return if isinstance ( right_image , ee . ImageCollection ): right_image = ee . Image ( right_image . mosaic ()) elif isinstance ( right_image , ee . Image ): pass else : right_image = ee . Image ( right_image ) right_image = ee_tile_layer ( right_image , right_vis , right_names [ right_dropdown_index ]) right_layer . url = right_image . url except Exception as e : print ( e ) return right_dropdown . observe ( right_dropdown_change , names = 'value' ) try : split_control = ipyleaflet . SplitMapControl ( left_layer = left_layer , right_layer = right_layer ) self . add_control ( split_control ) except Exception as e : print ( e ) video_overlay ( self , url , bounds , name ) Overlays a video from the Internet on the map. Parameters: Name Type Description Default url str http URL of the video, such as \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\" required bounds tuple bounding box of the video in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)). required name str name of the layer to show on the layer control. required Source code in geemap/geemap.py def video_overlay ( self , url , bounds , name ): \"\"\"Overlays a video from the Internet on the map. Args: url (str): http URL of the video, such as \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\" bounds (tuple): bounding box of the video in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)). name (str): name of the layer to show on the layer control. \"\"\" try : video = ipyleaflet . VideoOverlay ( url = url , bounds = bounds , name = name ) self . add_layer ( video ) except Exception as e : print ( e ) add_image_to_gif ( in_gif , out_gif , in_image , xy = None , image_size = ( 80 , 80 ), circle_mask = False ) Adds an image logo to a GIF image. Parameters: Name Type Description Default in_gif str Input file path to the GIF image. required out_gif str Output file path to the GIF image. required in_image str Input file path to the image. required xy tuple Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. None image_size tuple Resize image. Defaults to (80, 80). (80, 80) circle_mask bool Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False. False Source code in geemap/geemap.py def add_image_to_gif ( in_gif , out_gif , in_image , xy = None , image_size = ( 80 , 80 ), circle_mask = False ): \"\"\"Adds an image logo to a GIF image. Args: in_gif (str): Input file path to the GIF image. out_gif (str): Output file path to the GIF image. in_image (str): Input file path to the image. xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. image_size (tuple, optional): Resize image. Defaults to (80, 80). circle_mask (bool, optional): Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False. \"\"\" import io import warnings from PIL import Image , ImageDraw , ImageSequence , ImageFilter warnings . simplefilter ( 'ignore' ) in_gif = os . path . abspath ( in_gif ) is_url = False if in_image . startswith ( 'http' ): is_url = True if not os . path . exists ( in_gif ): print ( 'The input gif file does not exist.' ) return if ( not is_url ) and ( not os . path . exists ( in_image )): print ( 'The provided logo file does not exist.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) try : image = Image . open ( in_gif ) except Exception as e : print ( 'An error occurred while opening the image.' ) print ( e ) return try : if in_image . startswith ( 'http' ): logo_raw_image = open_image_from_url ( in_image ) else : in_image = os . path . abspath ( in_image ) logo_raw_image = Image . open ( in_image ) except Exception as e : print ( e ) logo_raw_size = logo_raw_image . size image_size = min ( logo_raw_size [ 0 ], image_size [ 0 ]), min ( logo_raw_size [ 1 ], image_size [ 1 ]) logo_image = logo_raw_image . convert ( 'RGBA' ) logo_image . thumbnail ( image_size , Image . ANTIALIAS ) W , H = image . size mask_im = None if circle_mask : mask_im = Image . new ( \"L\" , image_size , 0 ) draw = ImageDraw . Draw ( mask_im ) draw . ellipse (( 0 , 0 , image_size [ 0 ], image_size [ 1 ]), fill = 255 ) if has_transparency ( logo_raw_image ): mask_im = logo_image . copy () if xy is None : # default logo location is 5% width and 5% height of the image. xy = ( int ( 0.05 * W ), int ( 0.05 * H )) elif ( xy is not None ) and ( not isinstance ( xy , tuple )) and ( len ( xy ) == 2 ): print ( \"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\" ) return elif all ( isinstance ( item , int ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( x > 0 ) and ( x < W ) and ( y > 0 ) and ( y < H ): pass else : print ( 'xy is out of bounds. x must be within [0, {} ], and y must be within [0, {} ]' . format ( W , H )) return elif all ( isinstance ( item , str ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( '%' in x ) and ( '%' in y ): try : x = int ( float ( x . replace ( '%' , '' )) / 100.0 * W ) y = int ( float ( y . replace ( '%' , '' )) / 100.0 * H ) xy = ( x , y ) except Exception as e : print ( \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\" ) return else : print ( \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\" ) return try : frames = [] for index , frame in enumerate ( ImageSequence . Iterator ( image )): frame = frame . convert ( 'RGBA' ) frame . paste ( logo_image , xy , mask_im ) b = io . BytesIO () frame . save ( b , format = \"GIF\" ) frame = Image . open ( b ) frames . append ( frame ) frames [ 0 ] . save ( out_gif , save_all = True , append_images = frames [ 1 :]) except Exception as e : print ( e ) add_text_to_gif ( in_gif , out_gif , xy = None , text_sequence = None , font_type = 'arial.ttf' , font_size = 20 , font_color = '#000000' , add_progress_bar = True , progress_bar_color = 'white' , progress_bar_height = 5 , duration = 100 , loop = 0 ) Adds animated text to a GIF image. Parameters: Name Type Description Default in_gif str The file path to the input GIF image. required out_gif str The file path to the output GIF image. required xy tuple Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. None text_sequence int, str, list Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None. None font_type str Font type. Defaults to \"arial.ttf\". 'arial.ttf' font_size int Font size. Defaults to 20. 20 font_color str Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff'). Defaults to '#000000'. '#000000' add_progress_bar bool Whether to add a progress bar at the bottom of the GIF. Defaults to True. True progress_bar_color str Color for the progress bar. Defaults to 'white'. 'white' progress_bar_height int Height of the progress bar. Defaults to 5. 5 duration int controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100. 100 loop int controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0. 0 Source code in geemap/geemap.py def add_text_to_gif ( in_gif , out_gif , xy = None , text_sequence = None , font_type = \"arial.ttf\" , font_size = 20 , font_color = '#000000' , add_progress_bar = True , progress_bar_color = 'white' , progress_bar_height = 5 , duration = 100 , loop = 0 ): \"\"\"Adds animated text to a GIF image. Args: in_gif (str): The file path to the input GIF image. out_gif (str): The file path to the output GIF image. xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None. font_type (str, optional): Font type. Defaults to \"arial.ttf\". font_size (int, optional): Font size. Defaults to 20. font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff'). Defaults to '#000000'. add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True. progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'. progress_bar_height (int, optional): Height of the progress bar. Defaults to 5. duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100. loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0. \"\"\" import io import pkg_resources import warnings from PIL import Image , ImageDraw , ImageSequence , ImageFont warnings . simplefilter ( 'ignore' ) pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) default_font = os . path . join ( pkg_dir , 'data/fonts/arial.ttf' ) in_gif = os . path . abspath ( in_gif ) out_gif = os . path . abspath ( out_gif ) if not os . path . exists ( in_gif ): print ( 'The input gif file does not exist.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) if font_type == 'arial.ttf' : font = ImageFont . truetype ( default_font , font_size ) else : try : font_list = system_fonts ( show_full_path = True ) font_names = [ os . path . basename ( f ) for f in font_list ] if ( font_type in font_list ) or ( font_type in font_names ): font = ImageFont . truetype ( font_type , font_size ) else : print ( 'The specified font type could not be found on your system. Using the default font instead.' ) font = ImageFont . truetype ( default_font , font_size ) except Exception as e : print ( e ) font = ImageFont . truetype ( default_font , font_size ) color = check_color ( font_color ) progress_bar_color = check_color ( progress_bar_color ) try : image = Image . open ( in_gif ) except Exception as e : print ( 'An error occurred while opening the gif.' ) print ( e ) return count = image . n_frames W , H = image . size progress_bar_widths = [ i * 1.0 / count * W for i in range ( 1 , count + 1 )] progress_bar_shapes = [[( 0 , H - progress_bar_height ), ( x , H )] for x in progress_bar_widths ] if xy is None : # default text location is 5% width and 5% height of the image. xy = ( int ( 0.05 * W ), int ( 0.05 * H )) elif ( xy is not None ) and ( not isinstance ( xy , tuple )) and ( len ( xy ) == 2 ): print ( \"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\" ) return elif all ( isinstance ( item , int ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( x > 0 ) and ( x < W ) and ( y > 0 ) and ( y < H ): pass else : print ( 'xy is out of bounds. x must be within [0, {} ], and y must be within [0, {} ]' . format ( W , H )) return elif all ( isinstance ( item , str ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( '%' in x ) and ( '%' in y ): try : x = int ( float ( x . replace ( '%' , '' )) / 100.0 * W ) y = int ( float ( y . replace ( '%' , '' )) / 100.0 * H ) xy = ( x , y ) except Exception as e : print ( \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\" ) return else : print ( \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\" ) return if text_sequence is None : text = [ str ( x ) for x in range ( 1 , count + 1 )] elif isinstance ( text_sequence , int ): text = [ str ( x ) for x in range ( text_sequence , text_sequence + count + 1 )] elif isinstance ( text_sequence , str ): try : text_sequence = int ( text_sequence ) text = [ str ( x ) for x in range ( text_sequence , text_sequence + count + 1 )] except Exception as e : text = [ text_sequence ] * count elif isinstance ( text_sequence , list ) and len ( text_sequence ) != count : print ( 'The length of the text sequence must be equal to the number ( {} ) of frames in the gif.' . format ( count )) return else : text = [ str ( x ) for x in text_sequence ] try : frames = [] # Loop over each frame in the animated image for index , frame in enumerate ( ImageSequence . Iterator ( image )): # Draw the text on the frame frame = frame . convert ( 'RGB' ) draw = ImageDraw . Draw ( frame ) # w, h = draw.textsize(text[index]) draw . text ( xy , text [ index ], font = font , fill = color ) if add_progress_bar : draw . rectangle ( progress_bar_shapes [ index ], fill = progress_bar_color ) del draw b = io . BytesIO () frame . save ( b , format = \"GIF\" ) frame = Image . open ( b ) frames . append ( frame ) # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/ # Save the frames as a new image frames [ 0 ] . save ( out_gif , save_all = True , append_images = frames [ 1 :], duration = duration , loop = loop , optimize = True ) except Exception as e : print ( e ) adjust_longitude ( in_fc ) Adjusts longitude if it is less than -180 or greater than 180. Parameters: Name Type Description Default in_fc dict The input dictionary containing coordinates. required Returns: Type Description dict A dictionary containing the converted longitudes Source code in geemap/geemap.py def adjust_longitude ( in_fc ): \"\"\"Adjusts longitude if it is less than -180 or greater than 180. Args: in_fc (dict): The input dictionary containing coordinates. Returns: dict: A dictionary containing the converted longitudes \"\"\" try : keys = in_fc . keys () if 'geometry' in keys : coordinates = in_fc [ 'geometry' ][ 'coordinates' ] if in_fc [ 'geometry' ][ 'type' ] == 'Point' : longitude = coordinates [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'geometry' ][ 'coordinates' ][ 0 ] = longitude elif in_fc [ 'geometry' ][ 'type' ] == 'Polygon' : for index1 , item in enumerate ( coordinates ): for index2 , element in enumerate ( item ): longitude = element [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'geometry' ][ 'coordinates' ][ index1 ][ index2 ][ 0 ] = longitude elif in_fc [ 'geometry' ][ 'type' ] == 'LineString' : for index , element in enumerate ( coordinates ): longitude = element [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'geometry' ][ 'coordinates' ][ index ][ 0 ] = longitude elif 'type' in keys : coordinates = in_fc [ 'coordinates' ] if in_fc [ 'type' ] == 'Point' : longitude = coordinates [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'coordinates' ][ 0 ] = longitude elif in_fc [ 'type' ] == 'Polygon' : for index1 , item in enumerate ( coordinates ): for index2 , element in enumerate ( item ): longitude = element [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'coordinates' ][ index1 ][ index2 ][ 0 ] = longitude elif in_fc [ 'type' ] == 'LineString' : for index , element in enumerate ( coordinates ): longitude = element [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'coordinates' ][ index ][ 0 ] = longitude return in_fc except Exception as e : print ( e ) return None api_docs () Open a browser and navigate to the geemap API documentation. Source code in geemap/geemap.py def api_docs (): \"\"\"Open a browser and navigate to the geemap API documentation. \"\"\" import webbrowser url = 'https://giswqs.github.io/geemap/geemap' webbrowser . open_new_tab ( url ) build_api_tree ( api_dict , output_widget , layout_width = '100%' ) Builds an Earth Engine API tree view. Parameters: Name Type Description Default api_dict dict The dictionary containing information about each Earth Engine API function. required output_widget object An Output widget. required layout_width str The percentage width of the widget. Defaults to '100%'. '100%' Returns: Type Description tuple Returns a tuple containing two items: a tree Output widget and a tree dictionary. Source code in geemap/geemap.py def build_api_tree ( api_dict , output_widget , layout_width = '100%' ): \"\"\"Builds an Earth Engine API tree view. Args: api_dict (dict): The dictionary containing information about each Earth Engine API function. output_widget (object): An Output widget. layout_width (str, optional): The percentage width of the widget. Defaults to '100%'. Returns: tuple: Returns a tuple containing two items: a tree Output widget and a tree dictionary. \"\"\" import warnings warnings . filterwarnings ( 'ignore' ) tree = Tree () tree_dict = {} names = api_dict . keys () def handle_click ( event ): if event [ 'new' ]: name = event [ 'owner' ] . name values = api_dict [ name ] with output_widget : output_widget . clear_output () html_widget = widgets . HTML ( value = values [ 'html' ]) display ( html_widget ) for name in names : func_list = ee_function_tree ( name ) first = func_list [ 0 ] if first not in tree_dict . keys (): tree_dict [ first ] = Node ( first ) tree_dict [ first ] . opened = False tree . add_node ( tree_dict [ first ]) for index , func in enumerate ( func_list ): if index > 0 : if func not in tree_dict . keys (): node = tree_dict [ func_list [ index - 1 ]] node . opened = False tree_dict [ func ] = Node ( func ) node . add_node ( tree_dict [ func ]) if index == len ( func_list ) - 1 : node = tree_dict [ func_list [ index ]] node . icon = 'file' node . observe ( handle_click , 'selected' ) return tree , tree_dict build_repo_tree ( out_dir = None , name = 'gee_repos' ) Builds a repo tree for GEE account. Parameters: Name Type Description Default out_dir str The output directory for the repos. Defaults to None. None name str The output name for the repo directory. Defaults to 'gee_repos'. 'gee_repos' Returns: Type Description tuple Returns a tuple containing a tree widget, an output widget, and a tree dictionary containing nodes. Source code in geemap/geemap.py def build_repo_tree ( out_dir = None , name = 'gee_repos' ): \"\"\"Builds a repo tree for GEE account. Args: out_dir (str): The output directory for the repos. Defaults to None. name (str, optional): The output name for the repo directory. Defaults to 'gee_repos'. Returns: tuple: Returns a tuple containing a tree widget, an output widget, and a tree dictionary containing nodes. \"\"\" import warnings warnings . filterwarnings ( 'ignore' ) if out_dir is None : out_dir = os . path . join ( os . path . expanduser ( '~' )) repo_dir = os . path . join ( out_dir , name ) if not os . path . exists ( repo_dir ): os . makedirs ( repo_dir ) URLs = { # 'Owner': 'https://earthengine.googlesource.com/{}/default'.format(ee_user_id()), 'Writer' : '' , 'Reader' : 'https://github.com/giswqs/geemap' , 'Examples' : 'https://github.com/giswqs/earthengine-py-examples' , 'Archive' : 'https://earthengine.googlesource.com/EGU2017-EE101' } user_id = ee_user_id () if user_id is not None : URLs [ 'Owner' ] = 'https://earthengine.googlesource.com/ {} /default' . format ( ee_user_id ()) path_widget = widgets . Text ( placeholder = 'Enter the link to a Git repository here...' ) path_widget . layout . width = '475px' clone_widget = widgets . Button ( description = 'Clone' , button_style = 'primary' , tooltip = 'Clone the repository to folder.' ) info_widget = widgets . HBox () groups = [ 'Owner' , 'Writer' , 'Reader' , 'Examples' , 'Archive' ] for group in groups : group_dir = os . path . join ( repo_dir , group ) if not os . path . exists ( group_dir ): os . makedirs ( group_dir ) example_dir = os . path . join ( repo_dir , 'Examples/earthengine-py-examples' ) if not os . path . exists ( example_dir ): clone_github_repo ( URLs [ 'Examples' ], out_dir = example_dir ) left_widget , right_widget , tree_dict = file_browser ( in_dir = repo_dir , add_root_node = False , search_description = 'Filter scripts...' , use_import = True , return_sep_widgets = True ) info_widget . children = [ right_widget ] def handle_folder_click ( event ): if event [ 'new' ]: url = '' selected = event [ 'owner' ] if selected . name in URLs . keys (): url = URLs [ selected . name ] path_widget . value = url clone_widget . disabled = False info_widget . children = [ path_widget , clone_widget ] else : info_widget . children = [ right_widget ] for group in groups : dirname = os . path . join ( repo_dir , group ) node = tree_dict [ dirname ] node . observe ( handle_folder_click , 'selected' ) def handle_clone_click ( b ): url = path_widget . value default_dir = os . path . join ( repo_dir , 'Examples' ) if url == '' : path_widget . value = 'Please enter a valid URL to the repository.' else : for group in groups : key = os . path . join ( repo_dir , group ) node = tree_dict [ key ] if node . selected : default_dir = key try : path_widget . value = 'Cloning...' clone_dir = os . path . join ( default_dir , os . path . basename ( url )) if 'github.com' in url : clone_github_repo ( url , out_dir = clone_dir ) elif 'googlesource' in url : clone_google_repo ( url , out_dir = clone_dir ) path_widget . value = 'Cloned to {} ' . format ( clone_dir ) clone_widget . disabled = True except Exception as e : path_widget . value = 'An error occurred when trying to clone the repository ' + \\ str ( e ) clone_widget . disabled = True clone_widget . on_click ( handle_clone_click ) return left_widget , info_widget , tree_dict check_color ( in_color ) Checks the input color and returns the corresponding hex color code. Parameters: Name Type Description Default in_color str or tuple It can be a string (e.g., 'red', '#ffff00') or tuple (e.g., (255, 127, 0)). required Returns: Type Description str A hex color code. Source code in geemap/geemap.py def check_color ( in_color ): \"\"\"Checks the input color and returns the corresponding hex color code. Args: in_color (str or tuple): It can be a string (e.g., 'red', '#ffff00') or tuple (e.g., (255, 127, 0)). Returns: str: A hex color code. \"\"\" out_color = '#000000' # default black color if isinstance ( in_color , tuple ) and len ( in_color ) == 3 : if all ( isinstance ( item , int ) for item in in_color ): rescaled_color = [ x / 255.0 for x in in_color ] out_color = colour . Color ( rgb = tuple ( rescaled_color )) return out_color . hex_l else : print ( 'RGB color must be a tuple with three integer values ranging from 0 to 255.' ) return else : try : out_color = colour . Color ( in_color ) return out_color . hex_l except Exception as e : print ( 'The provided color is invalid. Using the default black color.' ) print ( e ) return out_color check_git_install () Checks if Git is installed. Returns: Type Description bool Returns True if Git is installed, otherwise returns False. Source code in geemap/geemap.py def check_git_install (): \"\"\"Checks if Git is installed. Returns: bool: Returns True if Git is installed, otherwise returns False. \"\"\" import webbrowser cmd = 'git --version' output = os . popen ( cmd ) . read () if 'git version' in output : return True else : url = 'https://git-scm.com/downloads' print ( \"Git is not installed. Please download Git from {} and install it.\" . format ( url )) webbrowser . open_new_tab ( url ) return False check_install ( package ) Checks whether a package is installed. If not, it will install the package. Parameters: Name Type Description Default package str The name of the package to check. required Source code in geemap/geemap.py def check_install ( package ): \"\"\"Checks whether a package is installed. If not, it will install the package. Args: package (str): The name of the package to check. \"\"\" import subprocess try : __import__ ( package ) # print('{} is already installed.'.format(package)) except ImportError : print ( ' {} is not installed. Installing ...' . format ( package )) try : subprocess . check_call ([ \"python\" , '-m' , 'pip' , 'install' , package ]) except Exception as e : print ( 'Failed to install {} ' . format ( package )) print ( e ) print ( \" {} has been installed successfully.\" . format ( package )) clone_github_repo ( url , out_dir ) Clones a GitHub repository. Parameters: Name Type Description Default url str The link to the GitHub repository required out_dir str The output directory for the cloned repository. required Source code in geemap/geemap.py def clone_github_repo ( url , out_dir ): \"\"\"Clones a GitHub repository. Args: url (str): The link to the GitHub repository out_dir (str): The output directory for the cloned repository. \"\"\" import zipfile repo_name = os . path . basename ( url ) # url_zip = os.path.join(url, 'archive/master.zip') url_zip = url + '/archive/master.zip' if os . path . exists ( out_dir ): print ( 'The specified output directory already exists. Please choose a new directory.' ) return parent_dir = os . path . dirname ( out_dir ) out_file_path = os . path . join ( parent_dir , repo_name + '.zip' ) try : urllib . request . urlretrieve ( url_zip , out_file_path ) except : print ( \"The provided URL is invalid. Please double check the URL.\" ) return with zipfile . ZipFile ( out_file_path , \"r\" ) as zip_ref : zip_ref . extractall ( parent_dir ) src = out_file_path . replace ( '.zip' , '-master' ) os . rename ( src , out_dir ) os . remove ( out_file_path ) clone_github_repo2 ( url , out_dir = None ) Clones a GitHub repository. Parameters: Name Type Description Default url str The link to the GitHub repository required out_dir str The output directory for the cloned repository. Defaults to None. None Source code in geemap/geemap.py def clone_github_repo2 ( url , out_dir = None ): \"\"\"Clones a GitHub repository. Args: url (str): The link to the GitHub repository out_dir (str, optional): The output directory for the cloned repository. Defaults to None. \"\"\" check_install ( 'dulwich' ) from dulwich import porcelain repo_name = os . path . basename ( url ) if out_dir is None : out_dir = os . path . join ( os . getcwd (), repo_name ) if not os . path . exists ( os . path . dirname ( out_dir )): os . makedirs ( os . path . dirname ( out_dir )) if os . path . exists ( out_dir ): print ( 'The specified output directory already exists. Please choose a new directory.' ) return try : porcelain . clone ( url , out_dir ) except Exception as e : print ( 'Failed to clone the repository.' ) print ( e ) clone_google_repo ( url , out_dir = None ) Clones an Earth Engine repository from https://earthengine.googlesource.com, such as https://earthengine.googlesource.com/users/google/datasets Parameters: Name Type Description Default url str The link to the Earth Engine repository required out_dir str The output directory for the cloned repository. Defaults to None. None Source code in geemap/geemap.py def clone_google_repo ( url , out_dir = None ): \"\"\"Clones an Earth Engine repository from https://earthengine.googlesource.com, such as https://earthengine.googlesource.com/users/google/datasets Args: url (str): The link to the Earth Engine repository out_dir (str, optional): The output directory for the cloned repository. Defaults to None. \"\"\" repo_name = os . path . basename ( url ) if out_dir is None : out_dir = os . path . join ( os . getcwd (), repo_name ) if not os . path . exists ( os . path . dirname ( out_dir )): os . makedirs ( os . path . dirname ( out_dir )) if os . path . exists ( out_dir ): print ( 'The specified output directory already exists. Please choose a new directory.' ) return if check_git_install (): cmd = 'git clone \" {} \" \" {} \"' . format ( url , out_dir ) os . popen ( cmd ) . read () clone_repo ( out_dir = '.' , unzip = True ) Clones the geemap GitHub repository. Parameters: Name Type Description Default out_dir str Output folder for the repo. Defaults to '.'. '.' unzip bool Whether to unzip the repository. Defaults to True. True Source code in geemap/geemap.py def clone_repo ( out_dir = '.' , unzip = True ): \"\"\"Clones the geemap GitHub repository. Args: out_dir (str, optional): Output folder for the repo. Defaults to '.'. unzip (bool, optional): Whether to unzip the repository. Defaults to True. \"\"\" url = 'https://github.com/giswqs/geemap/archive/master.zip' filename = 'geemap-master.zip' download_from_url ( url , out_file_name = filename , out_dir = out_dir , unzip = unzip ) copy_credentials_to_colab () Copies ee credentials from Google Drive to Google Colab. Source code in geemap/geemap.py def copy_credentials_to_colab (): \"\"\"Copies ee credentials from Google Drive to Google Colab. \"\"\" import shutil src = '/content/drive/My Drive/.config/earthengine/credentials' dst = '/root/.config/earthengine/credentials' wd = os . path . dirname ( dst ) if not os . path . exists ( wd ): os . makedirs ( wd ) shutil . copyfile ( src , dst ) copy_credentials_to_drive () Copies ee credentials from Google Colab to Google Drive. Source code in geemap/geemap.py def copy_credentials_to_drive (): \"\"\"Copies ee credentials from Google Colab to Google Drive. \"\"\" import shutil src = '/root/.config/earthengine/credentials' dst = '/content/drive/My Drive/.config/earthengine/credentials' wd = os . path . dirname ( dst ) if not os . path . exists ( wd ): os . makedirs ( wd ) shutil . copyfile ( src , dst ) create_code_cell ( code = '' , where = 'below' ) Creates a code cell in the IPython Notebook. Parameters: Name Type Description Default code str Code to fill the new code cell with. Defaults to ''. '' where str Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. 'below' Source code in geemap/geemap.py def create_code_cell ( code = '' , where = 'below' ): \"\"\"Creates a code cell in the IPython Notebook. Args: code (str, optional): Code to fill the new code cell with. Defaults to ''. where (str, optional): Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. \"\"\" import base64 from IPython.display import Javascript , display encoded_code = ( base64 . b64encode ( str . encode ( code ))) . decode () display ( Javascript ( \"\"\" var code = IPython.notebook.insert_cell_ {0} ('code'); code.set_text(atob(\" {1} \")); \"\"\" . format ( where , encoded_code ))) create_colorbar ( width = 150 , height = 30 , palette = [ 'blue' , 'green' , 'red' ], add_ticks = True , add_labels = True , labels = None , vertical = False , out_file = None , font_type = 'arial.ttf' , font_size = 12 , font_color = 'black' , add_outline = True , outline_color = 'black' ) Creates a colorbar based on the provided palette. Parameters: Name Type Description Default width int Width of the colorbar in pixels. Defaults to 150. 150 height int Height of the colorbar in pixels. Defaults to 30. 30 palette list Palette for the colorbar. Each color can be provided as a string (e.g., 'red'), a hex string (e.g., '#ff0000'), or an RGB tuple (255, 0, 255). Defaults to ['blue', 'green', 'red']. ['blue', 'green', 'red'] add_ticks bool Whether to add tick markers to the colorbar. Defaults to True. True add_labels bool Whether to add labels to the colorbar. Defaults to True. True labels list A list of labels to add to the colorbar. Defaults to None. None vertical bool Whether to rotate the colorbar vertically. Defaults to False. False out_file str File path to the output colorbar in png format. Defaults to None. None font_type str Font type to use for labels. Defaults to 'arial.ttf'. 'arial.ttf' font_size int Font size to use for labels. Defaults to 12. 12 font_color str Font color to use for labels. Defaults to 'black'. 'black' add_outline bool Whether to add an outline to the colorbar. Defaults to True. True outline_color str Color for the outline of the colorbar. Defaults to 'black'. 'black' Returns: Type Description str File path of the output colorbar in png format. Source code in geemap/geemap.py def create_colorbar ( width = 150 , height = 30 , palette = [ 'blue' , 'green' , 'red' ], add_ticks = True , add_labels = True , labels = None , vertical = False , out_file = None , font_type = 'arial.ttf' , font_size = 12 , font_color = 'black' , add_outline = True , outline_color = 'black' ): \"\"\"Creates a colorbar based on the provided palette. Args: width (int, optional): Width of the colorbar in pixels. Defaults to 150. height (int, optional): Height of the colorbar in pixels. Defaults to 30. palette (list, optional): Palette for the colorbar. Each color can be provided as a string (e.g., 'red'), a hex string (e.g., '#ff0000'), or an RGB tuple (255, 0, 255). Defaults to ['blue', 'green', 'red']. add_ticks (bool, optional): Whether to add tick markers to the colorbar. Defaults to True. add_labels (bool, optional): Whether to add labels to the colorbar. Defaults to True. labels (list, optional): A list of labels to add to the colorbar. Defaults to None. vertical (bool, optional): Whether to rotate the colorbar vertically. Defaults to False. out_file (str, optional): File path to the output colorbar in png format. Defaults to None. font_type (str, optional): Font type to use for labels. Defaults to 'arial.ttf'. font_size (int, optional): Font size to use for labels. Defaults to 12. font_color (str, optional): Font color to use for labels. Defaults to 'black'. add_outline (bool, optional): Whether to add an outline to the colorbar. Defaults to True. outline_color (str, optional): Color for the outline of the colorbar. Defaults to 'black'. Returns: str: File path of the output colorbar in png format. \"\"\" import decimal import io import pkg_resources import warnings from colour import Color from PIL import Image , ImageDraw , ImageFont warnings . simplefilter ( 'ignore' ) pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) if out_file is None : filename = 'colorbar_' + random_string () + '.png' out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) out_file = os . path . join ( out_dir , filename ) elif not out_file . endswith ( '.png' ): print ( 'The output file must end with .png' ) return else : out_file = os . path . abspath ( out_file ) if not os . path . exists ( os . path . dirname ( out_file )): os . makedirs ( os . path . dirname ( out_file )) im = Image . new ( 'RGBA' , ( width , height )) ld = im . load () def float_range ( start , stop , step ): while start < stop : yield float ( start ) start += decimal . Decimal ( step ) n_colors = len ( palette ) decimal_places = 2 rgb_colors = [ Color ( check_color ( c )) . rgb for c in palette ] keys = [ round ( c , decimal_places ) for c in list ( float_range ( 0 , 1.0001 , 1.0 / ( n_colors - 1 )))] heatmap = [] for index , item in enumerate ( keys ): pair = [ item , rgb_colors [ index ]] heatmap . append ( pair ) def gaussian ( x , a , b , c , d = 0 ): return a * math . exp ( - ( x - b ) ** 2 / ( 2 * c ** 2 )) + d def pixel ( x , width = 100 , map = [], spread = 1 ): width = float ( width ) r = sum ([ gaussian ( x , p [ 1 ][ 0 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) g = sum ([ gaussian ( x , p [ 1 ][ 1 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) b = sum ([ gaussian ( x , p [ 1 ][ 2 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) return min ( 1.0 , r ), min ( 1.0 , g ), min ( 1.0 , b ) for x in range ( im . size [ 0 ]): r , g , b = pixel ( x , width = width , map = heatmap ) r , g , b = [ int ( 256 * v ) for v in ( r , g , b )] for y in range ( im . size [ 1 ]): ld [ x , y ] = r , g , b if add_outline : draw = ImageDraw . Draw ( im ) draw . rectangle ([( 0 , 0 ), ( width - 1 , height - 1 )], outline = check_color ( outline_color )) del draw if add_ticks : tick_length = height * 0.1 x = [ key * width for key in keys ] y_top = height - tick_length y_bottom = height draw = ImageDraw . Draw ( im ) for i in x : shape = [( i , y_top ), ( i , y_bottom )] draw . line ( shape , fill = 'black' , width = 0 ) del draw if vertical : im = im . transpose ( Image . ROTATE_90 ) width , height = im . size if labels is None : labels = [ str ( c ) for c in keys ] elif len ( labels ) == 2 : try : lowerbound = float ( labels [ 0 ]) upperbound = float ( labels [ 1 ]) step = ( upperbound - lowerbound ) / ( len ( palette ) - 1 ) labels = [ str ( lowerbound + c * step ) for c in range ( 0 , len ( palette ))] except Exception as e : print ( e ) print ( 'The labels are invalid.' ) return elif len ( labels ) == len ( palette ): labels = [ str ( c ) for c in labels ] else : print ( 'The labels must have the same length as the palette.' ) return if add_labels : default_font = os . path . join ( pkg_dir , 'data/fonts/arial.ttf' ) if font_type == 'arial.ttf' : font = ImageFont . truetype ( default_font , font_size ) else : try : font_list = system_fonts ( show_full_path = True ) font_names = [ os . path . basename ( f ) for f in font_list ] if ( font_type in font_list ) or ( font_type in font_names ): font = ImageFont . truetype ( font_type , font_size ) else : print ( 'The specified font type could not be found on your system. Using the default font instead.' ) font = ImageFont . truetype ( default_font , font_size ) except Exception as e : print ( e ) font = ImageFont . truetype ( default_font , font_size ) font_color = check_color ( font_color ) draw = ImageDraw . Draw ( im ) w , h = draw . textsize ( labels [ 0 ], font = font ) for label in labels : w_tmp , h_tmp = draw . textsize ( label , font ) if w_tmp > w : w = w_tmp if h_tmp > h : h = h_tmp W , H = width + w * 2 , height + h * 2 background = Image . new ( 'RGBA' , ( W , H )) draw = ImageDraw . Draw ( background ) if vertical : xy = ( 0 , h ) else : xy = ( w , 0 ) background . paste ( im , xy , im ) for index , label in enumerate ( labels ): w_tmp , h_tmp = draw . textsize ( label , font ) if vertical : spacing = 5 x = width + spacing y = int ( height + h - keys [ index ] * height - h_tmp / 2 - 1 ) draw . text (( x , y ), label , font = font , fill = font_color ) else : x = int ( keys [ index ] * width + w - w_tmp / 2 ) spacing = int ( h * 0.05 ) y = height + spacing draw . text (( x , y ), label , font = font , fill = font_color ) im = background . copy () im . save ( out_file ) return out_file create_download_link ( filename , title = 'Click here to download: ' ) Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578 Parameters: Name Type Description Default filename str The file path to the file to download required title str str. Defaults to \"Click here to download: \". 'Click here to download: ' Returns: Type Description str HTML download URL. Source code in geemap/geemap.py def create_download_link ( filename , title = \"Click here to download: \" ): \"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578 Args: filename (str): The file path to the file to download title (str, optional): str. Defaults to \"Click here to download: \". Returns: str: HTML download URL. \"\"\" import base64 from IPython.display import HTML data = open ( filename , \"rb\" ) . read () b64 = base64 . b64encode ( data ) payload = b64 . decode () basename = os . path . basename ( filename ) html = '<a download=\" {filename} \" href=\"data:text/csv;base64, {payload} \" style=\"color:#0000FF;\" target=\"_blank\"> {title} </a>' html = html . format ( payload = payload , title = title + f ' { basename } ' , filename = basename ) return HTML ( html ) credentials_in_colab () Checks if the ee credentials file exists in Google Colab. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/geemap.py def credentials_in_colab (): \"\"\"Checks if the ee credentials file exists in Google Colab. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" credentials_path = '/root/.config/earthengine/credentials' if os . path . exists ( credentials_path ): return True else : return False credentials_in_drive () Checks if the ee credentials file exists in Google Drive. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/geemap.py def credentials_in_drive (): \"\"\"Checks if the ee credentials file exists in Google Drive. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" credentials_path = '/content/drive/My Drive/.config/earthengine/credentials' if os . path . exists ( credentials_path ): return True else : return False csv_to_shp ( in_csv , out_shp , longitude = 'longitude' , latitude = 'latitude' ) Converts a csv file with latlon info to a point shapefile. Parameters: Name Type Description Default in_csv str The input csv file containing longitude and latitude columns. required out_shp str The file path to the output shapefile. required longitude str The column name of the longitude column. Defaults to 'longitude'. 'longitude' latitude str The column name of the latitude column. Defaults to 'latitude'. 'latitude' Source code in geemap/geemap.py def csv_to_shp ( in_csv , out_shp , longitude = 'longitude' , latitude = 'latitude' ): \"\"\"Converts a csv file with latlon info to a point shapefile. Args: in_csv (str): The input csv file containing longitude and latitude columns. out_shp (str): The file path to the output shapefile. longitude (str, optional): The column name of the longitude column. Defaults to 'longitude'. latitude (str, optional): The column name of the latitude column. Defaults to 'latitude'. \"\"\" import csv import shapefile as shp if not os . path . exists ( in_csv ): print ( 'The provided CSV file does not exist.' ) return if not in_csv . endswith ( '.csv' ): print ( 'The input file must end with .csv' ) return out_dir = os . path . dirname ( out_shp ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) try : points = shp . Writer ( out_shp , shapeType = shp . POINT ) with open ( in_csv ) as csvfile : csvreader = csv . DictReader ( csvfile ) header = csvreader . fieldnames [ points . field ( field ) for field in header ] for row in csvreader : points . point (( float ( row [ longitude ])), ( float ( row [ latitude ]))) points . record ( * tuple ([ row [ f ] for f in header ])) out_prj = out_shp . replace ( '.shp' , '.prj' ) with open ( out_prj , 'w' ) as f : prj_str = 'GEOGCS[\"GCS_WGS_1984\",DATUM[\"D_WGS_1984\",SPHEROID[\"WGS_1984\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"Degree\",0.0174532925199433]] ' f . write ( prj_str ) except Exception as e : print ( e ) date_sequence ( start , end , unit , date_format = 'YYYY-MM-dd' ) Creates a date sequence. Parameters: Name Type Description Default start str The start date, e.g., '2000-01-01'. required end str The end date, e.g., '2000-12-31'. required unit str One of 'year', 'month' 'week', 'day', 'hour', 'minute', or 'second'. required date_format str A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'. 'YYYY-MM-dd' Returns: Type Description ee.List A list of date sequence. Source code in geemap/geemap.py def date_sequence ( start , end , unit , date_format = 'YYYY-MM-dd' ): \"\"\"Creates a date sequence. Args: start (str): The start date, e.g., '2000-01-01'. end (str): The end date, e.g., '2000-12-31'. unit (str): One of 'year', 'month' 'week', 'day', 'hour', 'minute', or 'second'. date_format (str, optional): A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'. Returns: ee.List: A list of date sequence. \"\"\" start_date = ee . Date ( start ) end_date = ee . Date ( end ) count = ee . Number ( end_date . difference ( start_date , unit )) . toInt () num_seq = ee . List . sequence ( 0 , count ) date_seq = num_seq . map ( lambda d : start_date . advance ( d , unit ) . format ( date_format )) return date_seq download_ee_video ( collection , video_args , out_gif ) Downloads a video thumbnail as a GIF image from Earth Engine. Parameters: Name Type Description Default collection object An ee.ImageCollection. required video_args object Parameters for expring the video thumbnail. required out_gif str File path to the output GIF. required Source code in geemap/geemap.py def download_ee_video ( collection , video_args , out_gif ): \"\"\"Downloads a video thumbnail as a GIF image from Earth Engine. Args: collection (object): An ee.ImageCollection. video_args (object): Parameters for expring the video thumbnail. out_gif (str): File path to the output GIF. \"\"\" import requests out_gif = os . path . abspath ( out_gif ) if not out_gif . endswith ( \".gif\" ): print ( 'The output file must have an extension of .gif.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) if 'region' in video_args . keys (): roi = video_args [ 'region' ] if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return video_args [ 'region' ] = roi try : print ( 'Generating URL...' ) url = collection . getVideoThumbURL ( video_args ) print ( 'Downloading GIF image from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading.' ) return else : with open ( out_gif , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) print ( 'The GIF image has been saved to: {} ' . format ( out_gif )) except Exception as e : print ( e ) edit_download_html ( htmlWidget , filename , title = 'Click here to download: ' ) Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058 Parameters: Name Type Description Default htmlWidget object The HTML widget to display the URL. required filename str File path to download. required title str Download description. Defaults to \"Click here to download: \". 'Click here to download: ' Source code in geemap/geemap.py def edit_download_html ( htmlWidget , filename , title = \"Click here to download: \" ): \"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058 Args: htmlWidget (object): The HTML widget to display the URL. filename (str): File path to download. title (str, optional): Download description. Defaults to \"Click here to download: \". \"\"\" from IPython.display import HTML import ipywidgets as widgets import base64 # Change widget html temperarily to a font-awesome spinner htmlWidget . value = \"<i class= \\\" fa fa-spinner fa-spin fa-2x fa-fw \\\" ></i><span class= \\\" sr-only \\\" >Loading...</span>\" # Process raw data data = open ( filename , \"rb\" ) . read () b64 = base64 . b64encode ( data ) payload = b64 . decode () basename = os . path . basename ( filename ) # Create and assign html to widget html = '<a download=\" {filename} \" href=\"data:text/csv;base64, {payload} \" target=\"_blank\"> {title} </a>' htmlWidget . value = html . format ( payload = payload , title = title + basename , filename = basename ) ee_api_to_csv ( outfile = None ) Extracts Earth Engine API documentation from https://developers.google.com/earth-engine/api_docs as a csv file. Parameters: Name Type Description Default outfile str The output file path to a csv file. Defaults to None. None Source code in geemap/geemap.py def ee_api_to_csv ( outfile = None ): \"\"\"Extracts Earth Engine API documentation from https://developers.google.com/earth-engine/api_docs as a csv file. Args: outfile (str, optional): The output file path to a csv file. Defaults to None. \"\"\" import csv import requests from bs4 import BeautifulSoup pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) data_dir = os . path . join ( pkg_dir , 'data' ) template_dir = os . path . join ( data_dir , 'template' ) csv_file = os . path . join ( template_dir , 'ee_api_docs.csv' ) if outfile is None : outfile = csv_file else : if not outfile . endswith ( '.csv' ): print ( 'The output file must end with .csv' ) return else : out_dir = os . path . dirname ( outfile ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) url = 'https://developers.google.com/earth-engine/api_docs' try : r = requests . get ( url ) soup = BeautifulSoup ( r . content , 'html.parser' ) names = [] descriptions = [] functions = [] returns = [] arguments = [] types = [] details = [] names = [ h2 . text for h2 in soup . find_all ( 'h2' )] descriptions = [ h2 . next_sibling . next_sibling . text for h2 in soup . find_all ( 'h2' )] func_tables = soup . find_all ( 'table' , class_ = 'blue' ) functions = [ func_table . find ( 'code' ) . text for func_table in func_tables ] returns = [ func_table . find_all ( 'td' )[ 1 ] . text for func_table in func_tables ] detail_tables = [] tables = soup . find_all ( 'table' , class_ = 'blue' ) for table in tables : item = table . next_sibling if item . attrs == { 'class' : [ 'details' ]}: detail_tables . append ( item ) else : detail_tables . append ( \"\" ) for detail_table in detail_tables : if detail_table != '' : items = [ item . text for item in detail_table . find_all ( 'code' )] else : items = \"\" arguments . append ( items ) for detail_table in detail_tables : if detail_table != '' : items = [ item . text for item in detail_table . find_all ( 'td' )] items = items [ 1 :: 3 ] else : items = \"\" types . append ( items ) for detail_table in detail_tables : if detail_table != '' : items = [ item . text for item in detail_table . find_all ( 'p' )] else : items = \"\" details . append ( items ) csv_file = open ( outfile , 'w' , encoding = 'utf-8' ) csv_writer = csv . writer ( csv_file , delimiter = ' \\t ' ) csv_writer . writerow ( [ 'name' , 'description' , 'function' , 'returns' , 'argument' , 'type' , 'details' ]) for i in range ( len ( names )): name = names [ i ] description = descriptions [ i ] function = functions [ i ] return_type = returns [ i ] argument = '|' . join ( arguments [ i ]) argu_type = '|' . join ( types [ i ]) detail = '|' . join ( details [ i ]) csv_writer . writerow ( [ name , description , function , return_type , argument , argu_type , detail ]) csv_file . close () except Exception as e : print ( e ) ee_data_html ( asset ) Generates HTML from an asset to be used in the HTML widget. Parameters: Name Type Description Default asset dict A dictionary containing an Earth Engine asset. required Returns: Type Description str A string containing HTML. Source code in geemap/geemap.py def ee_data_html ( asset ): \"\"\"Generates HTML from an asset to be used in the HTML widget. Args: asset (dict): A dictionary containing an Earth Engine asset. Returns: str: A string containing HTML. \"\"\" template = ''' <html> <body> <h3>asset_title</h3> <h4>Dataset Availability</h4> <p style=\"margin-left: 40px\">asset_dates</p> <h4>Earth Engine Snippet</h4> <p style=\"margin-left: 40px\">ee_id_snippet</p> <h4>Earth Engine Data Catalog</h4> <p style=\"margin-left: 40px\"><a href=\"asset_url\" target=\"_blank\">asset_id</a></p> <h4>Dataset Thumbnail</h4> <img src=\"thumbnail_url\"> </body> </html> ''' try : text = template . replace ( 'asset_title' , asset [ 'title' ]) text = text . replace ( 'asset_dates' , asset [ 'dates' ]) text = text . replace ( 'ee_id_snippet' , asset [ 'ee_id_snippet' ]) text = text . replace ( 'asset_id' , asset [ 'id' ]) text = text . replace ( 'asset_url' , asset [ 'asset_url' ]) # asset['thumbnail'] = ee_data_thumbnail(asset['id']) text = text . replace ( 'thumbnail_url' , asset [ 'thumbnail_url' ]) return text except Exception as e : print ( e ) ee_data_thumbnail ( asset_id ) Retrieves the thumbnail URL of an Earth Engine asset. Parameters: Name Type Description Default asset_id str An Earth Engine asset id. required Returns: Type Description str An http url of the thumbnail. Source code in geemap/geemap.py def ee_data_thumbnail ( asset_id ): \"\"\"Retrieves the thumbnail URL of an Earth Engine asset. Args: asset_id (str): An Earth Engine asset id. Returns: str: An http url of the thumbnail. \"\"\" import requests import urllib from bs4 import BeautifulSoup asset_uid = asset_id . replace ( '/' , '_' ) asset_url = \"https://developers.google.com/earth-engine/datasets/catalog/ {} \" . format ( asset_uid ) thumbnail_url = 'https://mw1.google.com/ges/dd/images/ {} _sample.png' . format ( asset_uid ) r = requests . get ( thumbnail_url ) try : if r . status_code != 200 : html_page = urllib . request . urlopen ( asset_url ) soup = BeautifulSoup ( html_page , features = \"html.parser\" ) for img in soup . findAll ( 'img' ): if 'sample.png' in img . get ( 'src' ): thumbnail_url = img . get ( 'src' ) return thumbnail_url return thumbnail_url except Exception as e : print ( e ) ee_export_geojson ( ee_object , filename = None , selectors = None ) Exports Earth Engine FeatureCollection to geojson. Parameters: Name Type Description Default ee_object object ee.FeatureCollection to export. required filename str Output file name. Defaults to None. None selectors list A list of attributes to export. Defaults to None. None Source code in geemap/geemap.py def ee_export_geojson ( ee_object , filename = None , selectors = None ): \"\"\"Exports Earth Engine FeatureCollection to geojson. Args: ee_object (object): ee.FeatureCollection to export. filename (str): Output file name. Defaults to None. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" import requests import zipfile # ee_initialize() if not isinstance ( ee_object , ee . FeatureCollection ): print ( 'The ee_object must be an ee.FeatureCollection.' ) return if filename is None : out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) filename = os . path . join ( out_dir , random_string ( 6 ) + '.geojson' ) allowed_formats = [ 'geojson' ] filename = os . path . abspath ( filename ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () if not ( filetype . lower () in allowed_formats ): print ( 'The output file type must be geojson.' ) return if selectors is None : selectors = ee_object . first () . propertyNames () . getInfo () selectors = [ '.geo' ] + selectors elif not isinstance ( selectors , list ): print ( \"selectors must be a list, such as ['attribute1', 'attribute2']\" ) return else : allowed_attributes = ee_object . first () . propertyNames () . getInfo () for attribute in selectors : if not ( attribute in allowed_attributes ): print ( 'Attributes must be one chosen from: {} ' . format ( ', ' . join ( allowed_attributes ))) return try : # print('Generating URL ...') url = ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) # print('Downloading data from {}\\nPlease wait ...'.format(url)) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading. \\n Retrying ...' ) try : new_ee_object = ee_object . map ( filter_polygons ) print ( 'Generating URL ...' ) url = new_ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) except Exception as e : print ( e ) with open ( filename , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) except Exception as e : print ( 'An error occurred while downloading.' ) print ( e ) return with open ( filename ) as f : geojson = f . read () return geojson ee_export_image ( ee_object , filename , scale = None , crs = None , region = None , file_per_band = False ) Exports an ee.Image as a GeoTIFF. Parameters: Name Type Description Default ee_object object The ee.Image to download. required filename str Output filename for the exported image. required scale float A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. None crs str A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. None region object A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. None file_per_band bool Whether to produce a different GeoTIFF per band. Defaults to False. False Source code in geemap/geemap.py def ee_export_image ( ee_object , filename , scale = None , crs = None , region = None , file_per_band = False ): \"\"\"Exports an ee.Image as a GeoTIFF. Args: ee_object (object): The ee.Image to download. filename (str): Output filename for the exported image. scale (float, optional): A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. crs (str, optional): A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. region (object, optional): A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. file_per_band (bool, optional): Whether to produce a different GeoTIFF per band. Defaults to False. \"\"\" import requests import zipfile # ee_initialize() if not isinstance ( ee_object , ee . Image ): print ( 'The ee_object must be an ee.Image.' ) return filename = os . path . abspath ( filename ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () filename_zip = filename . replace ( '.tif' , '.zip' ) if filetype != 'tif' : print ( 'The filename must end with .tif' ) return try : print ( 'Generating URL ...' ) params = { 'name' : name , 'filePerBand' : file_per_band } if scale is None : scale = ee_object . projection () . nominalScale () . multiply ( 10 ) params [ 'scale' ] = scale if region is None : region = ee_object . geometry () params [ 'region' ] = region if crs is not None : params [ 'crs' ] = crs url = ee_object . getDownloadURL ( params ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading.' ) return with open ( filename_zip , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) except Exception as e : print ( 'An error occurred while downloading.' ) print ( e ) return try : z = zipfile . ZipFile ( filename_zip ) z . extractall ( os . path . dirname ( filename )) z . close () os . remove ( filename_zip ) if file_per_band : print ( 'Data downloaded to {} ' . format ( os . path . dirname ( filename ))) else : print ( 'Data downloaded to {} ' . format ( filename )) except Exception as e : print ( e ) ee_export_image_collection ( ee_object , out_dir , scale = None , crs = None , region = None , file_per_band = False ) Exports an ImageCollection as GeoTIFFs. Parameters: Name Type Description Default ee_object object The ee.Image to download. required out_dir str The output directory for the exported images. required scale float A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. None crs str A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. None region object A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. None file_per_band bool Whether to produce a different GeoTIFF per band. Defaults to False. False Source code in geemap/geemap.py def ee_export_image_collection ( ee_object , out_dir , scale = None , crs = None , region = None , file_per_band = False ): \"\"\"Exports an ImageCollection as GeoTIFFs. Args: ee_object (object): The ee.Image to download. out_dir (str): The output directory for the exported images. scale (float, optional): A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. crs (str, optional): A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. region (object, optional): A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. file_per_band (bool, optional): Whether to produce a different GeoTIFF per band. Defaults to False. \"\"\" import requests import zipfile # ee_initialize() if not isinstance ( ee_object , ee . ImageCollection ): print ( 'The ee_object must be an ee.ImageCollection.' ) return if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) try : count = int ( ee_object . size () . getInfo ()) print ( \"Total number of images: {} \\n \" . format ( count )) for i in range ( 0 , count ): image = ee . Image ( ee_object . toList ( count ) . get ( i )) name = image . get ( 'system:index' ) . getInfo () + '.tif' filename = os . path . join ( os . path . abspath ( out_dir ), name ) print ( 'Exporting {} / {} : {} ' . format ( i + 1 , count , name )) ee_export_image ( image , filename = filename , scale = scale , crs = crs , region = region , file_per_band = file_per_band ) print ( ' \\n ' ) except Exception as e : print ( e ) ee_export_image_collection_to_drive ( ee_object , descriptions = None , folder = None , region = None , scale = None , crs = None , max_pixels = 10000000000000.0 , file_format = 'GeoTIFF' , format_options = {}) Creates a batch task to export an ImageCollection as raster images to Google Drive. Parameters: Name Type Description Default ee_object object The image to export. required descriptions list A list of human-readable names of the tasks. None folder str The Google Drive Folder that the export will reside in. Defaults to None. None region object A LinearRing, Polygon, or coordinates representing region to export. These may be specified as the Geometry objects or coordinates serialized as a string. If not specified, the region defaults to the viewport at the time of invocation. Defaults to None. None scale float Resolution in meters per pixel. Defaults to 10 times of the image resolution. None crs str CRS to use for the exported image.. Defaults to None. None max_pixels int Restrict the number of pixels in the export. Defaults to 1.0E13. 10000000000000.0 file_format str The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported. Defaults to 'GeoTIFF'. 'GeoTIFF' format_options dict A dictionary of string keys to format specific options, e.g., {'compressed': True, 'cloudOptimized': True} {} Source code in geemap/geemap.py def ee_export_image_collection_to_drive ( ee_object , descriptions = None , folder = None , region = None , scale = None , crs = None , max_pixels = 1.0E13 , file_format = 'GeoTIFF' , format_options = {}): \"\"\"Creates a batch task to export an ImageCollection as raster images to Google Drive. Args: ee_object (object): The image to export. descriptions (list): A list of human-readable names of the tasks. folder (str, optional): The Google Drive Folder that the export will reside in. Defaults to None. region (object, optional): A LinearRing, Polygon, or coordinates representing region to export. These may be specified as the Geometry objects or coordinates serialized as a string. If not specified, the region defaults to the viewport at the time of invocation. Defaults to None. scale (float, optional): Resolution in meters per pixel. Defaults to 10 times of the image resolution. crs (str, optional): CRS to use for the exported image.. Defaults to None. max_pixels (int, optional): Restrict the number of pixels in the export. Defaults to 1.0E13. file_format (str, optional): The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported. Defaults to 'GeoTIFF'. format_options (dict, optional): A dictionary of string keys to format specific options, e.g., {'compressed': True, 'cloudOptimized': True} \"\"\" # ee_initialize() if not isinstance ( ee_object , ee . ImageCollection ): print ( 'The ee_object must be an ee.ImageCollection.' ) return try : count = int ( ee_object . size () . getInfo ()) print ( \"Total number of images: {} \\n \" . format ( count )) if ( descriptions is not None ) and ( len ( descriptions ) != count ): print ( 'The number of descriptions is not equal to the number of images.' ) return if descriptions is None : descriptions = ee_object . aggregate_array ( 'system:index' ) . getInfo () images = ee_object . toList ( count ) for i in range ( 0 , count ): image = ee . Image ( images . get ( i )) name = descriptions [ i ] ee_export_image_to_drive ( image , name , folder , region , scale , crs , max_pixels , file_format , format_options ) except Exception as e : print ( e ) ee_export_image_to_drive ( ee_object , description , folder = None , region = None , scale = None , crs = None , max_pixels = 10000000000000.0 , file_format = 'GeoTIFF' , format_options = {}) Creates a batch task to export an Image as a raster to Google Drive. Parameters: Name Type Description Default ee_object object The image to export. required description str A human-readable name of the task. required folder str The Google Drive Folder that the export will reside in. Defaults to None. None region object A LinearRing, Polygon, or coordinates representing region to export. These may be specified as the Geometry objects or coordinates serialized as a string. If not specified, the region defaults to the viewport at the time of invocation. Defaults to None. None scale float Resolution in meters per pixel. Defaults to 10 times of the image resolution. None crs str CRS to use for the exported image.. Defaults to None. None max_pixels int Restrict the number of pixels in the export. Defaults to 1.0E13. 10000000000000.0 file_format str The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported. Defaults to 'GeoTIFF'. 'GeoTIFF' format_options dict A dictionary of string keys to format specific options, e.g., {'compressed': True, 'cloudOptimized': True} {} Source code in geemap/geemap.py def ee_export_image_to_drive ( ee_object , description , folder = None , region = None , scale = None , crs = None , max_pixels = 1.0E13 , file_format = 'GeoTIFF' , format_options = {}): \"\"\"Creates a batch task to export an Image as a raster to Google Drive. Args: ee_object (object): The image to export. description (str): A human-readable name of the task. folder (str, optional): The Google Drive Folder that the export will reside in. Defaults to None. region (object, optional): A LinearRing, Polygon, or coordinates representing region to export. These may be specified as the Geometry objects or coordinates serialized as a string. If not specified, the region defaults to the viewport at the time of invocation. Defaults to None. scale (float, optional): Resolution in meters per pixel. Defaults to 10 times of the image resolution. crs (str, optional): CRS to use for the exported image.. Defaults to None. max_pixels (int, optional): Restrict the number of pixels in the export. Defaults to 1.0E13. file_format (str, optional): The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported. Defaults to 'GeoTIFF'. format_options (dict, optional): A dictionary of string keys to format specific options, e.g., {'compressed': True, 'cloudOptimized': True} \"\"\" # ee_initialize() if not isinstance ( ee_object , ee . Image ): print ( 'The ee_object must be an ee.Image.' ) return try : params = {} if folder is not None : params [ 'driveFolder' ] = folder if region is not None : params [ 'region' ] = region if scale is None : scale = ee_object . projection () . nominalScale () . multiply ( 10 ) params [ 'scale' ] = scale if crs is not None : params [ 'crs' ] = crs params [ 'maxPixels' ] = max_pixels params [ 'fileFormat' ] = file_format params [ 'formatOptions' ] = format_options task = ee . batch . Export . image ( ee_object , description , params ) task . start () print ( 'Exporting {} ...' . format ( description )) except Exception as e : print ( e ) ee_export_vector ( ee_object , filename , selectors = None ) Exports Earth Engine FeatureCollection to other formats, including shp, csv, json, kml, and kmz. Parameters: Name Type Description Default ee_object object ee.FeatureCollection to export. required filename str Output file name. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/geemap.py def ee_export_vector ( ee_object , filename , selectors = None ): \"\"\"Exports Earth Engine FeatureCollection to other formats, including shp, csv, json, kml, and kmz. Args: ee_object (object): ee.FeatureCollection to export. filename (str): Output file name. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" import requests import zipfile # ee_initialize() if not isinstance ( ee_object , ee . FeatureCollection ): raise ValueError ( 'ee_object must be an ee.FeatureCollection' ) allowed_formats = [ 'csv' , 'geojson' , 'kml' , 'kmz' , 'shp' ] # allowed_formats = ['csv', 'kml', 'kmz'] filename = os . path . abspath ( filename ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () if filetype == 'shp' : filename = filename . replace ( '.shp' , '.zip' ) if not ( filetype . lower () in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) print ( 'Earth Engine no longer supports downloading featureCollection as shapefile or json. \\n Please use geemap.ee_export_vector_to_drive() to export featureCollection to Google Drive.' ) raise ValueError if selectors is None : selectors = ee_object . first () . propertyNames () . getInfo () if filetype == 'csv' : # remove .geo coordinate field ee_object = ee_object . select ([ \".*\" ], None , False ) if filetype == 'geojson' : selectors = [ '.geo' ] + selectors elif not isinstance ( selectors , list ): raise ValueError ( \"selectors must be a list, such as ['attribute1', 'attribute2']\" ) else : allowed_attributes = ee_object . first () . propertyNames () . getInfo () for attribute in selectors : if not ( attribute in allowed_attributes ): raise ValueError ( 'Attributes must be one chosen from: {} ' . format ( ', ' . join ( allowed_attributes ))) try : print ( 'Generating URL ...' ) url = ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading. \\n Retrying ...' ) try : new_ee_object = ee_object . map ( filter_polygons ) print ( 'Generating URL ...' ) url = new_ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) except Exception as e : print ( e ) raise ValueError with open ( filename , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) except Exception as e : print ( 'An error occurred while downloading.' ) raise ValueError ( e ) try : if filetype == 'shp' : z = zipfile . ZipFile ( filename ) z . extractall ( os . path . dirname ( filename )) os . remove ( filename ) filename = filename . replace ( '.zip' , '.shp' ) print ( 'Data downloaded to {} ' . format ( filename )) except Exception as e : raise ValueError ( e ) ee_export_vector_to_drive ( ee_object , description , folder , file_format = 'shp' , selectors = None ) Exports Earth Engine FeatureCollection to Google Drive. other formats, including shp, csv, json, kml, and kmz. Parameters: Name Type Description Default ee_object object ee.FeatureCollection to export. required description str File name of the output file. required folder str Folder name within Google Drive to save the exported file. required file_format str The supported file format include shp, csv, json, kml, kmz, and TFRecord. Defaults to 'shp'. 'shp' selectors list The list of attributes to export. Defaults to None. None Source code in geemap/geemap.py def ee_export_vector_to_drive ( ee_object , description , folder , file_format = 'shp' , selectors = None ): \"\"\"Exports Earth Engine FeatureCollection to Google Drive. other formats, including shp, csv, json, kml, and kmz. Args: ee_object (object): ee.FeatureCollection to export. description (str): File name of the output file. folder (str): Folder name within Google Drive to save the exported file. file_format (str, optional): The supported file format include shp, csv, json, kml, kmz, and TFRecord. Defaults to 'shp'. selectors (list, optional): The list of attributes to export. Defaults to None. \"\"\" if not isinstance ( ee_object , ee . FeatureCollection ): print ( 'The ee_object must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' , 'tfrecord' ] if not ( file_format . lower () in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return task_config = { 'folder' : folder , 'fileFormat' : file_format , } if selectors is not None : task_config [ 'selectors' ] = selectors elif ( selectors is None ) and ( file_format . lower () == 'csv' ): # remove .geo coordinate field ee_object = ee_object . select ([ \".*\" ], None , False ) print ( 'Exporting {} ...' . format ( description )) task = ee . batch . Export . table . toDrive ( ee_object , description , ** task_config ) task . start () ee_function_tree ( name ) Construct the tree structure based on an Earth Engine function. For example, the function \"ee.Algorithms.FMask.matchClouds\" will return a list [\"ee.Algorithms\", \"ee.Algorithms.FMask\", \"ee.Algorithms.FMask.matchClouds\"] Parameters: Name Type Description Default name str The name of the Earth Engine function required Returns: Type Description list The list for parent functions. Source code in geemap/geemap.py def ee_function_tree ( name ): \"\"\"Construct the tree structure based on an Earth Engine function. For example, the function \"ee.Algorithms.FMask.matchClouds\" will return a list [\"ee.Algorithms\", \"ee.Algorithms.FMask\", \"ee.Algorithms.FMask.matchClouds\"] Args: name (str): The name of the Earth Engine function Returns: list: The list for parent functions. \"\"\" func_list = [] try : items = name . split ( '.' ) if items [ 0 ] == 'ee' : for i in range ( 2 , len ( items ) + 1 ): func_list . append ( '.' . join ( items [ 0 : i ])) else : for i in range ( 1 , len ( items ) + 1 ): func_list . append ( '.' . join ( items [ 0 : i ])) return func_list except Exception as e : print ( e ) print ( 'The provided function name is invalid.' ) ee_initialize ( token_name = 'EARTHENGINE_TOKEN' ) Authenticates Earth Engine and initialize an Earth Engine session Source code in geemap/geemap.py def ee_initialize ( token_name = 'EARTHENGINE_TOKEN' ): \"\"\"Authenticates Earth Engine and initialize an Earth Engine session \"\"\" try : ee_token = os . environ . get ( token_name ) if ee_token is not None : credential = '{\"refresh_token\":\" %s \"}' % ee_token credential_file_path = os . path . expanduser ( \"~/.config/earthengine/\" ) os . makedirs ( credential_file_path , exist_ok = True ) with open ( credential_file_path + 'credentials' , 'w' ) as file : file . write ( credential ) elif in_colab_shell (): if credentials_in_drive () and ( not credentials_in_colab ()): copy_credentials_to_colab () elif not credentials_in_colab : ee . Authenticate () if is_drive_mounted () and ( not credentials_in_drive ()): copy_credentials_to_drive () else : if is_drive_mounted (): copy_credentials_to_drive () ee . Initialize () except : ee . Authenticate () ee . Initialize () ee_search ( asset_limit = 100 ) Search Earth Engine API and user assets. If you received a warning (IOPub message rate exceeded) in Jupyter notebook, you can relaunch Jupyter notebook using the following command: jupyter notebook --NotebookApp.iopub_msg_rate_limit=10000 Parameters: Name Type Description Default asset_limit int The number of assets to display for each asset type, i.e., Image, ImageCollection, and FeatureCollection. Defaults to 100. 100 Source code in geemap/geemap.py def ee_search ( asset_limit = 100 ): \"\"\"Search Earth Engine API and user assets. If you received a warning (IOPub message rate exceeded) in Jupyter notebook, you can relaunch Jupyter notebook using the following command: jupyter notebook --NotebookApp.iopub_msg_rate_limit=10000 Args: asset_limit (int, optional): The number of assets to display for each asset type, i.e., Image, ImageCollection, and FeatureCollection. Defaults to 100. \"\"\" import warnings warnings . filterwarnings ( 'ignore' ) class Flags : def __init__ ( self , repos = None , docs = None , assets = None , docs_dict = None , asset_dict = None , asset_import = None ): self . repos = repos self . docs = docs self . assets = assets self . docs_dict = docs_dict self . asset_dict = asset_dict self . asset_import = asset_import flags = Flags () search_type = widgets . ToggleButtons ( options = [ 'Scripts' , 'Docs' , 'Assets' ], tooltips = [ 'Search Earth Engine Scripts' , 'Search Earth Engine API' , 'Search Earth Engine Assets' ], button_style = 'primary' ) search_type . style . button_width = '100px' search_box = widgets . Text ( placeholder = 'Filter scripts...' , value = 'Loading...' ) search_box . layout . width = '310px' tree_widget = widgets . Output () left_widget = widgets . VBox () right_widget = widgets . VBox () output_widget = widgets . Output () output_widget . layout . max_width = '650px' search_widget = widgets . HBox () search_widget . children = [ left_widget , right_widget ] display ( search_widget ) repo_tree , repo_output , _ = build_repo_tree () left_widget . children = [ search_type , repo_tree ] right_widget . children = [ repo_output ] flags . repos = repo_tree search_box . value = '' def search_type_changed ( change ): search_box . value = '' output_widget . clear_output () tree_widget . clear_output () if change [ 'new' ] == 'Scripts' : search_box . placeholder = 'Filter scripts...' left_widget . children = [ search_type , repo_tree ] right_widget . children = [ repo_output ] elif change [ 'new' ] == 'Docs' : search_box . placeholder = 'Filter methods...' search_box . value = 'Loading...' left_widget . children = [ search_type , search_box , tree_widget ] right_widget . children = [ output_widget ] if flags . docs is None : api_dict = read_api_csv () ee_api_tree , tree_dict = build_api_tree ( api_dict , output_widget ) flags . docs = ee_api_tree flags . docs_dict = tree_dict else : ee_api_tree = flags . docs with tree_widget : tree_widget . clear_output () display ( ee_api_tree ) right_widget . children = [ output_widget ] search_box . value = '' elif change [ 'new' ] == 'Assets' : search_box . placeholder = 'Filter assets...' left_widget . children = [ search_type , search_box , tree_widget ] right_widget . children = [ output_widget ] search_box . value = 'Loading...' if flags . assets is None : asset_tree , asset_widget , asset_dict = build_asset_tree ( limit = asset_limit ) flags . assets = asset_tree flags . asset_dict = asset_dict flags . asset_import = asset_widget with tree_widget : tree_widget . clear_output () display ( flags . assets ) right_widget . children = [ flags . asset_import ] search_box . value = '' search_type . observe ( search_type_changed , names = 'value' ) def search_box_callback ( text ): if search_type . value == 'Docs' : with tree_widget : if text . value == '' : print ( 'Loading...' ) tree_widget . clear_output ( wait = True ) display ( flags . docs ) else : tree_widget . clear_output () print ( 'Searching...' ) tree_widget . clear_output ( wait = True ) sub_tree = search_api_tree ( text . value , flags . docs_dict ) display ( sub_tree ) elif search_type . value == 'Assets' : with tree_widget : if text . value == '' : print ( 'Loading...' ) tree_widget . clear_output ( wait = True ) display ( flags . assets ) else : tree_widget . clear_output () print ( 'Searching...' ) tree_widget . clear_output ( wait = True ) sub_tree = search_api_tree ( text . value , flags . asset_dict ) display ( sub_tree ) search_box . on_submit ( search_box_callback ) ee_tile_layer ( ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ) Converts and Earth Engine layer to ipyleaflet TileLayer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer untitled'. 'Layer untitled' shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/geemap.py def ee_tile_layer ( ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ): \"\"\"Converts and Earth Engine layer to ipyleaflet TileLayer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer untitled'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" # ee_initialize() image = None if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) tile_layer = ipyleaflet . TileLayer ( url = map_id_dict [ 'tile_fetcher' ] . url_format , attribution = 'Google Earth Engine' , name = name , opacity = opacity , visible = True # visible=shown ) return tile_layer ee_to_csv ( ee_object , filename , selectors = None ) Downloads an ee.FeatureCollection as a CSV file. Parameters: Name Type Description Default ee_object object ee.FeatureCollection required filename str The output filepath of the CSV file. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/geemap.py def ee_to_csv ( ee_object , filename , selectors = None ): \"\"\"Downloads an ee.FeatureCollection as a CSV file. Args: ee_object (object): ee.FeatureCollection filename (str): The output filepath of the CSV file. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" # ee_initialize() try : if filename . lower () . endswith ( '.csv' ): ee_export_vector ( ee_object = ee_object , filename = filename , selectors = selectors ) else : print ( 'The filename must end with .csv' ) except Exception as e : print ( e ) ee_to_geojson ( ee_object , out_json = None ) Converts Earth Engine object to geojson. Parameters: Name Type Description Default ee_object object An Earth Engine object. required Returns: Type Description object GeoJSON object. Source code in geemap/geemap.py def ee_to_geojson ( ee_object , out_json = None ): \"\"\"Converts Earth Engine object to geojson. Args: ee_object (object): An Earth Engine object. Returns: object: GeoJSON object. \"\"\" from json import dumps # ee_initialize() try : if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): json_object = ee_object . getInfo () if out_json is not None : out_json = os . path . abspath ( out_json ) if not os . path . exists ( os . path . dirname ( out_json )): os . makedirs ( os . path . dirname ( out_json )) geojson = open ( out_json , \"w\" ) geojson . write ( dumps ({ \"type\" : \"FeatureCollection\" , \"features\" : json_object }, indent = 2 ) + \" \\n \" ) geojson . close () return json_object else : print ( \"Could not convert the Earth Engine object to geojson\" ) except Exception as e : print ( e ) ee_to_numpy ( ee_object , bands = None , region = None , properties = None , default_value = None ) Extracts a rectangular region of pixels from an image into a 2D numpy array per band. Parameters: Name Type Description Default ee_object object The image to sample. required bands list The list of band names to extract. Please make sure that all bands have the same spatial resolution. Defaults to None. None region object The region whose projected bounding box is used to sample the image. The maximum number of pixels you can export is 262,144. Resampling and reprojecting all bands to a fixed scale can be useful. Defaults to the footprint in each band. None properties list The properties to copy over from the sampled image. Defaults to all non-system properties. None default_value float A default value used when a sampled pixel is masked or outside a band's footprint. Defaults to None. None Returns: Type Description array A 3D numpy array. Source code in geemap/geemap.py def ee_to_numpy ( ee_object , bands = None , region = None , properties = None , default_value = None ): \"\"\"Extracts a rectangular region of pixels from an image into a 2D numpy array per band. Args: ee_object (object): The image to sample. bands (list, optional): The list of band names to extract. Please make sure that all bands have the same spatial resolution. Defaults to None. region (object, optional): The region whose projected bounding box is used to sample the image. The maximum number of pixels you can export is 262,144. Resampling and reprojecting all bands to a fixed scale can be useful. Defaults to the footprint in each band. properties (list, optional): The properties to copy over from the sampled image. Defaults to all non-system properties. default_value (float, optional): A default value used when a sampled pixel is masked or outside a band's footprint. Defaults to None. Returns: array: A 3D numpy array. \"\"\" import numpy as np if not isinstance ( ee_object , ee . Image ): print ( 'The input must be an ee.Image.' ) return if region is None : region = ee_object . geometry () try : if bands is not None : ee_object = ee_object . select ( bands ) else : bands = ee_object . bandNames () . getInfo () band_count = len ( bands ) band_arrs = ee_object . sampleRectangle ( region = region , properties = properties , defaultValue = default_value ) band_values = [] for band in bands : band_arr = band_arrs . get ( band ) . getInfo () band_value = np . array ( band_arr ) band_values . append ( band_value ) image = np . dstack ( band_values ) return image except Exception as e : print ( e ) ee_to_shp ( ee_object , filename , selectors = None ) Downloads an ee.FeatureCollection as a shapefile. Parameters: Name Type Description Default ee_object object ee.FeatureCollection required filename str The output filepath of the shapefile. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/geemap.py def ee_to_shp ( ee_object , filename , selectors = None ): \"\"\"Downloads an ee.FeatureCollection as a shapefile. Args: ee_object (object): ee.FeatureCollection filename (str): The output filepath of the shapefile. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" # ee_initialize() try : if filename . lower () . endswith ( '.shp' ): ee_export_vector ( ee_object = ee_object , filename = filename , selectors = selectors ) else : print ( 'The filename must end with .shp' ) except Exception as e : print ( e ) ee_user_id () Gets Earth Engine account user id. Returns: Type Description str A string containing the user id. Source code in geemap/geemap.py def ee_user_id (): \"\"\"Gets Earth Engine account user id. Returns: str: A string containing the user id. \"\"\" # ee_initialize() roots = ee . data . getAssetRoots () if len ( roots ) == 0 : return None else : root = ee . data . getAssetRoots ()[ 0 ] user_id = root [ 'id' ] . replace ( \"projects/earthengine-legacy/assets/\" , \"\" ) return user_id file_browser ( in_dir = None , show_hidden = False , add_root_node = True , search_description = None , use_import = False , return_sep_widgets = False ) Creates a simple file browser and text editor. Parameters: Name Type Description Default in_dir str The input directory. Defaults to None, which will use the current working directory. None show_hidden bool Whether to show hidden files/folders. Defaults to False. False add_root_node bool Whether to add the input directory as a root node. Defaults to True. True search_description str The description of the search box. Defaults to None. None use_import bool Whether to show the import button. Defaults to False. False return_sep_widgets bool Whether to return the results as separate widgets. Defaults to False. False Returns: Type Description object An ipywidget. Source code in geemap/geemap.py def file_browser ( in_dir = None , show_hidden = False , add_root_node = True , search_description = None , use_import = False , return_sep_widgets = False ): \"\"\"Creates a simple file browser and text editor. Args: in_dir (str, optional): The input directory. Defaults to None, which will use the current working directory. show_hidden (bool, optional): Whether to show hidden files/folders. Defaults to False. add_root_node (bool, optional): Whether to add the input directory as a root node. Defaults to True. search_description (str, optional): The description of the search box. Defaults to None. use_import (bool, optional): Whether to show the import button. Defaults to False. return_sep_widgets (bool, optional): Whether to return the results as separate widgets. Defaults to False. Returns: object: An ipywidget. \"\"\" import platform if in_dir is None : in_dir = os . getcwd () if not os . path . exists ( in_dir ): print ( 'The provided directory does not exist.' ) return elif not os . path . isdir ( in_dir ): print ( 'The provided path is not a valid directory.' ) return sep = '/' if platform . system () == \"Windows\" : sep = ' \\\\ ' if in_dir . endswith ( sep ): in_dir = in_dir [: - 1 ] full_widget = widgets . HBox () left_widget = widgets . VBox () right_widget = widgets . VBox () import_btn = widgets . Button ( description = 'import' , button_style = 'primary' , tooltip = 'import the content to a new cell' , disabled = True ) import_btn . layout . width = '70px' path_widget = widgets . Text () path_widget . layout . min_width = '400px' # path_widget.layout.max_width = '400px' save_widget = widgets . Button ( description = 'Save' , button_style = 'primary' , tooltip = 'Save edits to file.' , disabled = True ) info_widget = widgets . HBox () info_widget . children = [ path_widget , save_widget ] if use_import : info_widget . children = [ import_btn , path_widget , save_widget ] text_widget = widgets . Textarea () text_widget . layout . width = '630px' text_widget . layout . height = '600px' right_widget . children = [ info_widget , text_widget ] full_widget . children = [ left_widget ] if search_description is None : search_description = 'Search files/folders...' search_box = widgets . Text ( placeholder = search_description ) search_box . layout . width = '310px' tree_widget = widgets . Output () tree_widget . layout . max_width = '310px' tree_widget . overflow = 'auto' left_widget . children = [ search_box , tree_widget ] tree = Tree ( multiple_selection = False ) tree_dict = {} def on_button_clicked ( b ): content = text_widget . value out_file = path_widget . value out_dir = os . path . dirname ( out_file ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) with open ( out_file , 'w' ) as f : f . write ( content ) text_widget . disabled = True text_widget . value = 'The content has been saved successfully.' save_widget . disabled = True path_widget . disabled = True if ( out_file not in tree_dict . keys ()) and ( out_dir in tree_dict . keys ()): node = Node ( os . path . basename ( out_file )) tree_dict [ out_file ] = node parent_node = tree_dict [ out_dir ] parent_node . add_node ( node ) save_widget . on_click ( on_button_clicked ) def import_btn_clicked ( b ): if ( text_widget . value != '' ) and ( path_widget . value . endswith ( '.py' )): create_code_cell ( text_widget . value ) import_btn . on_click ( import_btn_clicked ) def search_box_callback ( text ): with tree_widget : if text . value == '' : print ( 'Loading...' ) tree_widget . clear_output ( wait = True ) display ( tree ) else : tree_widget . clear_output () print ( 'Searching...' ) tree_widget . clear_output ( wait = True ) sub_tree = search_api_tree ( text . value , tree_dict ) display ( sub_tree ) search_box . on_submit ( search_box_callback ) def handle_file_click ( event ): if event [ 'new' ]: cur_node = event [ 'owner' ] for key in tree_dict . keys (): if ( cur_node is tree_dict [ key ]) and ( os . path . isfile ( key )): if key . endswith ( '.py' ): import_btn . disabled = False else : import_btn . disabled = True try : with open ( key ) as f : content = f . read () text_widget . value = content text_widget . disabled = False path_widget . value = key path_widget . disabled = False save_widget . disabled = False full_widget . children = [ left_widget , right_widget ] except Exception as e : path_widget . value = key path_widget . disabled = True save_widget . disabled = True text_widget . disabled = True text_widget . value = 'Failed to open {} .' . format ( cur_node . name ) + ' \\n\\n ' + str ( e ) full_widget . children = [ left_widget , right_widget ] return break def handle_folder_click ( event ): if event [ 'new' ]: full_widget . children = [ left_widget ] text_widget . value = '' if add_root_node : root_name = in_dir . split ( sep )[ - 1 ] root_node = Node ( root_name ) tree_dict [ in_dir ] = root_node tree . add_node ( root_node ) root_node . observe ( handle_folder_click , 'selected' ) for root , d_names , f_names in os . walk ( in_dir ): if not show_hidden : folders = root . split ( sep ) for folder in folders : if folder . startswith ( '.' ): continue for d_name in d_names : if d_name . startswith ( '.' ): d_names . remove ( d_name ) for f_name in f_names : if f_name . startswith ( '.' ): f_names . remove ( f_name ) d_names . sort () f_names . sort () if ( not add_root_node ) and ( root == in_dir ): for d_name in d_names : node = Node ( d_name ) tree_dict [ os . path . join ( in_dir , d_name )] = node tree . add_node ( node ) node . opened = False node . observe ( handle_folder_click , 'selected' ) if ( root != in_dir ) and ( root not in tree_dict . keys ()): name = root . split ( sep )[ - 1 ] dir_name = os . path . dirname ( root ) parent_node = tree_dict [ dir_name ] node = Node ( name ) tree_dict [ root ] = node parent_node . add_node ( node ) node . observe ( handle_folder_click , 'selected' ) if len ( f_names ) > 0 : parent_node = tree_dict [ root ] parent_node . opened = False for f_name in f_names : node = Node ( f_name ) node . icon = 'file' full_path = os . path . join ( root , f_name ) tree_dict [ full_path ] = node parent_node . add_node ( node ) node . observe ( handle_file_click , 'selected' ) with tree_widget : tree_widget . clear_output () display ( tree ) if return_sep_widgets : return left_widget , right_widget , tree_dict else : return full_widget filter_polygons ( ftr ) Converts GeometryCollection to Polygon/MultiPolygon Parameters: Name Type Description Default ftr object ee.Feature required Returns: Type Description object ee.Feature Source code in geemap/geemap.py def filter_polygons ( ftr ): \"\"\"Converts GeometryCollection to Polygon/MultiPolygon Args: ftr (object): ee.Feature Returns: object: ee.Feature \"\"\" # ee_initialize() geometries = ftr . geometry () . geometries () geometries = geometries . map ( lambda geo : ee . Feature ( ee . Geometry ( geo )) . set ( 'geoType' , ee . Geometry ( geo ) . type ())) polygons = ee . FeatureCollection ( geometries ) . filter ( ee . Filter . eq ( 'geoType' , 'Polygon' )) . geometry () return ee . Feature ( polygons ) . copyProperties ( ftr ) geocode ( location , max_rows = 10 , reverse = False ) Search location by address and lat/lon coordinates. Parameters: Name Type Description Default location str Place name or address required max_rows int Maximum number of records to return. Defaults to 10. 10 reverse bool Search place based on coordinates. Defaults to False. False Returns: Type Description list Returns a list of locations. Source code in geemap/geemap.py def geocode ( location , max_rows = 10 , reverse = False ): \"\"\"Search location by address and lat/lon coordinates. Args: location (str): Place name or address max_rows (int, optional): Maximum number of records to return. Defaults to 10. reverse (bool, optional): Search place based on coordinates. Defaults to False. Returns: list: Returns a list of locations. \"\"\" if not isinstance ( location , str ): print ( 'The location must be a string.' ) return None if not reverse : locations = [] addresses = set () g = geocoder . arcgis ( location , maxRows = max_rows ) for result in g : address = result . address if not address in addresses : addresses . add ( address ) locations . append ( result ) if len ( locations ) > 0 : return locations else : return None else : try : if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return g = geocoder . arcgis ( latlon , method = 'reverse' ) locations = [] addresses = set () for result in g : address = result . address if not address in addresses : addresses . add ( address ) locations . append ( result ) if len ( locations ) > 0 : return locations else : return None except Exception as e : print ( e ) return None geojson_to_ee ( geo_json , geodesic = True ) Converts a geojson to ee.Geometry() Parameters: Name Type Description Default geo_json dict A geojson geometry dictionary or file path. required Returns: Type Description ee_object An ee.Geometry object Source code in geemap/geemap.py def geojson_to_ee ( geo_json , geodesic = True ): \"\"\"Converts a geojson to ee.Geometry() Args: geo_json (dict): A geojson geometry dictionary or file path. Returns: ee_object: An ee.Geometry object \"\"\" # ee_initialize() try : import json if not isinstance ( geo_json , dict ) and os . path . isfile ( geo_json ): with open ( os . path . abspath ( geo_json )) as f : geo_json = json . load ( f ) if geo_json [ 'type' ] == 'FeatureCollection' : features = ee . FeatureCollection ( geo_json [ 'features' ]) return features elif geo_json [ 'type' ] == 'Feature' : geom = None keys = geo_json [ 'properties' ][ 'style' ] . keys () if 'radius' in keys : # Checks whether it is a circle geom = ee . Geometry ( geo_json [ 'geometry' ]) radius = geo_json [ 'properties' ][ 'style' ][ 'radius' ] geom = geom . buffer ( radius ) elif geo_json [ 'geometry' ][ 'type' ] == 'Point' : # Checks whether it is a point coordinates = geo_json [ 'geometry' ][ 'coordinates' ] longitude = coordinates [ 0 ] latitude = coordinates [ 1 ] geom = ee . Geometry . Point ( longitude , latitude ) else : geom = ee . Geometry ( geo_json [ 'geometry' ], \"\" , geodesic ) return geom else : print ( \"Could not convert the geojson to ee.Geometry()\" ) except Exception as e : print ( \"Could not convert the geojson to ee.Geometry()\" ) print ( e ) has_transparency ( img ) Checks whether an image has transparency. Parameters: Name Type Description Default img object a PIL Image object. required Returns: Type Description bool True if it has transparency, False otherwise. Source code in geemap/geemap.py def has_transparency ( img ): \"\"\"Checks whether an image has transparency. Args: img (object): a PIL Image object. Returns: bool: True if it has transparency, False otherwise. \"\"\" if img . mode == \"P\" : transparent = img . info . get ( \"transparency\" , - 1 ) for _ , index in img . getcolors (): if index == transparent : return True elif img . mode == \"RGBA\" : extrema = img . getextrema () if extrema [ 3 ][ 0 ] < 255 : return True return False hex_to_rgb ( value = 'FFFFFF' ) Converts hex color to RGB color. Parameters: Name Type Description Default value str Hex color code as a string. Defaults to 'FFFFFF'. 'FFFFFF' Returns: Type Description tuple RGB color as a tuple. Source code in geemap/geemap.py def hex_to_rgb ( value = 'FFFFFF' ): \"\"\"Converts hex color to RGB color. Args: value (str, optional): Hex color code as a string. Defaults to 'FFFFFF'. Returns: tuple: RGB color as a tuple. \"\"\" value = value . lstrip ( '#' ) lv = len ( value ) return tuple ( int ( value [ i : i + lv // 3 ], 16 ) for i in range ( 0 , lv , lv // 3 )) image_props ( img , date_format = 'YYYY-MM-dd' ) Gets image properties. Parameters: Name Type Description Default img ee.Image The input image. required date_format str The output date format. Defaults to 'YYYY-MM-dd HH:mm:ss'. 'YYYY-MM-dd' Returns: Type Description dd.Dictionary The dictionary containing image properties. Source code in geemap/geemap.py def image_props ( img , date_format = 'YYYY-MM-dd' ): \"\"\"Gets image properties. Args: img (ee.Image): The input image. date_format (str, optional): The output date format. Defaults to 'YYYY-MM-dd HH:mm:ss'. Returns: dd.Dictionary: The dictionary containing image properties. \"\"\" if not isinstance ( img , ee . Image ): print ( 'The input object must be an ee.Image' ) return keys = img . propertyNames () . remove ( 'system:footprint' ) . remove ( 'system:bands' ) values = keys . map ( lambda p : img . get ( p )) bands = img . bandNames () scales = bands . map ( lambda b : img . select ([ b ]) . projection () . nominalScale ()) scale = ee . Algorithms . If ( scales . distinct () . size () . gt ( 1 ), ee . Dictionary . fromLists ( bands . getInfo (), scales ), scales . get ( 0 )) image_date = ee . Date ( img . get ( 'system:time_start' )) . format ( date_format ) time_start = ee . Date ( img . get ( 'system:time_start' ) ) . format ( 'YYYY-MM-dd HH:mm:ss' ) # time_end = ee.Date(img.get('system:time_end')).format('YYYY-MM-dd HH:mm:ss') time_end = ee . Algorithms . If ( ee . List ( img . propertyNames ()) . contains ( 'system:time_end' ), ee . Date ( img . get ( 'system:time_end' )) . format ( 'YYYY-MM-dd HH:mm:ss' ), time_start ) asset_size = ee . Number ( img . get ( 'system:asset_size' )) . divide ( 1e6 ) . format () . cat ( ee . String ( ' MB' )) props = ee . Dictionary . fromLists ( keys , values ) props = props . set ( 'system:time_start' , time_start ) props = props . set ( 'system:time_end' , time_end ) props = props . set ( 'system:asset_size' , asset_size ) props = props . set ( 'NOMINAL_SCALE' , scale ) props = props . set ( 'IMAGE_DATE' , image_date ) return props image_stats ( img , region = None , scale = None ) Gets image descriptive statistics. Parameters: Name Type Description Default img ee.Image The input image to calculate descriptive statistics. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description ee.Dictionary A dictionary containing the description statistics of the input image. Source code in geemap/geemap.py def image_stats ( img , region = None , scale = None ): \"\"\"Gets image descriptive statistics. Args: img (ee.Image): The input image to calculate descriptive statistics. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: ee.Dictionary: A dictionary containing the description statistics of the input image. \"\"\" import geemap.utils as utils if not isinstance ( img , ee . Image ): print ( 'The input object must be an ee.Image' ) return stat_types = [ 'min' , 'max' , 'mean' , 'std' , 'sum' ] image_min = utils . image_min_value ( img , region , scale ) image_max = utils . image_max_value ( img , region , scale ) image_mean = utils . image_mean_value ( img , region , scale ) image_std = utils . image_std_value ( img , region , scale ) image_sum = utils . image_sum_value ( img , region , scale ) stat_results = ee . List ( [ image_min , image_max , image_mean , image_std , image_sum ]) stats = ee . Dictionary . fromLists ( stat_types , stat_results ) return stats in_colab_shell () Tests if the code is being executed within Google Colab. Source code in geemap/geemap.py def in_colab_shell (): \"\"\"Tests if the code is being executed within Google Colab.\"\"\" try : import google.colab # pylint: disable=unused-variable return True except ImportError : return False install_from_github ( url ) Install a package from a GitHub repository. Parameters: Name Type Description Default url str The URL of the GitHub repository. required Source code in geemap/geemap.py def install_from_github ( url ): \"\"\"Install a package from a GitHub repository. Args: url (str): The URL of the GitHub repository. \"\"\" try : download_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) if not os . path . exists ( download_dir ): os . makedirs ( download_dir ) repo_name = os . path . basename ( url ) zip_url = os . path . join ( url , 'archive/master.zip' ) filename = repo_name + '-master.zip' download_from_url ( url = zip_url , out_file_name = filename , out_dir = download_dir , unzip = True ) pkg_dir = os . path . join ( download_dir , repo_name + '-master' ) pkg_name = os . path . basename ( url ) work_dir = os . getcwd () os . chdir ( pkg_dir ) print ( 'Installing {} ...' . format ( pkg_name )) cmd = 'pip install .' os . system ( cmd ) os . chdir ( work_dir ) print ( ' {} has been installed successfully.' . format ( pkg_name )) # print(\"\\nPlease comment out 'install_from_github()' and restart the kernel to take effect:\\nJupyter menu -> Kernel -> Restart & Clear Output\") except Exception as e : print ( e ) is_drive_mounted () Checks whether Google Drive is mounted in Google Colab. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/geemap.py def is_drive_mounted (): \"\"\"Checks whether Google Drive is mounted in Google Colab. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" drive_path = '/content/drive/My Drive' if os . path . exists ( drive_path ): return True else : return False is_latlon_valid ( location ) Checks whether a pair of coordinates is valid. Parameters: Name Type Description Default location str A pair of latlon coordinates separated by comma or space. required Returns: Type Description bool Returns True if valid. Source code in geemap/geemap.py def is_latlon_valid ( location ): \"\"\"Checks whether a pair of coordinates is valid. Args: location (str): A pair of latlon coordinates separated by comma or space. Returns: bool: Returns True if valid. \"\"\" latlon = [] if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return False try : lat , lon = float ( latlon [ 0 ]), float ( latlon [ 1 ]) if lat >= - 90 and lat <= 90 and lon >= - 180 and lat <= 180 : return True else : return False except Exception as e : print ( e ) return False is_tool ( name ) Check whether name is on PATH and marked as executable. Source code in geemap/geemap.py def is_tool ( name ): \"\"\"Check whether `name` is on PATH and marked as executable.\"\"\" from shutil import which return which ( name ) is not None landsat_timeseries ( roi = None , start_year = 1984 , end_year = 2020 , start_date = '06-10' , end_date = '09-20' , apply_fmask = True ) Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Parameters: Name Type Description Default roi object Region of interest to create the timelapse. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 1984. 1984 end_year int Ending year for the timelapse. Defaults to 2020. 2020 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. '06-10' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. '09-20' apply_fmask bool Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. True Returns: Type Description object Returns an ImageCollection containing annual Landsat images. Source code in geemap/geemap.py def landsat_timeseries ( roi = None , start_year = 1984 , end_year = 2020 , start_date = '06-10' , end_date = '09-20' , apply_fmask = True ): \"\"\"Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Args: roi (object, optional): Region of interest to create the timelapse. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 1984. end_year (int, optional): Ending year for the timelapse. Defaults to 2020. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. Returns: object: Returns an ImageCollection containing annual Landsat images. \"\"\" ################################################################################ # Input and output parameters. import re import datetime if roi is None : roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return ################################################################################ # Setup vars to get dates. if isinstance ( start_year , int ) and ( start_year >= 1984 ) and ( start_year < 2020 ): pass else : print ( 'The start year must be an integer >= 1984.' ) return if isinstance ( end_year , int ) and ( end_year > 1984 ) and ( end_year <= 2020 ): pass else : print ( 'The end year must be an integer <= 2020.' ) return if re . match ( \"[0-9] {2} \\-[0-9] {2} \" , start_date ) and re . match ( \"[0-9] {2} \\-[0-9] {2} \" , end_date ): pass else : print ( 'The start date and end date must be month-day, such as 06-10, 09-20' ) return try : datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) except Exception as e : print ( 'The input dates are invalid.' ) return def days_between ( d1 , d2 ): d1 = datetime . datetime . strptime ( d1 , \"%Y-%m- %d \" ) d2 = datetime . datetime . strptime ( d2 , \"%Y-%m- %d \" ) return abs (( d2 - d1 ) . days ) n_days = days_between ( str ( start_year ) + '-' + start_date , str ( start_year ) + '-' + end_date ) start_month = int ( start_date [: 2 ]) start_day = int ( start_date [ 3 : 5 ]) start_date = str ( start_year ) + '-' + start_date end_date = str ( end_year ) + '-' + end_date # Define a collection filter by date, bounds, and quality. def colFilter ( col , aoi ): # , startDate, endDate): return ( col . filterBounds ( aoi )) # Landsat collection preprocessingEnabled # Get Landsat surface reflectance collections for OLI, ETM+ and TM sensors. LC08col = ee . ImageCollection ( 'LANDSAT/LC08/C01/T1_SR' ) LE07col = ee . ImageCollection ( 'LANDSAT/LE07/C01/T1_SR' ) LT05col = ee . ImageCollection ( 'LANDSAT/LT05/C01/T1_SR' ) LT04col = ee . ImageCollection ( 'LANDSAT/LT04/C01/T1_SR' ) # Define a collection filter by date, bounds, and quality. def colFilter ( col , roi , start_date , end_date ): return ( col . filterBounds ( roi ) . filterDate ( start_date , end_date )) # .filter('CLOUD_COVER < 5') # .filter('GEOMETRIC_RMSE_MODEL < 15') # .filter('IMAGE_QUALITY == 9 || IMAGE_QUALITY_OLI == 9')) # Function to get and rename bands of interest from OLI. def renameOli ( img ): return ( img . select ( [ 'B2' , 'B3' , 'B4' , 'B5' , 'B6' , 'B7' , 'pixel_qa' ], [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ])) # Function to get and rename bands of interest from ETM+. def renameEtm ( img ): return ( img . select ( [ 'B1' , 'B2' , 'B3' , 'B4' , 'B5' , 'B7' , 'pixel_qa' ], [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ])) # Add NBR for LandTrendr segmentation. def calcNbr ( img ): return ( img . addBands ( img . normalizedDifference ([ 'NIR' , 'SWIR2' ]) . multiply ( - 10000 ) . rename ( 'NBR' )) . int16 ()) # Define function to mask out clouds and cloud shadows in images. # Use CFmask band included in USGS Landsat SR image product. def fmask ( img ): cloudShadowBitMask = 1 << 3 cloudsBitMask = 1 << 5 qa = img . select ( 'pixel_qa' ) mask = qa . bitwiseAnd ( cloudShadowBitMask ) . eq ( 0 ) \\ . And ( qa . bitwiseAnd ( cloudsBitMask ) . eq ( 0 )) return ( img . updateMask ( mask )) # Define function to prepare OLI images. def prepOli ( img ): orig = img img = renameOli ( img ) if apply_fmask : img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Define function to prepare ETM+ images. def prepEtm ( img ): orig = img img = renameEtm ( img ) if apply_fmask : img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Get annual median collection. def getAnnualComp ( y ): startDate = ee . Date . fromYMD ( ee . Number ( y ), ee . Number ( start_month ), ee . Number ( start_day )) endDate = startDate . advance ( ee . Number ( n_days ), 'day' ) # Filter collections and prepare them for merging. LC08coly = colFilter ( LC08col , roi , startDate , endDate ) . map ( prepOli ) LE07coly = colFilter ( LE07col , roi , startDate , endDate ) . map ( prepEtm ) LT05coly = colFilter ( LT05col , roi , startDate , endDate ) . map ( prepEtm ) LT04coly = colFilter ( LT04col , roi , startDate , endDate ) . map ( prepEtm ) # Merge the collections. col = LC08coly . merge ( LE07coly ) . merge ( LT05coly ) . merge ( LT04coly ) yearImg = col . median () nBands = yearImg . bandNames () . size () yearImg = ee . Image ( ee . Algorithms . If ( nBands , yearImg , dummyImg )) return ( calcNbr ( yearImg ) . set ({ 'year' : y , 'system:time_start' : startDate . millis (), 'nBands' : nBands })) ################################################################################ # Make a dummy image for missing years. bandNames = ee . List ([ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ]) fillerValues = ee . List . repeat ( 0 , bandNames . size ()) dummyImg = ee . Image . constant ( fillerValues ) . rename ( bandNames ) \\ . selfMask () . int16 () ################################################################################ # Get a list of years years = ee . List . sequence ( start_year , end_year ) ################################################################################ # Make list of annual image composites. imgList = years . map ( getAnnualComp ) # Convert image composite list to collection imgCol = ee . ImageCollection . fromImages ( imgList ) imgCol = imgCol . map ( lambda img : img . clip ( roi ) . set ({ 'coordinates' : roi . coordinates ()})) return imgCol landsat_ts_gif ( roi = None , out_gif = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' , bands = [ 'NIR' , 'Red' , 'Green' ], vis_params = None , dimensions = 768 , frames_per_second = 10 , apply_fmask = True , nd_bands = None , nd_threshold = 0 , nd_palette = [ 'black' , 'blue' ]) Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work. Parameters: Name Type Description Default roi object Region of interest to create the timelapse. Defaults to None. None out_gif str File path to the output animated GIF. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 1984. 1984 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. '06-10' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. '09-20' bands list Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. ['NIR', 'Red', 'Green'] vis_params dict Visualization parameters. Defaults to None. None dimensions int a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. 768 frames_per_second int Animation speed. Defaults to 10. 10 apply_fmask bool Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. True nd_bands list A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1). None nd_threshold float The threshold for extacting pixels from the normalized difference band. 0 nd_palette list The color palette to use for displaying the normalized difference band. ['black', 'blue'] Returns: Type Description str File path to the output GIF image. Source code in geemap/geemap.py def landsat_ts_gif ( roi = None , out_gif = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' , bands = [ 'NIR' , 'Red' , 'Green' ], vis_params = None , dimensions = 768 , frames_per_second = 10 , apply_fmask = True , nd_bands = None , nd_threshold = 0 , nd_palette = [ 'black' , 'blue' ]): \"\"\"Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work. Args: roi (object, optional): Region of interest to create the timelapse. Defaults to None. out_gif (str, optional): File path to the output animated GIF. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 1984. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. bands (list, optional): Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. vis_params (dict, optional): Visualization parameters. Defaults to None. dimensions (int, optional): a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. frames_per_second (int, optional): Animation speed. Defaults to 10. apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. nd_bands (list, optional): A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1). nd_threshold (float, optional): The threshold for extacting pixels from the normalized difference band. nd_palette (list, optional): The color palette to use for displaying the normalized difference band. Returns: str: File path to the output GIF image. \"\"\" # ee_initialize() if roi is None : roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) elif isinstance ( roi , ee . Feature ) or isinstance ( roi , ee . FeatureCollection ): roi = roi . geometry () elif isinstance ( roi , ee . Geometry ): pass else : print ( 'The provided roi is invalid. It must be an ee.Geometry' ) return if out_gif is None : out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) filename = 'landsat_ts_' + random_string () + '.gif' out_gif = os . path . join ( out_dir , filename ) elif not out_gif . endswith ( '.gif' ): print ( 'The output file must end with .gif' ) return # elif not os.path.isfile(out_gif): # print('The output file must be a file') # return else : out_gif = os . path . abspath ( out_gif ) out_dir = os . path . dirname ( out_gif ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) allowed_bands = [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ] if len ( bands ) == 3 and all ( x in allowed_bands for x in bands ): pass else : raise Exception ( 'You can only select 3 bands from the following: {} ' . format ( ', ' . join ( allowed_bands ))) if nd_bands is not None : if len ( nd_bands ) == 2 and all ( x in allowed_bands [: - 1 ] for x in nd_bands ): pass else : raise Exception ( 'You can only select two bands from the following: {} ' . format ( ', ' . join ( allowed_bands [: - 1 ]))) try : col = landsat_timeseries ( roi , start_year , end_year , start_date , end_date , apply_fmask ) if vis_params is None : vis_params = {} vis_params [ 'bands' ] = bands vis_params [ 'min' ] = 0 vis_params [ 'max' ] = 4000 vis_params [ 'gamma' ] = [ 1 , 1 , 1 ] video_args = vis_params . copy () video_args [ 'dimensions' ] = dimensions video_args [ 'region' ] = roi video_args [ 'framesPerSecond' ] = frames_per_second video_args [ 'crs' ] = 'EPSG:3857' if 'bands' not in video_args . keys (): video_args [ 'bands' ] = bands if 'min' not in video_args . keys (): video_args [ 'min' ] = 0 if 'max' not in video_args . keys (): video_args [ 'max' ] = 4000 if 'gamma' not in video_args . keys (): video_args [ 'gamma' ] = [ 1 , 1 , 1 ] download_ee_video ( col , video_args , out_gif ) if nd_bands is not None : nd_images = landsat_ts_norm_diff ( col , bands = nd_bands , threshold = nd_threshold ) out_nd_gif = out_gif . replace ( '.gif' , '_nd.gif' ) landsat_ts_norm_diff_gif ( nd_images , out_gif = out_nd_gif , vis_params = None , palette = nd_palette , dimensions = dimensions , frames_per_second = frames_per_second ) return out_gif except Exception as e : print ( e ) landsat_ts_norm_diff ( collection , bands = [ 'Green' , 'SWIR1' ], threshold = 0 ) Computes a normalized difference index based on a Landsat timeseries. Parameters: Name Type Description Default collection ee.ImageCollection A Landsat timeseries. required bands list The bands to use for computing normalized difference. Defaults to ['Green', 'SWIR1']. ['Green', 'SWIR1'] threshold float The threshold to extract features. Defaults to 0. 0 Returns: Type Description ee.ImageCollection An ImageCollection containing images with values greater than the specified threshold. Source code in geemap/geemap.py def landsat_ts_norm_diff ( collection , bands = [ 'Green' , 'SWIR1' ], threshold = 0 ): \"\"\"Computes a normalized difference index based on a Landsat timeseries. Args: collection (ee.ImageCollection): A Landsat timeseries. bands (list, optional): The bands to use for computing normalized difference. Defaults to ['Green', 'SWIR1']. threshold (float, optional): The threshold to extract features. Defaults to 0. Returns: ee.ImageCollection: An ImageCollection containing images with values greater than the specified threshold. \"\"\" nd_images = collection . map ( lambda img : img . normalizedDifference ( bands ) . gt ( threshold ) . copyProperties ( img , img . propertyNames ())) return nd_images landsat_ts_norm_diff_gif ( collection , out_gif = None , vis_params = None , palette = [ 'black' , 'blue' ], dimensions = 768 , frames_per_second = 10 ) [summary] Parameters: Name Type Description Default collection ee.ImageCollection The normalized difference Landsat timeseires. required out_gif str File path to the output animated GIF. Defaults to None. None vis_params dict Visualization parameters. Defaults to None. None palette list The palette to use for visualizing the timelapse. Defaults to ['black', 'blue']. The first color in the list is the background color. ['black', 'blue'] dimensions int a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. 768 frames_per_second int Animation speed. Defaults to 10. 10 Returns: Type Description str File path to the output animated GIF. Source code in geemap/geemap.py def landsat_ts_norm_diff_gif ( collection , out_gif = None , vis_params = None , palette = [ 'black' , 'blue' ], dimensions = 768 , frames_per_second = 10 ): \"\"\"[summary] Args: collection (ee.ImageCollection): The normalized difference Landsat timeseires. out_gif (str, optional): File path to the output animated GIF. Defaults to None. vis_params (dict, optional): Visualization parameters. Defaults to None. palette (list, optional): The palette to use for visualizing the timelapse. Defaults to ['black', 'blue']. The first color in the list is the background color. dimensions (int, optional): a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. frames_per_second (int, optional): Animation speed. Defaults to 10. Returns: str: File path to the output animated GIF. \"\"\" coordinates = ee . Image ( collection . first ()) . get ( 'coordinates' ) roi = ee . Geometry . Polygon ( coordinates , None , False ) if out_gif is None : out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) filename = 'landsat_ts_nd_' + random_string () + '.gif' out_gif = os . path . join ( out_dir , filename ) elif not out_gif . endswith ( '.gif' ): raise Exception ( 'The output file must end with .gif' ) bands = [ 'nd' ] if vis_params is None : vis_params = {} vis_params [ 'bands' ] = bands vis_params [ 'palette' ] = palette video_args = vis_params . copy () video_args [ 'dimensions' ] = dimensions video_args [ 'region' ] = roi video_args [ 'framesPerSecond' ] = frames_per_second video_args [ 'crs' ] = 'EPSG:3857' if 'bands' not in video_args . keys (): video_args [ 'bands' ] = bands download_ee_video ( collection , video_args , out_gif ) return out_gif latlon_from_text ( location ) Extracts latlon from text. Parameters: Name Type Description Default location str A pair of latlon coordinates separated by comma or space. required Returns: Type Description bool Returns (lat, lon) if valid. Source code in geemap/geemap.py def latlon_from_text ( location ): \"\"\"Extracts latlon from text. Args: location (str): A pair of latlon coordinates separated by comma or space. Returns: bool: Returns (lat, lon) if valid. \"\"\" latlon = [] try : if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return None lat , lon = latlon [ 0 ], latlon [ 1 ] if lat >= - 90 and lat <= 90 and lon >= - 180 and lat <= 180 : return lat , lon else : return None except Exception as e : print ( e ) print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return None legend_from_ee ( ee_class_table ) Extract legend from an Earth Engine class table on the Earth Engine Data Catalog page such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1 Value Color Description 0 1c0dff Water 1 05450a Evergreen needleleaf forest 2 086a10 Evergreen broadleaf forest 3 54a708 Deciduous needleleaf forest 4 78d203 Deciduous broadleaf forest 5 009900 Mixed forest 6 c6b044 Closed shrublands 7 dcd159 Open shrublands 8 dade48 Woody savannas 9 fbff13 Savannas 10 b6ff05 Grasslands 11 27ff87 Permanent wetlands 12 c24f44 Croplands 13 a5a5a5 Urban and built-up 14 ff6d4c Cropland/natural vegetation mosaic 15 69fff8 Snow and ice 16 f9ffa4 Barren or sparsely vegetated 254 ffffff Unclassified Parameters: Name Type Description Default ee_class_table str An Earth Engine class table with triple quotes. required Returns: Type Description dict Returns a legend dictionary that can be used to create a legend. Source code in geemap/geemap.py def legend_from_ee ( ee_class_table ): \"\"\"Extract legend from an Earth Engine class table on the Earth Engine Data Catalog page such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1 Value Color Description 0 1c0dff Water 1 05450a Evergreen needleleaf forest 2 086a10 Evergreen broadleaf forest 3 54a708 Deciduous needleleaf forest 4 78d203 Deciduous broadleaf forest 5 009900 Mixed forest 6 c6b044 Closed shrublands 7 dcd159 Open shrublands 8 dade48 Woody savannas 9 fbff13 Savannas 10 b6ff05 Grasslands 11 27ff87 Permanent wetlands 12 c24f44 Croplands 13 a5a5a5 Urban and built-up 14 ff6d4c Cropland/natural vegetation mosaic 15 69fff8 Snow and ice 16 f9ffa4 Barren or sparsely vegetated 254 ffffff Unclassified Args: ee_class_table (str): An Earth Engine class table with triple quotes. Returns: dict: Returns a legend dictionary that can be used to create a legend. \"\"\" try : ee_class_table = ee_class_table . strip () lines = ee_class_table . split ( ' \\n ' )[ 1 :] if lines [ 0 ] == 'Value \\t Color \\t Description' : lines = lines [ 1 :] legend_dict = {} for index , line in enumerate ( lines ): items = line . split ( \" \\t \" ) items = [ item . strip () for item in items ] color = items [ 1 ] key = items [ 0 ] + \" \" + items [ 2 ] legend_dict [ key ] = color return legend_dict except Exception as e : print ( e ) load_GeoTIFF ( URL ) Loads a Cloud Optimized GeoTIFF (COG) as an Image. Only Google Cloud Storage is supported. The URL can be one of the following formats: Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF Parameters: Name Type Description Default URL str The Cloud Storage URL of the GeoTIFF to load. required Returns: Type Description ee.Image an Earth Engine image. Source code in geemap/geemap.py def load_GeoTIFF ( URL ): \"\"\"Loads a Cloud Optimized GeoTIFF (COG) as an Image. Only Google Cloud Storage is supported. The URL can be one of the following formats: Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF Args: URL (str): The Cloud Storage URL of the GeoTIFF to load. Returns: ee.Image: an Earth Engine image. \"\"\" uri = URL . strip () if uri . startswith ( 'https://storage.googleapis.com/' ): uri = uri . replace ( 'https://storage.googleapis.com/' , 'gs://' ) elif uri . startswith ( 'https://storage.cloud.google.com/' ): uri = uri . replace ( 'https://storage.cloud.google.com/' , 'gs://' ) if not uri . startswith ( 'gs://' ): raise Exception ( 'Invalid GCS URL: {} . Expected something of the form \"gs://bucket/path/to/object.tif\".' . format ( uri )) if not uri . lower () . endswith ( '.tif' ): raise Exception ( 'Invalid GCS URL: {} . Expected something of the form \"gs://bucket/path/to/object.tif\".' . format ( uri )) cloud_image = ee . Image . loadGeoTIFF ( uri ) return cloud_image load_GeoTIFFs ( URLs ) Loads a list of Cloud Optimized GeoTIFFs (COG) as an ImageCollection. URLs is a list of URL, which can be one of the following formats: Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF Parameters: Name Type Description Default URLs list A list of Cloud Storage URL of the GeoTIFF to load. required Returns: Type Description ee.ImageCollection An Earth Engine ImageCollection. Source code in geemap/geemap.py def load_GeoTIFFs ( URLs ): \"\"\"Loads a list of Cloud Optimized GeoTIFFs (COG) as an ImageCollection. URLs is a list of URL, which can be one of the following formats: Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF Args: URLs (list): A list of Cloud Storage URL of the GeoTIFF to load. Returns: ee.ImageCollection: An Earth Engine ImageCollection. \"\"\" if not isinstance ( URLs , list ): raise Exception ( 'The URLs argument must be a list.' ) URIs = [] for URL in URLs : uri = URL . strip () if uri . startswith ( 'https://storage.googleapis.com/' ): uri = uri . replace ( 'https://storage.googleapis.com/' , 'gs://' ) elif uri . startswith ( 'https://storage.cloud.google.com/' ): uri = uri . replace ( 'https://storage.cloud.google.com/' , 'gs://' ) if not uri . startswith ( 'gs://' ): raise Exception ( 'Invalid GCS URL: {} . Expected something of the form \"gs://bucket/path/to/object.tif\".' . format ( uri )) if not uri . lower () . endswith ( '.tif' ): raise Exception ( 'Invalid GCS URL: {} . Expected something of the form \"gs://bucket/path/to/object.tif\".' . format ( uri )) URIs . append ( uri ) URIs = ee . List ( URIs ) collection = URIs . map ( lambda uri : ee . Image . loadGeoTIFF ( uri )) return ee . ImageCollection ( collection ) minimum_bounding_box ( geojson ) Gets the minimum bounding box for a geojson polygon. Parameters: Name Type Description Default geojson dict A geojson dictionary. required Returns: Type Description tuple Returns a tuple containing the minimum bounding box in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -120)). Source code in geemap/geemap.py def minimum_bounding_box ( geojson ): \"\"\"Gets the minimum bounding box for a geojson polygon. Args: geojson (dict): A geojson dictionary. Returns: tuple: Returns a tuple containing the minimum bounding box in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -120)). \"\"\" coordinates = [] try : if 'geometry' in geojson . keys (): coordinates = geojson [ 'geometry' ][ 'coordinates' ][ 0 ] else : coordinates = geojson [ 'coordinates' ][ 0 ] lower_left = min ([ x [ 1 ] for x in coordinates ]), min ( [ x [ 0 ] for x in coordinates ]) # (lat, lon) upper_right = max ([ x [ 1 ] for x in coordinates ]), max ([ x [ 0 ] for x in coordinates ]) # (lat, lon) bounds = ( lower_left , upper_right ) return bounds except Exception as e : # print(e) return None naip_timeseries ( roi = None , start_year = 2009 , end_year = 2018 ) Creates NAIP annual timeseries Parameters: Name Type Description Default roi object An ee.Geometry representing the region of interest. Defaults to None. None start_year int Starting year for the timeseries. Defaults to2009. 2009 end_year int Ending year for the timeseries. Defaults to 2018. 2018 Returns: Type Description object An ee.ImageCollection representing annual NAIP imagery. Source code in geemap/geemap.py def naip_timeseries ( roi = None , start_year = 2009 , end_year = 2018 ): \"\"\"Creates NAIP annual timeseries Args: roi (object, optional): An ee.Geometry representing the region of interest. Defaults to None. start_year (int, optional): Starting year for the timeseries. Defaults to2009. end_year (int, optional): Ending year for the timeseries. Defaults to 2018. Returns: object: An ee.ImageCollection representing annual NAIP imagery. \"\"\" # ee_initialize() try : def get_annual_NAIP ( year ): try : collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) if roi is not None : collection = collection . filterBounds ( roi ) start_date = ee . Date . fromYMD ( year , 1 , 1 ) end_date = ee . Date . fromYMD ( year , 12 , 31 ) naip = collection . filterDate ( start_date , end_date ) \\ . filter ( ee . Filter . listContains ( \"system:band_names\" , \"N\" )) naip = ee . Image ( ee . ImageCollection ( naip ) . mosaic ()) return naip except Exception as e : print ( e ) years = ee . List . sequence ( start_year , end_year ) collection = years . map ( get_annual_NAIP ) return collection except Exception as e : print ( e ) open_github ( subdir = None ) Opens the GitHub repository for this package. Parameters: Name Type Description Default subdir str Sub-directory of the repository. Defaults to None. None Source code in geemap/geemap.py def open_github ( subdir = None ): \"\"\"Opens the GitHub repository for this package. Args: subdir (str, optional): Sub-directory of the repository. Defaults to None. \"\"\" import webbrowser url = 'https://github.com/giswqs/geemap' if subdir == 'source' : url += '/tree/master/geemap/' elif subdir == 'examples' : url += '/tree/master/examples' elif subdir == 'tutorials' : url += '/tree/master/tutorials' webbrowser . open_new_tab ( url ) open_image_from_url ( url ) Loads an image from the specified URL. Parameters: Name Type Description Default url str URL of the image. required Returns: Type Description object Image object. Source code in geemap/geemap.py def open_image_from_url ( url ): \"\"\"Loads an image from the specified URL. Args: url (str): URL of the image. Returns: object: Image object. \"\"\" from PIL import Image import requests from io import BytesIO from urllib.parse import urlparse try : # if url.endswith('.gif'): # out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') # if not os.path.exists(out_dir): # os.makedirs(out_dir) # a = urlparse(url) # out_name = os.path.basename(a.path) # out_path = os.path.join(out_dir, out_name) # download_from_url(url, out_name, out_dir, unzip=False) # img = Image.open(out_path) # else: response = requests . get ( url ) img = Image . open ( BytesIO ( response . content )) return img except Exception as e : print ( e ) open_youtube () Opens the YouTube tutorials for geemap. Source code in geemap/geemap.py def open_youtube (): \"\"\"Opens the YouTube tutorials for geemap. \"\"\" import webbrowser url = 'https://www.youtube.com/playlist?list=PLAxJ4-o7ZoPccOFv1dCwvGI6TYnirRTg3' webbrowser . open_new_tab ( url ) read_api_csv () Extracts Earth Engine API from a csv file and returns a dictionary containing information about each function. Returns: Type Description dict The dictionary containing information about each function, including name, description, function form, return type, arguments, html. Source code in geemap/geemap.py def read_api_csv (): \"\"\"Extracts Earth Engine API from a csv file and returns a dictionary containing information about each function. Returns: dict: The dictionary containing information about each function, including name, description, function form, return type, arguments, html. \"\"\" import copy import csv pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) data_dir = os . path . join ( pkg_dir , 'data' ) template_dir = os . path . join ( data_dir , 'template' ) csv_file = os . path . join ( template_dir , 'ee_api_docs.csv' ) html_file = os . path . join ( template_dir , 'ee_api_docs.html' ) with open ( html_file ) as f : in_html_lines = f . readlines () api_dict = {} with open ( csv_file , 'r' , encoding = 'utf-8' ) as f : csv_reader = csv . DictReader ( f , delimiter = ' \\t ' ) for line in csv_reader : out_html_lines = copy . copy ( in_html_lines ) out_html_lines [ 65 ] = in_html_lines [ 65 ] . replace ( 'function_name' , line [ 'name' ]) out_html_lines [ 66 ] = in_html_lines [ 66 ] . replace ( 'function_description' , line . get ( 'description' )) out_html_lines [ 74 ] = in_html_lines [ 74 ] . replace ( 'function_usage' , line . get ( 'function' )) out_html_lines [ 75 ] = in_html_lines [ 75 ] . replace ( 'function_returns' , line . get ( 'returns' )) arguments = line . get ( 'argument' ) types = line . get ( 'type' ) details = line . get ( 'details' ) if '|' in arguments : argument_items = arguments . split ( '|' ) else : argument_items = [ arguments ] if '|' in types : types_items = types . split ( '|' ) else : types_items = [ types ] if '|' in details : details_items = details . split ( '|' ) else : details_items = [ details ] out_argument_lines = [] for index in range ( len ( argument_items )): in_argument_lines = in_html_lines [ 87 : 92 ] in_argument_lines [ 1 ] = in_argument_lines [ 1 ] . replace ( 'function_argument' , argument_items [ index ]) in_argument_lines [ 2 ] = in_argument_lines [ 2 ] . replace ( 'function_type' , types_items [ index ]) in_argument_lines [ 3 ] = in_argument_lines [ 3 ] . replace ( 'function_details' , details_items [ index ]) out_argument_lines . append ( \"\" . join ( in_argument_lines )) out_html_lines = out_html_lines [: 87 ] + \\ out_argument_lines + out_html_lines [ 92 :] contents = '' . join ( out_html_lines ) api_dict [ line [ 'name' ]] = { 'description' : line . get ( 'description' ), 'function' : line . get ( 'function' ), 'returns' : line . get ( 'returns' ), 'argument' : line . get ( 'argument' ), 'type' : line . get ( 'type' ), 'details' : line . get ( 'details' ), 'html' : contents } return api_dict reduce_gif_size ( in_gif , out_gif = None ) Reduces a GIF image using ffmpeg. Parameters: Name Type Description Default in_gif str The input file path to the GIF image. required out_gif str The output file path to the GIF image. Defaults to None. None Source code in geemap/geemap.py def reduce_gif_size ( in_gif , out_gif = None ): \"\"\"Reduces a GIF image using ffmpeg. Args: in_gif (str): The input file path to the GIF image. out_gif (str, optional): The output file path to the GIF image. Defaults to None. \"\"\" import ffmpeg import shutil if not is_tool ( 'ffmpeg' ): print ( 'ffmpeg is not installed on your computer.' ) return if not os . path . exists ( in_gif ): print ( 'The input gif file does not exist.' ) return if out_gif is None : out_gif = in_gif elif not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) if in_gif == out_gif : tmp_gif = in_gif . replace ( '.gif' , '_tmp.gif' ) shutil . copyfile ( in_gif , tmp_gif ) stream = ffmpeg . input ( tmp_gif ) stream = ffmpeg . output ( stream , in_gif ) . overwrite_output () ffmpeg . run ( stream ) os . remove ( tmp_gif ) else : stream = ffmpeg . input ( in_gif ) stream = ffmpeg . output ( stream , out_gif ) . overwrite_output () ffmpeg . run ( stream ) rgb_to_hex ( rgb = ( 255 , 255 , 255 )) Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255. Parameters: Name Type Description Default rgb tuple RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255). (255, 255, 255) Returns: Type Description str hex color code Source code in geemap/geemap.py def rgb_to_hex ( rgb = ( 255 , 255 , 255 )): \"\"\"Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255. Args: rgb (tuple, optional): RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255). Returns: str: hex color code \"\"\" return ' %02x%02x%02x ' % rgb screen_capture ( outfile , monitor = 1 ) Takes a full screenshot of the selected monitor. Parameters: Name Type Description Default outfile str The output file path to the screenshot. required monitor int The monitor to take the screenshot. Defaults to 1. 1 Source code in geemap/geemap.py def screen_capture ( outfile , monitor = 1 ): \"\"\"Takes a full screenshot of the selected monitor. Args: outfile (str): The output file path to the screenshot. monitor (int, optional): The monitor to take the screenshot. Defaults to 1. \"\"\" from mss import mss out_dir = os . path . dirname ( outfile ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) if not isinstance ( monitor , int ): print ( 'The monitor number must be an integer.' ) return try : with mss () as sct : sct . shot ( output = outfile , mon = monitor ) return outfile except Exception as e : print ( e ) search_api_tree ( keywords , api_tree ) Search Earth Engine API and return functions containing the specified keywords Parameters: Name Type Description Default keywords str The keywords to search for. required api_tree dict The dictionary containing the Earth Engine API tree. required Returns: Type Description object An ipytree object/widget. Source code in geemap/geemap.py def search_api_tree ( keywords , api_tree ): \"\"\"Search Earth Engine API and return functions containing the specified keywords Args: keywords (str): The keywords to search for. api_tree (dict): The dictionary containing the Earth Engine API tree. Returns: object: An ipytree object/widget. \"\"\" import warnings warnings . filterwarnings ( 'ignore' ) sub_tree = Tree () for key in api_tree . keys (): if keywords in key : sub_tree . add_node ( api_tree [ key ]) return sub_tree search_ee_data ( keywords ) Searches Earth Engine data catalog. Parameters: Name Type Description Default keywords str Keywords to search for can be id, provider, tag and so on required Returns: Type Description list Returns a lit of assets. Source code in geemap/geemap.py def search_ee_data ( keywords ): \"\"\"Searches Earth Engine data catalog. Args: keywords (str): Keywords to search for can be id, provider, tag and so on Returns: list: Returns a lit of assets. \"\"\" try : cmd = 'geeadd search --keywords \" {} \"' . format ( str ( keywords )) output = os . popen ( cmd ) . read () start_index = output . index ( '[' ) assets = eval ( output [ start_index :]) results = [] for asset in assets : asset_dates = asset [ 'start_date' ] + ' - ' + asset [ 'end_date' ] asset_snippet = asset [ 'ee_id_snippet' ] start_index = asset_snippet . index ( \"'\" ) + 1 end_index = asset_snippet . index ( \"'\" , start_index ) asset_id = asset_snippet [ start_index : end_index ] asset [ 'dates' ] = asset_dates asset [ 'id' ] = asset_id asset [ 'uid' ] = asset_id . replace ( '/' , '_' ) # asset['url'] = 'https://developers.google.com/earth-engine/datasets/catalog/' + asset['uid'] # asset['thumbnail'] = 'https://mw1.google.com/ges/dd/images/{}_sample.png'.format( # asset['uid']) results . append ( asset ) return results except Exception as e : print ( e ) sentinel2_timeseries ( roi = None , start_year = 2015 , end_year = 2019 , start_date = '01-01' , end_date = '12-31' ) Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Images include both level 1C and level 2A imagery. Parameters: Name Type Description Default roi object Region of interest to create the timelapse. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 2015. 2015 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'. '01-01' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'. '12-31' Returns: Type Description object Returns an ImageCollection containing annual Sentinel 2 images. Source code in geemap/geemap.py def sentinel2_timeseries ( roi = None , start_year = 2015 , end_year = 2019 , start_date = '01-01' , end_date = '12-31' ): \"\"\"Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Images include both level 1C and level 2A imagery. Args: roi (object, optional): Region of interest to create the timelapse. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 2015. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'. Returns: object: Returns an ImageCollection containing annual Sentinel 2 images. \"\"\" ################################################################################ ################################################################################ # Input and output parameters. import re import datetime # ee_initialize() if roi is None : # roi = ee.Geometry.Polygon( # [[[-180, -80], # [-180, 80], # [180, 80], # [180, -80], # [-180, -80]]], None, False) roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return # Adjusts longitudes less than -180 degrees or greater than 180 degrees. geojson = ee_to_geojson ( roi ) geojson = adjust_longitude ( geojson ) roi = ee . Geometry ( geojson ) ################################################################################ # Setup vars to get dates. if isinstance ( start_year , int ) and ( start_year >= 2015 ) and ( start_year <= 2020 ): pass else : print ( 'The start year must be an integer >= 2015.' ) return if isinstance ( end_year , int ) and ( end_year >= 2015 ) and ( end_year <= 2020 ): pass else : print ( 'The end year must be an integer <= 2020.' ) return if re . match ( \"[0-9] {2} \\-[0-9] {2} \" , start_date ) and re . match ( \"[0-9] {2} \\-[0-9] {2} \" , end_date ): pass else : print ( 'The start data and end date must be month-day, such as 06-10, 09-20' ) return try : datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) except Exception as e : print ( 'The input dates are invalid.' ) print ( e ) return try : start_test = datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) end_test = datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) if start_test > end_test : raise ValueError ( 'Start date must be prior to end date' ) except Exception as e : print ( e ) return def days_between ( d1 , d2 ): d1 = datetime . datetime . strptime ( d1 , \"%Y-%m- %d \" ) d2 = datetime . datetime . strptime ( d2 , \"%Y-%m- %d \" ) return abs (( d2 - d1 ) . days ) n_days = days_between ( str ( start_year ) + '-' + start_date , str ( start_year ) + '-' + end_date ) start_month = int ( start_date [: 2 ]) start_day = int ( start_date [ 3 : 5 ]) start_date = str ( start_year ) + '-' + start_date end_date = str ( end_year ) + '-' + end_date # Define a collection filter by date, bounds, and quality. def colFilter ( col , aoi ): # , startDate, endDate): return ( col . filterBounds ( aoi )) # Get Sentinel 2 collections, both Level-1C (top of atmophere) and Level-2A (surface reflectance) MSILCcol = ee . ImageCollection ( 'COPERNICUS/S2' ) MSI2Acol = ee . ImageCollection ( 'COPERNICUS/S2_SR' ) # Define a collection filter by date, bounds, and quality. def colFilter ( col , roi , start_date , end_date ): return ( col . filterBounds ( roi ) . filterDate ( start_date , end_date )) # .filter('CLOUD_COVER < 5') # .filter('GEOMETRIC_RMSE_MODEL < 15') # .filter('IMAGE_QUALITY == 9 || IMAGE_QUALITY_OLI == 9')) # Function to get and rename bands of interest from MSI def renameMSI ( img ): return ( img . select ( [ 'B2' , 'B3' , 'B4' , 'B5' , 'B6' , 'B7' , 'B8' , 'B8A' , 'B11' , 'B12' , 'QA60' ], [ 'Blue' , 'Green' , 'Red' , 'Red Edge 1' , 'Red Edge 2' , 'Red Edge 3' , 'NIR' , 'Red Edge 4' , 'SWIR1' , 'SWIR2' , 'QA60' ])) # Add NBR for LandTrendr segmentation. def calcNbr ( img ): return ( img . addBands ( img . normalizedDifference ([ 'NIR' , 'SWIR2' ]) . multiply ( - 10000 ) . rename ( 'NBR' )) . int16 ()) # Define function to mask out clouds and cloud shadows in images. # Use CFmask band included in USGS Landsat SR image product. def fmask ( img ): cloudOpaqueBitMask = 1 << 10 cloudCirrusBitMask = 1 << 11 qa = img . select ( 'QA60' ) mask = qa . bitwiseAnd ( cloudOpaqueBitMask ) . eq ( 0 ) \\ . And ( qa . bitwiseAnd ( cloudCirrusBitMask ) . eq ( 0 )) return ( img . updateMask ( mask )) # Define function to prepare MSI images. def prepMSI ( img ): orig = img img = renameMSI ( img ) img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Get annual median collection. def getAnnualComp ( y ): startDate = ee . Date . fromYMD ( ee . Number ( y ), ee . Number ( start_month ), ee . Number ( start_day )) endDate = startDate . advance ( ee . Number ( n_days ), 'day' ) # Filter collections and prepare them for merging. MSILCcoly = colFilter ( MSILCcol , roi , startDate , endDate ) . map ( prepMSI ) MSI2Acoly = colFilter ( MSI2Acol , roi , startDate , endDate ) . map ( prepMSI ) # Merge the collections. col = MSILCcoly . merge ( MSI2Acoly ) yearImg = col . median () nBands = yearImg . bandNames () . size () yearImg = ee . Image ( ee . Algorithms . If ( nBands , yearImg , dummyImg )) return ( calcNbr ( yearImg ) . set ({ 'year' : y , 'system:time_start' : startDate . millis (), 'nBands' : nBands })) ################################################################################ # Make a dummy image for missing years. bandNames = ee . List ([ 'Blue' , 'Green' , 'Red' , 'Red Edge 1' , 'Red Edge 2' , 'Red Edge 3' , 'NIR' , 'Red Edge 4' , 'SWIR1' , 'SWIR2' , 'QA60' ]) fillerValues = ee . List . repeat ( 0 , bandNames . size ()) dummyImg = ee . Image . constant ( fillerValues ) . rename ( bandNames ) \\ . selfMask () . int16 () ################################################################################ # Get a list of years years = ee . List . sequence ( start_year , end_year ) ################################################################################ # Make list of annual image composites. imgList = years . map ( getAnnualComp ) # Convert image composite list to collection imgCol = ee . ImageCollection . fromImages ( imgList ) imgCol = imgCol . map ( lambda img : img . clip ( roi )) return imgCol set_proxy ( port = 1080 , ip = 'http://127.0.0.1' ) Sets proxy if needed. This is only needed for countries where Google services are not available. Parameters: Name Type Description Default port int The proxy port number. Defaults to 1080. 1080 ip str The IP address. Defaults to 'http://127.0.0.1'. 'http://127.0.0.1' Source code in geemap/geemap.py def set_proxy ( port = 1080 , ip = 'http://127.0.0.1' ): \"\"\"Sets proxy if needed. This is only needed for countries where Google services are not available. Args: port (int, optional): The proxy port number. Defaults to 1080. ip (str, optional): The IP address. Defaults to 'http://127.0.0.1'. \"\"\" import os import requests try : if not ip . startswith ( 'http' ): ip = 'http://' + ip proxy = ' {} : {} ' . format ( ip , port ) os . environ [ 'HTTP_PROXY' ] = proxy os . environ [ 'HTTPS_PROXY' ] = proxy a = requests . get ( 'https://earthengine.google.com/' ) if a . status_code != 200 : print ( 'Failed to connect to Earth Engine. Please double check the port number and ip address.' ) except Exception as e : print ( e ) show_image ( img_path , width = None , height = None ) Shows an image within Jupyter notebook. Parameters: Name Type Description Default img_path str The image file path. required width int Width of the image in pixels. Defaults to None. None height int Height of the image in pixels. Defaults to None. None Source code in geemap/geemap.py def show_image ( img_path , width = None , height = None ): \"\"\"Shows an image within Jupyter notebook. Args: img_path (str): The image file path. width (int, optional): Width of the image in pixels. Defaults to None. height (int, optional): Height of the image in pixels. Defaults to None. \"\"\" from IPython.display import display try : out = widgets . Output () # layout={'border': '1px solid black'}) # layout={'border': '1px solid black', 'width': str(width + 20) + 'px', 'height': str(height + 10) + 'px'},) out . clear_output ( wait = True ) display ( out ) with out : file = open ( img_path , \"rb\" ) image = file . read () if ( width is None ) and ( height is None ): display ( widgets . Image ( value = image )) elif ( width is not None ) and ( height is not None ): display ( widgets . Image ( value = image , width = width , height = height )) else : print ( 'You need set both width and height.' ) return except Exception as e : print ( e ) show_youtube ( id = 'h0pz3S6Tvx0' ) Displays a YouTube video within Jupyter notebooks. Parameters: Name Type Description Default id str Unique ID of the video. Defaults to 'h0pz3S6Tvx0'. 'h0pz3S6Tvx0' Source code in geemap/geemap.py def show_youtube ( id = 'h0pz3S6Tvx0' ): \"\"\"Displays a YouTube video within Jupyter notebooks. Args: id (str, optional): Unique ID of the video. Defaults to 'h0pz3S6Tvx0'. \"\"\" from IPython.display import YouTubeVideo , display try : out = widgets . Output ( layout = { 'width' : '815px' }) # layout={'border': '1px solid black', 'width': '815px'}) out . clear_output ( wait = True ) display ( out ) with out : display ( YouTubeVideo ( id , width = 800 , height = 450 )) except Exception as e : print ( e ) shp_to_ee ( in_shp ) Converts a shapefile to Earth Engine objects. Note that the CRS of the shapefile must be EPSG:4326 Parameters: Name Type Description Default in_shp str File path to a shapefile. required Returns: Type Description object Earth Engine objects representing the shapefile. Source code in geemap/geemap.py def shp_to_ee ( in_shp ): \"\"\"Converts a shapefile to Earth Engine objects. Note that the CRS of the shapefile must be EPSG:4326 Args: in_shp (str): File path to a shapefile. Returns: object: Earth Engine objects representing the shapefile. \"\"\" # ee_initialize() try : json_data = shp_to_geojson ( in_shp ) ee_object = geojson_to_ee ( json_data ) return ee_object except Exception as e : print ( e ) shp_to_geojson ( in_shp , out_json = None ) Converts a shapefile to GeoJSON. Parameters: Name Type Description Default in_shp str File path of the input shapefile. required out_json str File path of the output GeoJSON. Defaults to None. None Returns: Type Description object The json object representing the shapefile. Source code in geemap/geemap.py def shp_to_geojson ( in_shp , out_json = None ): \"\"\"Converts a shapefile to GeoJSON. Args: in_shp (str): File path of the input shapefile. out_json (str, optional): File path of the output GeoJSON. Defaults to None. Returns: object: The json object representing the shapefile. \"\"\" # check_install('pyshp') # ee_initialize() try : import json import shapefile in_shp = os . path . abspath ( in_shp ) if out_json is None : out_json = os . path . splitext ( in_shp )[ 0 ] + \".json\" if os . path . exists ( out_json ): out_json = out_json . replace ( '.json' , '_bk.json' ) elif not os . path . exists ( os . path . dirname ( out_json )): os . makedirs ( os . path . dirname ( out_json )) reader = shapefile . Reader ( in_shp ) fields = reader . fields [ 1 :] field_names = [ field [ 0 ] for field in fields ] buffer = [] for sr in reader . shapeRecords (): atr = dict ( zip ( field_names , sr . record )) geom = sr . shape . __geo_interface__ buffer . append ( dict ( type = \"Feature\" , geometry = geom , properties = atr )) from json import dumps geojson = open ( out_json , \"w\" ) geojson . write ( dumps ({ \"type\" : \"FeatureCollection\" , \"features\" : buffer }, indent = 2 ) + \" \\n \" ) geojson . close () with open ( out_json ) as f : json_data = json . load ( f ) return json_data except Exception as e : print ( e ) system_fonts ( show_full_path = False ) Gets a list of system fonts. # Common font locations: # Linux: /usr/share/fonts/TTF/ # Windows: C:\\Windows\\Fonts # macOS: System > Library > Fonts Parameters: Name Type Description Default show_full_path bool Whether to show the full path of each system font. Defaults to False. False Returns: Type Description list A list of system fonts. Source code in geemap/geemap.py def system_fonts ( show_full_path = False ): \"\"\"Gets a list of system fonts. # Common font locations: # Linux: /usr/share/fonts/TTF/ # Windows: C:\\Windows\\Fonts # macOS: System > Library > Fonts Args: show_full_path (bool, optional): Whether to show the full path of each system font. Defaults to False. Returns: list: A list of system fonts. \"\"\" try : import matplotlib.font_manager font_list = matplotlib . font_manager . findSystemFonts ( fontpaths = None , fontext = 'ttf' ) font_list . sort () font_names = [ os . path . basename ( f ) for f in font_list ] font_names . sort () if show_full_path : return font_list else : return font_names except Exception as e : print ( e ) update_package () Updates the geemap package from the geemap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. Source code in geemap/geemap.py def update_package (): \"\"\"Updates the geemap package from the geemap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. \"\"\" import shutil try : download_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) if not os . path . exists ( download_dir ): os . makedirs ( download_dir ) clone_repo ( out_dir = download_dir ) pkg_dir = os . path . join ( download_dir , 'geemap-master' ) work_dir = os . getcwd () os . chdir ( pkg_dir ) if shutil . which ( 'pip' ) is None : cmd = 'pip3 install .' else : cmd = 'pip install .' os . system ( cmd ) os . chdir ( work_dir ) print ( \" \\n Please comment out 'geemap.update_package()' and restart the kernel to take effect: \\n Jupyter menu -> Kernel -> Restart & Clear Output\" ) except Exception as e : print ( e ) upload_to_imgur ( in_gif ) Uploads an image to imgur.com Parameters: Name Type Description Default in_gif str The file path to the image. required Source code in geemap/geemap.py def upload_to_imgur ( in_gif ): \"\"\"Uploads an image to imgur.com Args: in_gif (str): The file path to the image. \"\"\" import subprocess pkg_name = 'imgur-uploader' if not is_tool ( pkg_name ): check_install ( pkg_name ) try : IMGUR_API_ID = os . environ . get ( 'IMGUR_API_ID' , None ) IMGUR_API_SECRET = os . environ . get ( 'IMGUR_API_SECRET' , None ) credentials_path = os . path . join ( os . path . expanduser ( '~' ), '.config/imgur_uploader/uploader.cfg' ) if (( IMGUR_API_ID is not None ) and ( IMGUR_API_SECRET is not None )) or os . path . exists ( credentials_path ): proc = subprocess . Popen ( [ 'imgur-uploader' , in_gif ], stdout = subprocess . PIPE ) for i in range ( 0 , 2 ): line = proc . stdout . readline () print ( line . rstrip () . decode ( \"utf-8\" )) # while True: # line = proc.stdout.readline() # if not line: # break # print(line.rstrip().decode(\"utf-8\")) else : print ( 'Imgur API credentials could not be found. Please check https://pypi.org/project/imgur-uploader/ for instructions on how to get Imgur API credentials' ) return except Exception as e : print ( e ) zonal_statistics ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'MEAN' , scale = None , crs = None , tile_scale = 1.0 , ** kwargs ) Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Parameters: Name Type Description Default in_value_raster object An ee.Image that contains the values on which to calculate a statistic. required in_zone_vector object An ee.FeatureCollection that defines the zones. required out_file_path str Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz required statistics_type str Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps. 'MEAN' scale float A nominal scale in meters of the projection to work in. Defaults to None. None crs str The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. None tile_scale float A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. 1.0 Source code in geemap/geemap.py def zonal_statistics ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'MEAN' , scale = None , crs = None , tile_scale = 1.0 , ** kwargs ): \"\"\"Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Args: in_value_raster (object): An ee.Image that contains the values on which to calculate a statistic. in_zone_vector (object): An ee.FeatureCollection that defines the zones. out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz statistics_type (str, optional): Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. \"\"\" if not isinstance ( in_value_raster , ee . Image ): print ( 'The input raster must be an ee.Image.' ) return if not isinstance ( in_zone_vector , ee . FeatureCollection ): print ( 'The input zone data must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' ] filename = os . path . abspath ( out_file_path ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () if not ( filetype in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return # Parameters for histogram # The maximum number of buckets to use when building a histogram; will be rounded up to a power of 2. max_buckets = None # The minimum histogram bucket width, or null to allow any power of 2. min_bucket_width = None # The number of values to accumulate before building the initial histogram. max_raw = None hist_min = 1.0 # The lower (inclusive) bound of the first bucket. hist_max = 100.0 # The upper (exclusive) bound of the last bucket. hist_steps = 10 # The number of buckets to use. if 'max_buckets' in kwargs . keys (): max_buckets = kwargs [ 'max_buckets' ] if 'min_bucket_width' in kwargs . keys (): min_bucket_width = kwargs [ 'min_bucket' ] if 'max_raw' in kwargs . keys (): max_raw = kwargs [ 'max_raw' ] if statistics_type . upper () == 'FIXED_HIST' and ( 'hist_min' in kwargs . keys ()) and ( 'hist_max' in kwargs . keys ()) and ( 'hist_steps' in kwargs . keys ()): hist_min = kwargs [ 'hist_min' ] hist_max = kwargs [ 'hist_max' ] hist_steps = kwargs [ 'hist_steps' ] elif statistics_type . upper () == 'FIXED_HIST' : print ( 'To use fixedHistogram, please provide these three parameters: hist_min, hist_max, and hist_steps.' ) return allowed_statistics = { 'MEAN' : ee . Reducer . mean (), 'MAXIMUM' : ee . Reducer . max (), 'MEDIAN' : ee . Reducer . median (), 'MINIMUM' : ee . Reducer . min (), 'STD' : ee . Reducer . stdDev (), 'MIN_MAX' : ee . Reducer . minMax (), 'SUM' : ee . Reducer . sum (), 'VARIANCE' : ee . Reducer . variance (), 'HIST' : ee . Reducer . histogram ( maxBuckets = max_buckets , minBucketWidth = min_bucket_width , maxRaw = max_raw ), 'FIXED_HIST' : ee . Reducer . fixedHistogram ( hist_min , hist_max , hist_steps ) } if not ( statistics_type . upper () in allowed_statistics . keys ()): print ( 'The statistics type must be one of the following: {} ' . format ( ', ' . join ( list ( allowed_statistics . keys ())))) return if scale is None : scale = in_value_raster . projection () . nominalScale () . multiply ( 10 ) try : print ( 'Computing statistics ...' ) result = in_value_raster . reduceRegions ( collection = in_zone_vector , reducer = allowed_statistics [ statistics_type ], scale = scale , crs = crs , tileScale = tile_scale ) ee_export_vector ( result , filename ) except Exception as e : print ( e ) zonal_statistics_by_group ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'SUM' , decimal_places = 0 , denominator = 1.0 , scale = None , crs = None , tile_scale = 1.0 ) Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Parameters: Name Type Description Default in_value_raster object An integer Image that contains the values on which to calculate area/percentage. required in_zone_vector object An ee.FeatureCollection that defines the zones. required out_file_path str Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz required statistics_type str Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'. 'SUM' decimal_places int The number of decimal places to use. Defaults to 0. 0 denominator float To covert area units (e.g., from square meters to square kilometers). Defaults to 1.0. 1.0 scale float A nominal scale in meters of the projection to work in. Defaults to None. None crs str The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. None tile_scale float A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. 1.0 Source code in geemap/geemap.py def zonal_statistics_by_group ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'SUM' , decimal_places = 0 , denominator = 1.0 , scale = None , crs = None , tile_scale = 1.0 ): \"\"\"Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Args: in_value_raster (object): An integer Image that contains the values on which to calculate area/percentage. in_zone_vector (object): An ee.FeatureCollection that defines the zones. out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz statistics_type (str, optional): Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'. decimal_places (int, optional): The number of decimal places to use. Defaults to 0. denominator (float, optional): To covert area units (e.g., from square meters to square kilometers). Defaults to 1.0. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. \"\"\" if not isinstance ( in_value_raster , ee . Image ): print ( 'The input raster must be an ee.Image.' ) return band_count = in_value_raster . bandNames () . size () . getInfo () band_name = '' if band_count == 1 : band_name = in_value_raster . bandNames () . get ( 0 ) else : print ( 'The input image can only have one band.' ) return band_types = in_value_raster . bandTypes () . get ( band_name ) . getInfo () band_type = band_types . get ( 'precision' ) if band_type != 'int' : print ( 'The input image band must be integer type.' ) return if not isinstance ( in_zone_vector , ee . FeatureCollection ): print ( 'The input zone data must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' ] filename = os . path . abspath ( out_file_path ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] if not ( filetype . lower () in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return out_dir = os . path . dirname ( filename ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) allowed_statistics = [ 'SUM' , 'PERCENTAGE' ] if not ( statistics_type . upper () in allowed_statistics ): print ( 'The statistics type can only be one of {} ' . format ( ', ' . join ( allowed_statistics ))) return if scale is None : scale = in_value_raster . projection () . nominalScale () . multiply ( 10 ) try : print ( 'Computing ... ' ) geometry = in_zone_vector . geometry () hist = in_value_raster . reduceRegion ( ee . Reducer . frequencyHistogram ( ), geometry = geometry , bestEffort = True , scale = scale ) class_values = ee . Dictionary ( hist . get ( band_name )) . keys () . map ( lambda v : ee . Number . parse ( v )) . sort () class_names = class_values . map ( lambda c : ee . String ( 'Class_' ) . cat ( ee . Number ( c ) . format ())) class_count = class_values . size () . getInfo () dataset = ee . Image . pixelArea () . divide ( denominator ) . addBands ( in_value_raster ) init_result = dataset . reduceRegions ( ** { 'collection' : in_zone_vector , 'reducer' : ee . Reducer . sum () . group ( ** { 'groupField' : 1 , 'groupName' : 'group' , }), 'scale' : scale }) def build_dict ( input_list ): decimal_format = '%. {} f' . format ( decimal_places ) in_dict = input_list . map ( lambda x : ee . Dictionary () . set ( ee . String ( 'Class_' ) . cat ( ee . Number ( ee . Dictionary ( x ) . get ( 'group' )) . format ()), ee . Number . parse ( ee . Number ( ee . Dictionary ( x ) . get ( 'sum' )) . format ( decimal_format )))) return in_dict def get_keys ( input_list ): return input_list . map ( lambda x : ee . String ( 'Class_' ) . cat ( ee . Number ( ee . Dictionary ( x ) . get ( 'group' )) . format ())) def get_values ( input_list ): decimal_format = '%. {} f' . format ( decimal_places ) return input_list . map ( lambda x : ee . Number . parse ( ee . Number ( ee . Dictionary ( x ) . get ( 'sum' )) . format ( decimal_format ))) def set_attribute ( f ): groups = ee . List ( f . get ( 'groups' )) keys = get_keys ( groups ) values = get_values ( groups ) total_area = ee . List ( values ) . reduce ( ee . Reducer . sum ()) def get_class_values ( x ): cls_value = ee . Algorithms . If ( keys . contains ( x ), values . get ( keys . indexOf ( x )), 0 ) cls_value = ee . Algorithms . If ( ee . String ( statistics_type ) . compareTo ( ee . String ( 'SUM' )), ee . Number ( cls_value ) . divide ( ee . Number ( total_area )), cls_value ) return cls_value full_values = class_names . map ( lambda x : get_class_values ( x )) attr_dict = ee . Dictionary . fromLists ( class_names , full_values ) attr_dict = attr_dict . set ( 'Class_sum' , total_area ) return f . set ( attr_dict ) . set ( 'groups' , None ) final_result = init_result . map ( set_attribute ) ee_export_vector ( final_result , filename ) except Exception as e : print ( e )","title":"geemap module"},{"location":"geemap/#geemap-module","text":"","title":"geemap module"},{"location":"geemap/#geemap.geemap","text":"Main module for interactive mapping using Google Earth Engine Python API and ipyleaflet. Keep in mind that Earth Engine functions use both camel case and snake case, such as setOptions(), setCenter(), centerObject(), addLayer(). ipyleaflet functions use snake case, such as add_tile_layer(), add_wms_layer(), add_minimap().","title":"geemap.geemap"},{"location":"geemap/#geemap.geemap.Map","text":"The Map class inherits from ipyleaflet.Map. The arguments you can pass to the Map can be found at https://ipyleaflet.readthedocs.io/en/latest/api_reference/map.html. By default, the Map will add Google Maps as the basemap. Set add_google_map = False to use OpenStreetMap as the basemap. Returns: Type Description object ipyleaflet map object.","title":"Map"},{"location":"geemap/#geemap.geemap.Map.add_basemap","text":"Adds a basemap to the map. Parameters: Name Type Description Default basemap str Can be one of string from ee_basemaps. Defaults to 'HYBRID'. 'HYBRID' Source code in geemap/geemap.py def add_basemap ( self , basemap = 'HYBRID' ): \"\"\"Adds a basemap to the map. Args: basemap (str, optional): Can be one of string from ee_basemaps. Defaults to 'HYBRID'. \"\"\" try : self . add_layer ( ee_basemaps [ basemap ]) except Exception as e : print ( e ) print ( 'Basemap can only be one of the following: \\n {} ' . format ( ' \\n ' . join ( ee_basemaps . keys ())))","title":"add_basemap()"},{"location":"geemap/#geemap.geemap.Map.add_ee_layer","text":"Adds a given EE object to the map as a layer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer N'. None shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/geemap.py def add_ee_layer ( self , ee_object , vis_params = {}, name = None , shown = True , opacity = 1.0 ): \"\"\"Adds a given EE object to the map as a layer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer N'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" image = None if name is None : layer_count = len ( self . layers ) name = 'Layer ' + str ( layer_count + 1 ) if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) tile_layer = ipyleaflet . TileLayer ( url = map_id_dict [ 'tile_fetcher' ] . url_format , attribution = 'Google Earth Engine' , name = name , opacity = opacity , visible = True # visible=shown ) layer = self . find_layer ( name = name ) if layer is not None : existing_object = self . ee_layer_dict [ name ][ 'ee_object' ] if isinstance ( existing_object , ee . Image ) or isinstance ( existing_object , ee . ImageCollection ): self . ee_raster_layers . remove ( existing_object ) self . ee_raster_layer_names . remove ( name ) if self . plot_dropdown_widget is not None : self . plot_dropdown_widget . options = list ( self . ee_raster_layer_names ) self . ee_layers . remove ( existing_object ) self . ee_layer_names . remove ( name ) self . remove_layer ( layer ) self . ee_layers . append ( ee_object ) self . ee_layer_names . append ( name ) self . ee_layer_dict [ name ] = { 'ee_object' : ee_object , 'ee_layer' : tile_layer } self . add_layer ( tile_layer ) if isinstance ( ee_object , ee . Image ) or isinstance ( ee_object , ee . ImageCollection ): self . ee_raster_layers . append ( ee_object ) self . ee_raster_layer_names . append ( name ) if self . plot_dropdown_widget is not None : self . plot_dropdown_widget . options = list ( self . ee_raster_layer_names )","title":"add_ee_layer()"},{"location":"geemap/#geemap.geemap.Map.add_landsat_ts_gif","text":"Adds a Landsat timelapse to the map. Parameters: Name Type Description Default layer_name str Layer name to show under the layer control. Defaults to 'Timelapse'. 'Timelapse' roi object Region of interest to create the timelapse. Defaults to None. None label str A label to shown on the GIF, such as place name. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 1984. 1984 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. '06-10' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. '09-20' bands list Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. ['NIR', 'Red', 'Green'] vis_params dict Visualization parameters. Defaults to None. None dimensions int a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. 768 frames_per_second int Animation speed. Defaults to 10. 10 font_size int Font size of the animated text and label. Defaults to 30. 30 font_color str Font color of the animated text and label. Defaults to 'black'. 'white' add_progress_bar bool Whether to add a progress bar at the bottom of the GIF. Defaults to True. True progress_bar_color str Color for the progress bar. Defaults to 'white'. 'white' progress_bar_height int Height of the progress bar. Defaults to 5. 5 out_gif str File path to the output animated GIF. Defaults to None. None download bool Whether to download the gif. Defaults to False. False apply_fmask bool Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. True nd_bands list A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1). None nd_threshold float The threshold for extacting pixels from the normalized difference band. 0 nd_palette str The color palette to use for displaying the normalized difference band. ['black', 'blue'] Source code in geemap/geemap.py def add_landsat_ts_gif ( self , layer_name = 'Timelapse' , roi = None , label = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' , bands = [ 'NIR' , 'Red' , 'Green' ], vis_params = None , dimensions = 768 , frames_per_second = 10 , font_size = 30 , font_color = 'white' , add_progress_bar = True , progress_bar_color = 'white' , progress_bar_height = 5 , out_gif = None , download = False , apply_fmask = True , nd_bands = None , nd_threshold = 0 , nd_palette = [ 'black' , 'blue' ]): \"\"\"Adds a Landsat timelapse to the map. Args: layer_name (str, optional): Layer name to show under the layer control. Defaults to 'Timelapse'. roi (object, optional): Region of interest to create the timelapse. Defaults to None. label (str, optional): A label to shown on the GIF, such as place name. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 1984. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. bands (list, optional): Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. vis_params (dict, optional): Visualization parameters. Defaults to None. dimensions (int, optional): a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. frames_per_second (int, optional): Animation speed. Defaults to 10. font_size (int, optional): Font size of the animated text and label. Defaults to 30. font_color (str, optional): Font color of the animated text and label. Defaults to 'black'. add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True. progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'. progress_bar_height (int, optional): Height of the progress bar. Defaults to 5. out_gif (str, optional): File path to the output animated GIF. Defaults to None. download (bool, optional): Whether to download the gif. Defaults to False. apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. nd_bands (list, optional): A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1). nd_threshold (float, optional): The threshold for extacting pixels from the normalized difference band. nd_palette (str, optional): The color palette to use for displaying the normalized difference band. \"\"\" try : if roi is None : if self . draw_last_feature is not None : feature = self . draw_last_feature roi = feature . geometry () else : roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) elif isinstance ( roi , ee . Feature ) or isinstance ( roi , ee . FeatureCollection ): roi = roi . geometry () elif isinstance ( roi , ee . Geometry ): pass else : print ( 'The provided roi is invalid. It must be an ee.Geometry' ) return geojson = ee_to_geojson ( roi ) bounds = minimum_bounding_box ( geojson ) geojson = adjust_longitude ( geojson ) roi = ee . Geometry ( geojson ) in_gif = landsat_ts_gif ( roi = roi , out_gif = out_gif , start_year = start_year , end_year = end_year , start_date = start_date , end_date = end_date , bands = bands , vis_params = vis_params , dimensions = dimensions , frames_per_second = frames_per_second , apply_fmask = apply_fmask , nd_bands = nd_bands , nd_threshold = nd_threshold , nd_palette = nd_palette ) in_nd_gif = in_gif . replace ( '.gif' , '_nd.gif' ) print ( 'Adding animated text to GIF ...' ) add_text_to_gif ( in_gif , in_gif , xy = ( '2%' , '2%' ), text_sequence = start_year , font_size = font_size , font_color = font_color , duration = int ( 1000 / frames_per_second ), add_progress_bar = add_progress_bar , progress_bar_color = progress_bar_color , progress_bar_height = progress_bar_height ) if nd_bands is not None : add_text_to_gif ( in_nd_gif , in_nd_gif , xy = ( '2%' , '2%' ), text_sequence = start_year , font_size = font_size , font_color = font_color , duration = int ( 1000 / frames_per_second ), add_progress_bar = add_progress_bar , progress_bar_color = progress_bar_color , progress_bar_height = progress_bar_height ) if label is not None : add_text_to_gif ( in_gif , in_gif , xy = ( '2%' , '90%' ), text_sequence = label , font_size = font_size , font_color = font_color , duration = int ( 1000 / frames_per_second ), add_progress_bar = add_progress_bar , progress_bar_color = progress_bar_color , progress_bar_height = progress_bar_height ) # if nd_bands is not None: # add_text_to_gif(in_nd_gif, in_nd_gif, xy=('2%', '90%'), text_sequence=label, # font_size=font_size, font_color=font_color, duration=int(1000 / frames_per_second), add_progress_bar=add_progress_bar, progress_bar_color=progress_bar_color, progress_bar_height=progress_bar_height) if is_tool ( 'ffmpeg' ): reduce_gif_size ( in_gif ) if nd_bands is not None : reduce_gif_size ( in_nd_gif ) print ( 'Adding GIF to the map ...' ) self . image_overlay ( url = in_gif , bounds = bounds , name = layer_name ) if nd_bands is not None : self . image_overlay ( url = in_nd_gif , bounds = bounds , name = layer_name + ' ND' ) print ( 'The timelapse has been added to the map.' ) if download : link = create_download_link ( in_gif , title = \"Click here to download the Landsat timelapse: \" ) display ( link ) if nd_bands is not None : link2 = create_download_link ( in_nd_gif , title = \"Click here to download the Normalized Difference Index timelapse: \" ) display ( link2 ) except Exception as e : print ( e )","title":"add_landsat_ts_gif()"},{"location":"geemap/#geemap.geemap.Map.add_layer_control","text":"Adds the layer control to the map. Source code in geemap/geemap.py def add_layer_control ( self ): \"\"\"Adds the layer control to the map. \"\"\" pass","title":"add_layer_control()"},{"location":"geemap/#geemap.geemap.Map.add_legend","text":"Adds a customized basemap to the map. Parameters: Name Type Description Default legend_title str Title of the legend. Defaults to 'Legend'. 'Legend' legend_dict dict A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None. None legend_keys list A list of legend keys. Defaults to None. None legend_colors list A list of legend colors. Defaults to None. None position str Position of the legend. Defaults to 'bottomright'. 'bottomright' builtin_legend str Name of the builtin legend to add to the map. Defaults to None. None Source code in geemap/geemap.py def add_legend ( self , legend_title = 'Legend' , legend_dict = None , legend_keys = None , legend_colors = None , position = 'bottomright' , builtin_legend = None , ** kwargs ): \"\"\"Adds a customized basemap to the map. Args: legend_title (str, optional): Title of the legend. Defaults to 'Legend'. legend_dict (dict, optional): A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None. legend_keys (list, optional): A list of legend keys. Defaults to None. legend_colors (list, optional): A list of legend colors. Defaults to None. position (str, optional): Position of the legend. Defaults to 'bottomright'. builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None. \"\"\" import pkg_resources from IPython.display import display pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) legend_template = os . path . join ( pkg_dir , 'data/template/legend.html' ) # print(kwargs['min_height']) if 'min_width' not in kwargs . keys (): min_width = None else : min_wdith = kwargs [ 'min_width' ] if 'max_width' not in kwargs . keys (): max_width = None else : max_width = kwargs [ 'max_width' ] if 'min_height' not in kwargs . keys (): min_height = None else : min_height = kwargs [ 'min_height' ] if 'max_height' not in kwargs . keys (): max_height = None else : max_height = kwargs [ 'max_height' ] if 'height' not in kwargs . keys (): height = None else : height = kwargs [ 'height' ] if 'width' not in kwargs . keys (): width = None else : width = kwargs [ 'width' ] if width is None : max_width = '300px' if height is None : max_height = '400px' if not os . path . exists ( legend_template ): print ( 'The legend template does not exist.' ) return if legend_keys is not None : if not isinstance ( legend_keys , list ): print ( 'The legend keys must be a list.' ) return else : legend_keys = [ 'One' , 'Two' , 'Three' , 'Four' , 'ect' ] if legend_colors is not None : if not isinstance ( legend_colors , list ): print ( 'The legend colors must be a list.' ) return elif all ( isinstance ( item , tuple ) for item in legend_colors ): try : legend_colors = [ rgb_to_hex ( x ) for x in legend_colors ] except Exception as e : print ( e ) elif all (( item . startswith ( '#' ) and len ( item ) == 7 ) for item in legend_colors ): pass elif all (( len ( item ) == 6 ) for item in legend_colors ): pass else : print ( 'The legend colors must be a list of tuples.' ) return else : legend_colors = [ '#8DD3C7' , '#FFFFB3' , '#BEBADA' , '#FB8072' , '#80B1D3' ] if len ( legend_keys ) != len ( legend_colors ): print ( 'The legend keys and values must be the same length.' ) return allowed_builtin_legends = builtin_legends . keys () if builtin_legend is not None : # builtin_legend = builtin_legend.upper() if builtin_legend not in allowed_builtin_legends : print ( 'The builtin legend must be one of the following: {} ' . format ( ', ' . join ( allowed_builtin_legends ))) return else : legend_dict = builtin_legends [ builtin_legend ] legend_keys = list ( legend_dict . keys ()) legend_colors = list ( legend_dict . values ()) if legend_dict is not None : if not isinstance ( legend_dict , dict ): print ( 'The legend dict must be a dictionary.' ) return else : legend_keys = list ( legend_dict . keys ()) legend_colors = list ( legend_dict . values ()) if all ( isinstance ( item , tuple ) for item in legend_colors ): try : legend_colors = [ rgb_to_hex ( x ) for x in legend_colors ] except Exception as e : print ( e ) allowed_positions = [ 'topleft' , 'topright' , 'bottomleft' , 'bottomright' ] if position not in allowed_positions : print ( 'The position must be one of the following: {} ' . format ( ', ' . join ( allowed_positions ))) return header = [] content = [] footer = [] with open ( legend_template ) as f : lines = f . readlines () lines [ 3 ] = lines [ 3 ] . replace ( 'Legend' , legend_title ) header = lines [: 6 ] footer = lines [ 11 :] for index , key in enumerate ( legend_keys ): color = legend_colors [ index ] if not color . startswith ( '#' ): color = '#' + color item = \" <li><span style='background: {} ;'></span> {} </li> \\n \" . format ( color , key ) content . append ( item ) legend_html = header + content + footer legend_text = '' . join ( legend_html ) try : if self . legend_control is not None : legend_widget = self . legend_widget legend_widget . close () self . remove_control ( self . legend_control ) legend_output_widget = widgets . Output ( layout = { 'border' : '1px solid black' , 'max_width' : max_width , 'min_width' : min_width , 'max_height' : max_height , 'min_height' : min_height , 'height' : height , 'width' : width , 'overflow' : 'scroll' }) legend_control = WidgetControl ( widget = legend_output_widget , position = position ) legend_widget = widgets . HTML ( value = legend_text ) with legend_output_widget : display ( legend_widget ) self . legend_widget = legend_output_widget self . legend_control = legend_control self . add_control ( legend_control ) except Exception as e : print ( e )","title":"add_legend()"},{"location":"geemap/#geemap.geemap.Map.add_maker_cluster","text":"Captures user inputs and add markers to the map. Parameters: Name Type Description Default event str [description]. Defaults to 'click'. 'click' add_marker bool If True, add markers to the map. Defaults to True. True Returns: Type Description object a marker cluster. Source code in geemap/geemap.py def add_maker_cluster ( self , event = 'click' , add_marker = True ): \"\"\"Captures user inputs and add markers to the map. Args: event (str, optional): [description]. Defaults to 'click'. add_marker (bool, optional): If True, add markers to the map. Defaults to True. Returns: object: a marker cluster. \"\"\" coordinates = [] markers = [] marker_cluster = MarkerCluster ( name = \"Marker Cluster\" ) self . last_click = [] self . all_clicks = [] if add_marker : self . add_layer ( marker_cluster ) def handle_interaction ( ** kwargs ): latlon = kwargs . get ( 'coordinates' ) if event == 'click' and kwargs . get ( 'type' ) == 'click' : coordinates . append ( latlon ) self . last_click = latlon self . all_clicks = coordinates if add_marker : markers . append ( Marker ( location = latlon )) marker_cluster . markers = markers elif kwargs . get ( 'type' ) == 'mousemove' : pass # cursor style: https://www.w3schools.com/cssref/pr_class_cursor.asp self . default_style = { 'cursor' : 'crosshair' } self . on_interaction ( handle_interaction )","title":"add_maker_cluster()"},{"location":"geemap/#geemap.geemap.Map.add_minimap","text":"Adds a minimap (overview) to the ipyleaflet map. Parameters: Name Type Description Default zoom int Initial map zoom level. Defaults to 5. 5 position str Position of the minimap. Defaults to \"bottomright\". 'bottomright' Source code in geemap/geemap.py def add_minimap ( self , zoom = 5 , position = \"bottomright\" ): \"\"\"Adds a minimap (overview) to the ipyleaflet map. Args: zoom (int, optional): Initial map zoom level. Defaults to 5. position (str, optional): Position of the minimap. Defaults to \"bottomright\". \"\"\" minimap = ipyleaflet . Map ( zoom_control = False , attribution_control = False , zoom = 5 , center = self . center , layers = [ ee_basemaps [ 'ROADMAP' ]] ) minimap . layout . width = '150px' minimap . layout . height = '150px' link (( minimap , 'center' ), ( self , 'center' )) minimap_control = WidgetControl ( widget = minimap , position = position ) self . add_control ( minimap_control )","title":"add_minimap()"},{"location":"geemap/#geemap.geemap.Map.add_raster","text":"Adds a local raster dataset to the map. Parameters: Name Type Description Default image str The image file path. required bands int or list The image bands to use. It can be either a nubmer (e.g., 1) or a list (e.g., [3, 2, 1]). Defaults to None. None layer_name str The layer name to use for the raster. Defaults to None. None colormap str The name of the colormap to use for the raster, such as 'gray' and 'terrain'. More can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html. Defaults to None. None x_dim str The x dimension. Defaults to 'x'. 'x' y_dim str The y dimension. Defaults to 'y'. 'y' Source code in geemap/geemap.py def add_raster ( self , image , bands = None , layer_name = None , colormap = None , x_dim = 'x' , y_dim = 'y' ): \"\"\"Adds a local raster dataset to the map. Args: image (str): The image file path. bands (int or list, optional): The image bands to use. It can be either a nubmer (e.g., 1) or a list (e.g., [3, 2, 1]). Defaults to None. layer_name (str, optional): The layer name to use for the raster. Defaults to None. colormap (str, optional): The name of the colormap to use for the raster, such as 'gray' and 'terrain'. More can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html. Defaults to None. x_dim (str, optional): The x dimension. Defaults to 'x'. y_dim (str, optional): The y dimension. Defaults to 'y'. \"\"\" try : import xarray_leaflet except : # import platform # if platform.system() != \"Windows\": # # install_from_github( # # url='https://github.com/davidbrochart/xarray_leaflet') # check_install('xarray_leaflet') # import xarray_leaflet # else: print ( 'You need to install xarray_leaflet first. See https://github.com/davidbrochart/xarray_leaflet' ) print ( 'Try the following to install xarray_leaflet: \\n\\n conda install -c conda-forge xarray_leaflet' ) return import warnings import numpy as np import rioxarray import xarray as xr import matplotlib.pyplot as plt warnings . simplefilter ( 'ignore' ) if not os . path . exists ( image ): print ( 'The image file does not exist.' ) return if colormap is None : colormap = plt . cm . inferno if layer_name is None : layer_name = 'Layer_' + random_string () if isinstance ( colormap , str ): colormap = plt . cm . get_cmap ( name = colormap ) da = rioxarray . open_rasterio ( image , masked = True ) # print(da.rio.nodata) multi_band = False if len ( da . band ) > 1 : multi_band = True if bands is None : bands = [ 3 , 2 , 1 ] else : bands = 1 if multi_band : da = da . rio . write_nodata ( 0 ) else : da = da . rio . write_nodata ( np . nan ) da = da . sel ( band = bands ) # crs = da.rio.crs # nan = da.attrs['nodatavals'][0] # da = da / da.max() # # if multi_band: # da = xr.where(da == nan, np.nan, da) # da = da.rio.write_nodata(0) # da = da.rio.write_crs(crs) if multi_band : layer = da . leaflet . plot ( self , x_dim = x_dim , y_dim = y_dim , rgb_dim = 'band' ) else : layer = da . leaflet . plot ( self , x_dim = x_dim , y_dim = y_dim , colormap = colormap ) layer . name = layer_name","title":"add_raster()"},{"location":"geemap/#geemap.geemap.Map.add_tile_layer","text":"Adds a TileLayer to the map. Parameters: Name Type Description Default url str The URL of the tile layer. Defaults to 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'. 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png' name str The layer name to use for the layer. Defaults to None. None attribution str The attribution to use. Defaults to ''. '' opacity float The opacity of the layer. Defaults to 1. 1.0 shown bool A flag indicating whether the layer should be on by default. Defaults to True. True Source code in geemap/geemap.py def add_tile_layer ( self , url = 'https:// {s} .tile.openstreetmap.org/ {z} / {x} / {y} .png' , name = None , attribution = '' , opacity = 1.0 , shown = True ): \"\"\"Adds a TileLayer to the map. Args: url (str, optional): The URL of the tile layer. Defaults to 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'. name (str, optional): The layer name to use for the layer. Defaults to None. attribution (str, optional): The attribution to use. Defaults to ''. opacity (float, optional): The opacity of the layer. Defaults to 1. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. \"\"\" try : tile_layer = ipyleaflet . TileLayer ( url = url , name = name , attribution = attribution , opacity = opacity , visible = True # visible=shown ) self . add_layer ( tile_layer ) except Exception as e : print ( e ) print ( \"Failed to add the specified TileLayer.\" )","title":"add_tile_layer()"},{"location":"geemap/#geemap.geemap.Map.add_wms_layer","text":"Add a WMS layer to the map. Parameters: Name Type Description Default url str The URL of the WMS web service. required layers str Comma-separated list of WMS layers to show. required name str The layer name to use on the layer control. Defaults to None. None attribution str The attribution of the data layer. Defaults to ''. '' format str WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/jpeg'. 'image/jpeg' transparent bool If True, the WMS service will return images with transparency. Defaults to False. False opacity float The opacity of the layer. Defaults to 1.0. 1.0 shown bool A flag indicating whether the layer should be on by default. Defaults to True. True Source code in geemap/geemap.py def add_wms_layer ( self , url , layers , name = None , attribution = '' , format = 'image/jpeg' , transparent = False , opacity = 1.0 , shown = True ): \"\"\"Add a WMS layer to the map. Args: url (str): The URL of the WMS web service. layers (str): Comma-separated list of WMS layers to show. name (str, optional): The layer name to use on the layer control. Defaults to None. attribution (str, optional): The attribution of the data layer. Defaults to ''. format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/jpeg'. transparent (bool, optional): If True, the WMS service will return images with transparency. Defaults to False. opacity (float, optional): The opacity of the layer. Defaults to 1.0. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. \"\"\" if name is None : name = str ( layers ) try : wms_layer = ipyleaflet . WMSLayer ( url = url , layers = layers , name = name , attribution = attribution , format = format , transparent = transparent , opacity = opacity , visible = True # visible=shown ) self . add_layer ( wms_layer ) except Exception as e : print ( e ) print ( \"Failed to add the specified WMS TileLayer.\" )","title":"add_wms_layer()"},{"location":"geemap/#geemap.geemap.Map.addLayer","text":"Adds a given EE object to the map as a layer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer N'. None shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/geemap.py def add_ee_layer ( self , ee_object , vis_params = {}, name = None , shown = True , opacity = 1.0 ): \"\"\"Adds a given EE object to the map as a layer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer N'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" image = None if name is None : layer_count = len ( self . layers ) name = 'Layer ' + str ( layer_count + 1 ) if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) tile_layer = ipyleaflet . TileLayer ( url = map_id_dict [ 'tile_fetcher' ] . url_format , attribution = 'Google Earth Engine' , name = name , opacity = opacity , visible = True # visible=shown ) layer = self . find_layer ( name = name ) if layer is not None : existing_object = self . ee_layer_dict [ name ][ 'ee_object' ] if isinstance ( existing_object , ee . Image ) or isinstance ( existing_object , ee . ImageCollection ): self . ee_raster_layers . remove ( existing_object ) self . ee_raster_layer_names . remove ( name ) if self . plot_dropdown_widget is not None : self . plot_dropdown_widget . options = list ( self . ee_raster_layer_names ) self . ee_layers . remove ( existing_object ) self . ee_layer_names . remove ( name ) self . remove_layer ( layer ) self . ee_layers . append ( ee_object ) self . ee_layer_names . append ( name ) self . ee_layer_dict [ name ] = { 'ee_object' : ee_object , 'ee_layer' : tile_layer } self . add_layer ( tile_layer ) if isinstance ( ee_object , ee . Image ) or isinstance ( ee_object , ee . ImageCollection ): self . ee_raster_layers . append ( ee_object ) self . ee_raster_layer_names . append ( name ) if self . plot_dropdown_widget is not None : self . plot_dropdown_widget . options = list ( self . ee_raster_layer_names )","title":"addLayer()"},{"location":"geemap/#geemap.geemap.Map.addLayerControl","text":"Adds the layer control to the map. Source code in geemap/geemap.py def add_layer_control ( self ): \"\"\"Adds the layer control to the map. \"\"\" pass","title":"addLayerControl()"},{"location":"geemap/#geemap.geemap.Map.basemap_demo","text":"A demo for using geemap basemaps. Source code in geemap/geemap.py def basemap_demo ( self ): \"\"\"A demo for using geemap basemaps. \"\"\" dropdown = widgets . Dropdown ( options = list ( ee_basemaps . keys ()), value = 'HYBRID' , description = 'Basemaps' ) def on_click ( change ): basemap_name = change [ 'new' ] old_basemap = self . layers [ - 1 ] self . substitute_layer ( old_basemap , ee_basemaps [ basemap_name ]) dropdown . observe ( on_click , 'value' ) basemap_control = WidgetControl ( widget = dropdown , position = 'topright' ) self . remove_control ( self . inspector_control ) # self.remove_control(self.layer_control) self . add_control ( basemap_control )","title":"basemap_demo()"},{"location":"geemap/#geemap.geemap.Map.center_object","text":"Centers the map view on a given object. Parameters: Name Type Description Default ee_object Element|Geometry An Earth Engine object to center on - a geometry, image or feature. required zoom int The zoom level, from 1 to 24. Defaults to None. None Source code in geemap/geemap.py def center_object ( self , ee_object , zoom = None ): \"\"\"Centers the map view on a given object. Args: ee_object (Element|Geometry): An Earth Engine object to center on - a geometry, image or feature. zoom (int, optional): The zoom level, from 1 to 24. Defaults to None. \"\"\" lat = 0 lon = 0 bounds = [[ lat , lon ], [ lat , lon ]] if isinstance ( ee_object , ee . geometry . Geometry ): centroid = ee_object . centroid ( 1 ) lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . feature . Feature ): centroid = ee_object . geometry () . centroid ( 1 ) lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . featurecollection . FeatureCollection ): centroid = ee_object . geometry () . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . image . Image ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] else : bounds = [[ 0 , 0 ], [ 0 , 0 ]] lat = bounds [ 0 ][ 0 ] lon = bounds [ 0 ][ 1 ] self . setCenter ( lon , lat , zoom )","title":"center_object()"},{"location":"geemap/#geemap.geemap.Map.centerObject","text":"Centers the map view on a given object. Parameters: Name Type Description Default ee_object Element|Geometry An Earth Engine object to center on - a geometry, image or feature. required zoom int The zoom level, from 1 to 24. Defaults to None. None Source code in geemap/geemap.py def center_object ( self , ee_object , zoom = None ): \"\"\"Centers the map view on a given object. Args: ee_object (Element|Geometry): An Earth Engine object to center on - a geometry, image or feature. zoom (int, optional): The zoom level, from 1 to 24. Defaults to None. \"\"\" lat = 0 lon = 0 bounds = [[ lat , lon ], [ lat , lon ]] if isinstance ( ee_object , ee . geometry . Geometry ): centroid = ee_object . centroid ( 1 ) lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . feature . Feature ): centroid = ee_object . geometry () . centroid ( 1 ) lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . featurecollection . FeatureCollection ): centroid = ee_object . geometry () . centroid () lon , lat = centroid . getInfo ()[ 'coordinates' ] bounds = [[ lat , lon ], [ lat , lon ]] elif isinstance ( ee_object , ee . image . Image ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): geometry = ee_object . geometry () coordinates = geometry . getInfo ()[ 'coordinates' ][ 0 ] bounds = [ coordinates [ 0 ][:: - 1 ], coordinates [ 2 ][:: - 1 ]] else : bounds = [[ 0 , 0 ], [ 0 , 0 ]] lat = bounds [ 0 ][ 0 ] lon = bounds [ 0 ][ 1 ] self . setCenter ( lon , lat , zoom )","title":"centerObject()"},{"location":"geemap/#geemap.geemap.Map.extract_values_to_points","text":"Exports pixel values to a csv file based on user-drawn geometries. Parameters: Name Type Description Default filename str The output file path to the csv file or shapefile. required Source code in geemap/geemap.py def extract_values_to_points ( self , filename ): \"\"\"Exports pixel values to a csv file based on user-drawn geometries. Args: filename (str): The output file path to the csv file or shapefile. \"\"\" import csv filename = os . path . abspath ( filename ) allowed_formats = [ 'csv' , 'shp' ] ext = filename [ - 3 :] if ext not in allowed_formats : print ( 'The output file must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return out_dir = os . path . dirname ( filename ) out_csv = filename [: - 3 ] + 'csv' out_shp = filename [: - 3 ] + 'shp' if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) count = len ( self . chart_points ) out_list = [] if count > 0 : header = [ 'id' , 'longitude' , 'latitude' ] + self . chart_labels out_list . append ( header ) for i in range ( 0 , count ): id = i + 1 line = [ id ] + self . chart_points [ i ] + self . chart_values [ i ] out_list . append ( line ) with open ( out_csv , \"w\" , newline = \"\" ) as f : writer = csv . writer ( f ) writer . writerows ( out_list ) if ext == 'csv' : print ( 'The csv file has been saved to: {} ' . format ( out_csv )) else : csv_to_shp ( out_csv , out_shp ) print ( 'The shapefile has been saved to: {} ' . format ( out_shp ))","title":"extract_values_to_points()"},{"location":"geemap/#geemap.geemap.Map.find_layer","text":"Finds layer by name Parameters: Name Type Description Default name str Name of the layer to find. required Returns: Type Description object ipyleaflet layer object. Source code in geemap/geemap.py def find_layer ( self , name ): \"\"\"Finds layer by name Args: name (str): Name of the layer to find. Returns: object: ipyleaflet layer object. \"\"\" layers = self . layers for layer in layers : if layer . name == name : return layer return None","title":"find_layer()"},{"location":"geemap/#geemap.geemap.Map.get_scale","text":"Returns the approximate pixel scale of the current map view, in meters. Returns: Type Description float Map resolution in meters. Source code in geemap/geemap.py def get_scale ( self ): \"\"\"Returns the approximate pixel scale of the current map view, in meters. Returns: float: Map resolution in meters. \"\"\" zoom_level = self . zoom # Reference: https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution resolution = 156543.04 * math . cos ( 0 ) / math . pow ( 2 , zoom_level ) return resolution","title":"get_scale()"},{"location":"geemap/#geemap.geemap.Map.getScale","text":"Returns the approximate pixel scale of the current map view, in meters. Returns: Type Description float Map resolution in meters. Source code in geemap/geemap.py def get_scale ( self ): \"\"\"Returns the approximate pixel scale of the current map view, in meters. Returns: float: Map resolution in meters. \"\"\" zoom_level = self . zoom # Reference: https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution resolution = 156543.04 * math . cos ( 0 ) / math . pow ( 2 , zoom_level ) return resolution","title":"getScale()"},{"location":"geemap/#geemap.geemap.Map.image_overlay","text":"Overlays an image from the Internet or locally on the map. Parameters: Name Type Description Default url str http URL or local file path to the image. required bounds tuple bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)). required name str name of the layer to show on the layer control. required Source code in geemap/geemap.py def image_overlay ( self , url , bounds , name ): \"\"\"Overlays an image from the Internet or locally on the map. Args: url (str): http URL or local file path to the image. bounds (tuple): bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)). name (str): name of the layer to show on the layer control. \"\"\" from base64 import b64encode from PIL import Image , ImageSequence from io import BytesIO try : if not url . startswith ( 'http' ): if not os . path . exists ( url ): print ( 'The provided file does not exist.' ) return ext = os . path . splitext ( url )[ 1 ][ 1 :] # file extension image = Image . open ( url ) f = BytesIO () if ext . lower () == 'gif' : frames = [] # Loop over each frame in the animated image for frame in ImageSequence . Iterator ( image ): frame = frame . convert ( 'RGBA' ) b = BytesIO () frame . save ( b , format = \"gif\" ) frame = Image . open ( b ) frames . append ( frame ) frames [ 0 ] . save ( f , format = 'GIF' , save_all = True , append_images = frames [ 1 :], loop = 0 ) else : image . save ( f , ext ) data = b64encode ( f . getvalue ()) data = data . decode ( 'ascii' ) url = 'data:image/ {} ;base64,' . format ( ext ) + data img = ipyleaflet . ImageOverlay ( url = url , bounds = bounds , name = name ) self . add_layer ( img ) except Exception as e : print ( e )","title":"image_overlay()"},{"location":"geemap/#geemap.geemap.Map.layer_opacity","text":"Changes layer opacity. Parameters: Name Type Description Default name str The name of the layer to change opacity. required value float The opacity value to set. Defaults to 1.0. 1.0 Source code in geemap/geemap.py def layer_opacity ( self , name , value = 1.0 ): \"\"\"Changes layer opacity. Args: name (str): The name of the layer to change opacity. value (float, optional): The opacity value to set. Defaults to 1.0. \"\"\" layer = self . find_layer ( name ) try : layer . opacity = value # layer.interact(opacity=(0, 1, 0.1)) # to change layer opacity interactively except Exception as e : print ( e )","title":"layer_opacity()"},{"location":"geemap/#geemap.geemap.Map.marker_cluster","text":"Adds a marker cluster to the map and returns a list of ee.Feature, which can be accessed using Map.ee_marker_cluster. Returns: Type Description object a list of ee.Feature Source code in geemap/geemap.py def marker_cluster ( self ): \"\"\"Adds a marker cluster to the map and returns a list of ee.Feature, which can be accessed using Map.ee_marker_cluster. Returns: object: a list of ee.Feature \"\"\" coordinates = [] markers = [] marker_cluster = MarkerCluster ( name = \"Marker Cluster\" ) self . last_click = [] self . all_clicks = [] self . ee_markers = [] self . add_layer ( marker_cluster ) def handle_interaction ( ** kwargs ): latlon = kwargs . get ( 'coordinates' ) if kwargs . get ( 'type' ) == 'click' : coordinates . append ( latlon ) geom = ee . Geometry . Point ( latlon [ 1 ], latlon [ 0 ]) feature = ee . Feature ( geom ) self . ee_markers . append ( feature ) self . last_click = latlon self . all_clicks = coordinates markers . append ( Marker ( location = latlon )) marker_cluster . markers = markers elif kwargs . get ( 'type' ) == 'mousemove' : pass # cursor style: https://www.w3schools.com/cssref/pr_class_cursor.asp self . default_style = { 'cursor' : 'crosshair' } self . on_interaction ( handle_interaction )","title":"marker_cluster()"},{"location":"geemap/#geemap.geemap.Map.plot","text":"Creates a plot based on x-array and y-array data. Parameters: Name Type Description Default x numpy.ndarray or list The x-coordinates of the plotted line. required y numpy.ndarray or list The y-coordinates of the plotted line. required plot_type str The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. None overlay bool Whether to overlay plotted lines on the figure. Defaults to False. False position str Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. 'bottomright' min_width int Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_width int Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. None min_height int Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_height int Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. None Source code in geemap/geemap.py def plot ( self , x , y , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ): \"\"\"Creates a plot based on x-array and y-array data. Args: x (numpy.ndarray or list): The x-coordinates of the plotted line. y (numpy.ndarray or list): The y-coordinates of the plotted line. plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False. position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. \"\"\" if self . plot_widget is not None : plot_widget = self . plot_widget else : plot_widget = widgets . Output ( layout = { 'border' : '1px solid black' }) plot_control = WidgetControl ( widget = plot_widget , position = position , min_width = min_width , max_width = max_width , min_height = min_height , max_height = max_height ) self . plot_widget = plot_widget self . plot_control = plot_control self . add_control ( plot_control ) if max_width is None : max_width = 500 if max_height is None : max_height = 300 if ( plot_type is None ) and ( 'markers' not in kwargs . keys ()): kwargs [ 'markers' ] = 'circle' with plot_widget : try : fig = plt . figure ( 1 , ** kwargs ) if max_width is not None : fig . layout . width = str ( max_width ) + 'px' if max_height is not None : fig . layout . height = str ( max_height ) + 'px' plot_widget . clear_output ( wait = True ) if not overlay : plt . clear () if plot_type is None : if 'marker' not in kwargs . keys (): kwargs [ 'marker' ] = 'circle' plt . plot ( x , y , ** kwargs ) elif plot_type == 'bar' : plt . bar ( x , y , ** kwargs ) elif plot_type == 'scatter' : plt . scatter ( x , y , ** kwargs ) elif plot_type == 'hist' : plt . hist ( y , ** kwargs ) plt . show () except Exception as e : print ( e ) print ( \"Failed to create plot.\" )","title":"plot()"},{"location":"geemap/#geemap.geemap.Map.plot_demo","text":"A demo of interactive plotting using random pixel coordinates. Parameters: Name Type Description Default iterations int How many iterations to run for the demo. Defaults to 20. 20 plot_type str The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. None overlay bool Whether to overlay plotted lines on the figure. Defaults to False. False position str Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. 'bottomright' min_width int Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_width int Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. None min_height int Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_height int Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. None Source code in geemap/geemap.py def plot_demo ( self , iterations = 20 , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ): \"\"\"A demo of interactive plotting using random pixel coordinates. Args: iterations (int, optional): How many iterations to run for the demo. Defaults to 20. plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False. position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. \"\"\" import numpy as np import time if self . random_marker is not None : self . remove_layer ( self . random_marker ) image = ee . Image ( 'LE7_TOA_5YEAR/1999_2003' ) . select ([ 0 , 1 , 2 , 3 , 4 , 6 ]) self . addLayer ( image , { 'bands' : [ 'B4' , 'B3' , 'B2' ], 'gamma' : 1.4 }, \"LE7_TOA_5YEAR/1999_2003\" ) self . setCenter ( - 50.078877 , 25.190030 , 3 ) band_names = image . bandNames () . getInfo () band_count = len ( band_names ) latitudes = np . random . uniform ( 30 , 48 , size = iterations ) longitudes = np . random . uniform ( - 121 , - 76 , size = iterations ) marker = Marker ( location = ( 0 , 0 )) self . random_marker = marker self . add_layer ( marker ) for i in range ( iterations ): try : coordinate = ee . Geometry . Point ([ longitudes [ i ], latitudes [ i ]]) dict_values = image . sample ( coordinate ) . first () . toDictionary () . getInfo () band_values = list ( dict_values . values ()) title = ' {} / {} : Spectral signature at ( {} , {} )' . format ( i + 1 , iterations , round ( latitudes [ i ], 2 ), round ( longitudes [ i ], 2 )) marker . location = ( latitudes [ i ], longitudes [ i ]) self . plot ( band_names , band_values , plot_type = plot_type , overlay = overlay , min_width = min_width , max_width = max_width , min_height = min_height , max_height = max_height , title = title , ** kwargs ) time . sleep ( 0.3 ) except Exception as e : print ( e )","title":"plot_demo()"},{"location":"geemap/#geemap.geemap.Map.plot_raster","text":"Interactive plotting of Earth Engine data by clicking on the map. Parameters: Name Type Description Default ee_object object The ee.Image or ee.ImageCollection to sample. Defaults to None. None sample_scale float A nominal scale in meters of the projection to sample in. Defaults to None. None plot_type str The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. None overlay bool Whether to overlay plotted lines on the figure. Defaults to False. False position str Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. 'bottomright' min_width int Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_width int Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. None min_height int Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_height int Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. None Source code in geemap/geemap.py def plot_raster ( self , ee_object = None , sample_scale = None , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ): \"\"\"Interactive plotting of Earth Engine data by clicking on the map. Args: ee_object (object, optional): The ee.Image or ee.ImageCollection to sample. Defaults to None. sample_scale (float, optional): A nominal scale in meters of the projection to sample in. Defaults to None. plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False. position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. \"\"\" if self . plot_control is not None : del self . plot_widget self . remove_control ( self . plot_control ) if self . random_marker is not None : self . remove_layer ( self . random_marker ) plot_widget = widgets . Output ( layout = { 'border' : '1px solid black' }) plot_control = WidgetControl ( widget = plot_widget , position = position , min_width = min_width , max_width = max_width , min_height = min_height , max_height = max_height ) self . plot_widget = plot_widget self . plot_control = plot_control self . add_control ( plot_control ) self . default_style = { 'cursor' : 'crosshair' } msg = \"The plot function can only be used on ee.Image or ee.ImageCollection with more than one band.\" if ( ee_object is None ) and len ( self . ee_raster_layers ) > 0 : ee_object = self . ee_raster_layers [ - 1 ] if isinstance ( ee_object , ee . ImageCollection ): ee_object = ee_object . mosaic () elif isinstance ( ee_object , ee . ImageCollection ): ee_object = ee_object . mosaic () elif not isinstance ( ee_object , ee . Image ): print ( msg ) return if sample_scale is None : sample_scale = self . getScale () if max_width is None : max_width = 500 band_names = ee_object . bandNames () . getInfo () coordinates = [] markers = [] marker_cluster = MarkerCluster ( name = \"Marker Cluster\" ) self . last_click = [] self . all_clicks = [] self . add_layer ( marker_cluster ) def handle_interaction ( ** kwargs2 ): latlon = kwargs2 . get ( 'coordinates' ) if kwargs2 . get ( 'type' ) == 'click' : try : coordinates . append ( latlon ) self . last_click = latlon self . all_clicks = coordinates markers . append ( Marker ( location = latlon )) marker_cluster . markers = markers self . default_style = { 'cursor' : 'wait' } xy = ee . Geometry . Point ( latlon [:: - 1 ]) dict_values = ee_object . sample ( xy , scale = sample_scale ) . first () . toDictionary () . getInfo () band_values = list ( dict_values . values ()) self . plot ( band_names , band_values , plot_type = plot_type , overlay = overlay , min_width = min_width , max_width = max_width , min_height = min_height , max_height = max_height , ** kwargs ) self . default_style = { 'cursor' : 'crosshair' } except Exception as e : if self . plot_widget is not None : with self . plot_widget : self . plot_widget . clear_output () print ( \"No data for the clicked location.\" ) else : print ( e ) self . default_style = { 'cursor' : 'crosshair' } self . on_interaction ( handle_interaction )","title":"plot_raster()"},{"location":"geemap/#geemap.geemap.Map.remove_drawn_features","text":"Removes user-drawn geometries from the map Source code in geemap/geemap.py def remove_drawn_features ( self ): \"\"\"Removes user-drawn geometries from the map \"\"\" if self . draw_layer is not None : self . remove_layer ( self . draw_layer ) self . draw_count = 0 self . draw_features = [] self . draw_last_feature = None self . draw_layer = None self . draw_last_json = None self . draw_last_bounds = None self . user_roi = None self . user_rois = None self . chart_values = [] self . chart_points = [] self . chart_labels = None","title":"remove_drawn_features()"},{"location":"geemap/#geemap.geemap.Map.set_center","text":"Centers the map view at a given coordinates with the given zoom level. Parameters: Name Type Description Default lon float The longitude of the center, in degrees. required lat float The latitude of the center, in degrees. required zoom int The zoom level, from 1 to 24. Defaults to None. None Source code in geemap/geemap.py def set_center ( self , lon , lat , zoom = None ): \"\"\"Centers the map view at a given coordinates with the given zoom level. Args: lon (float): The longitude of the center, in degrees. lat (float): The latitude of the center, in degrees. zoom (int, optional): The zoom level, from 1 to 24. Defaults to None. \"\"\" self . center = ( lat , lon ) if zoom is not None : self . zoom = zoom","title":"set_center()"},{"location":"geemap/#geemap.geemap.Map.set_control_visibility","text":"Sets the visibility of the controls on the map. Parameters: Name Type Description Default layerControl bool Whether to show the control that allows the user to toggle layers on/off. Defaults to True. True fullscreenControl bool Whether to show the control that allows the user to make the map full-screen. Defaults to True. True latLngPopup bool Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. True Source code in geemap/geemap.py def set_control_visibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ): \"\"\"Sets the visibility of the controls on the map. Args: layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True. fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True. latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. \"\"\" pass","title":"set_control_visibility()"},{"location":"geemap/#geemap.geemap.Map.set_options","text":"Adds Google basemap and controls to the ipyleaflet map. Parameters: Name Type Description Default mapTypeId str A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. 'HYBRID' styles object A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. None types list A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. None Source code in geemap/geemap.py def set_options ( self , mapTypeId = 'HYBRID' , styles = None , types = None ): \"\"\"Adds Google basemap and controls to the ipyleaflet map. Args: mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. styles (object, optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. types (list, optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. \"\"\" self . clear_layers () self . clear_controls () self . scroll_wheel_zoom = True self . add_control ( ZoomControl ( position = 'topleft' )) self . add_control ( LayersControl ( position = 'topright' )) self . add_control ( ScaleControl ( position = 'bottomleft' )) self . add_control ( FullScreenControl ()) self . add_control ( DrawControl ()) measure = MeasureControl ( position = 'bottomleft' , active_color = 'orange' , primary_length_unit = 'kilometers' ) self . add_control ( measure ) try : self . add_layer ( ee_basemaps [ mapTypeId ]) except Exception as e : print ( e ) print ( 'Google basemaps can only be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\".' )","title":"set_options()"},{"location":"geemap/#geemap.geemap.Map.set_plot_options","text":"Sets plotting options. Parameters: Name Type Description Default add_marker_cluster bool Whether to add a marker cluster. Defaults to False. False sample_scale float A nominal scale in meters of the projection to sample in . Defaults to None. None plot_type str The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. None overlay bool Whether to overlay plotted lines on the figure. Defaults to False. False position str Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. 'bottomright' min_width int Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_width int Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. None min_height int Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. None max_height int Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. None Source code in geemap/geemap.py def set_plot_options ( self , add_marker_cluster = False , sample_scale = None , plot_type = None , overlay = False , position = 'bottomright' , min_width = None , max_width = None , min_height = None , max_height = None , ** kwargs ): \"\"\"Sets plotting options. Args: add_marker_cluster (bool, optional): Whether to add a marker cluster. Defaults to False. sample_scale (float, optional): A nominal scale in meters of the projection to sample in . Defaults to None. plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None. overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False. position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'. min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None. max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None. min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None. max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None. \"\"\" plot_options_dict = {} plot_options_dict [ 'add_marker_cluster' ] = add_marker_cluster plot_options_dict [ 'sample_scale' ] = sample_scale plot_options_dict [ 'plot_type' ] = plot_type plot_options_dict [ 'overlay' ] = overlay plot_options_dict [ 'position' ] = position plot_options_dict [ 'min_width' ] = min_width plot_options_dict [ 'max_width' ] = max_width plot_options_dict [ 'min_height' ] = min_height plot_options_dict [ 'max_height' ] = max_height for key in kwargs . keys (): plot_options_dict [ key ] = kwargs [ key ] self . plot_options = plot_options_dict if add_marker_cluster and ( self . plot_marker_cluster not in self . layers ): self . add_layer ( self . plot_marker_cluster )","title":"set_plot_options()"},{"location":"geemap/#geemap.geemap.Map.setCenter","text":"Centers the map view at a given coordinates with the given zoom level. Parameters: Name Type Description Default lon float The longitude of the center, in degrees. required lat float The latitude of the center, in degrees. required zoom int The zoom level, from 1 to 24. Defaults to None. None Source code in geemap/geemap.py def set_center ( self , lon , lat , zoom = None ): \"\"\"Centers the map view at a given coordinates with the given zoom level. Args: lon (float): The longitude of the center, in degrees. lat (float): The latitude of the center, in degrees. zoom (int, optional): The zoom level, from 1 to 24. Defaults to None. \"\"\" self . center = ( lat , lon ) if zoom is not None : self . zoom = zoom","title":"setCenter()"},{"location":"geemap/#geemap.geemap.Map.setControlVisibility","text":"Sets the visibility of the controls on the map. Parameters: Name Type Description Default layerControl bool Whether to show the control that allows the user to toggle layers on/off. Defaults to True. True fullscreenControl bool Whether to show the control that allows the user to make the map full-screen. Defaults to True. True latLngPopup bool Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. True Source code in geemap/geemap.py def set_control_visibility ( self , layerControl = True , fullscreenControl = True , latLngPopup = True ): \"\"\"Sets the visibility of the controls on the map. Args: layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True. fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True. latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True. \"\"\" pass","title":"setControlVisibility()"},{"location":"geemap/#geemap.geemap.Map.setOptions","text":"Adds Google basemap and controls to the ipyleaflet map. Parameters: Name Type Description Default mapTypeId str A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. 'HYBRID' styles object A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. None types list A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. None Source code in geemap/geemap.py def set_options ( self , mapTypeId = 'HYBRID' , styles = None , types = None ): \"\"\"Adds Google basemap and controls to the ipyleaflet map. Args: mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'. styles (object, optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None. types (list, optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None. \"\"\" self . clear_layers () self . clear_controls () self . scroll_wheel_zoom = True self . add_control ( ZoomControl ( position = 'topleft' )) self . add_control ( LayersControl ( position = 'topright' )) self . add_control ( ScaleControl ( position = 'bottomleft' )) self . add_control ( FullScreenControl ()) self . add_control ( DrawControl ()) measure = MeasureControl ( position = 'bottomleft' , active_color = 'orange' , primary_length_unit = 'kilometers' ) self . add_control ( measure ) try : self . add_layer ( ee_basemaps [ mapTypeId ]) except Exception as e : print ( e ) print ( 'Google basemaps can only be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\".' )","title":"setOptions()"},{"location":"geemap/#geemap.geemap.Map.split_map","text":"Adds split map. Parameters: Name Type Description Default left_layer str The layer tile layer. Defaults to 'HYBRID'. 'HYBRID' right_layer str The right tile layer. Defaults to 'ESRI'. 'ESRI' Source code in geemap/geemap.py def split_map ( self , left_layer = 'HYBRID' , right_layer = 'ESRI' ): \"\"\"Adds split map. Args: left_layer (str, optional): The layer tile layer. Defaults to 'HYBRID'. right_layer (str, optional): The right tile layer. Defaults to 'ESRI'. \"\"\" try : self . remove_control ( self . layer_control ) self . remove_control ( self . inspector_control ) if left_layer in ee_basemaps . keys (): left_layer = ee_basemaps [ left_layer ] if right_layer in ee_basemaps . keys (): right_layer = ee_basemaps [ right_layer ] control = ipyleaflet . SplitMapControl ( left_layer = left_layer , right_layer = right_layer ) self . add_control ( control ) except Exception as e : print ( e ) print ( 'The provided layers are invalid!' )","title":"split_map()"},{"location":"geemap/#geemap.geemap.Map.to_html","text":"Saves the map as a HTML file. Parameters: Name Type Description Default outfile str The output file path to the HTML file. required title str The title of the HTML file. Defaults to 'My Map'. 'My Map' width str The width of the map in pixels or percentage. Defaults to '100%'. '100%' height str The height of the map in pixels. Defaults to '880px'. '880px' Source code in geemap/geemap.py def to_html ( self , outfile , title = 'My Map' , width = '100%' , height = '880px' ): \"\"\"Saves the map as a HTML file. Args: outfile (str): The output file path to the HTML file. title (str, optional): The title of the HTML file. Defaults to 'My Map'. width (str, optional): The width of the map in pixels or percentage. Defaults to '100%'. height (str, optional): The height of the map in pixels. Defaults to '880px'. \"\"\" try : if not outfile . endswith ( '.html' ): print ( 'The output file must end with .html' ) return out_dir = os . path . dirname ( outfile ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) before_width = self . layout . width before_height = self . layout . height if not isinstance ( width , str ): print ( \"width must be a string.\" ) return elif width . endswith ( 'px' ) or width . endswith ( '%' ): pass else : print ( 'width must end with px or %' ) return if not isinstance ( height , str ): print ( \"height must be a string.\" ) return elif not height . endswith ( 'px' ): print ( 'height must end with px' ) return self . layout . width = width self . layout . height = height self . save ( outfile , title = title ) self . layout . width = before_width self . layout . height = before_height except Exception as e : print ( e )","title":"to_html()"},{"location":"geemap/#geemap.geemap.Map.to_image","text":"Saves the map as a PNG or JPG image. Parameters: Name Type Description Default outfile str The output file path to the image. Defaults to None. None monitor int The monitor to take the screenshot. Defaults to 1. 1 Source code in geemap/geemap.py def to_image ( self , outfile = None , monitor = 1 ): \"\"\"Saves the map as a PNG or JPG image. Args: outfile (str, optional): The output file path to the image. Defaults to None. monitor (int, optional): The monitor to take the screenshot. Defaults to 1. \"\"\" if outfile is None : outfile = os . path . join ( os . getcwd (), 'my_map.png' ) if outfile . endswith ( '.png' ) or outfile . endswith ( '.jpg' ): pass else : print ( 'The output file must be a PNG or JPG image.' ) return work_dir = os . path . dirname ( outfile ) if not os . path . exists ( work_dir ): os . makedirs ( work_dir ) screenshot = screen_capture ( outfile , monitor ) self . screenshot = screenshot","title":"to_image()"},{"location":"geemap/#geemap.geemap.Map.toolbar_reset","text":"Reset the toolbar so that no tool is selected. Source code in geemap/geemap.py def toolbar_reset ( self ): \"\"\"Reset the toolbar so that no tool is selected. \"\"\" toolbar_grid = self . toolbar for tool in toolbar_grid . children : tool . value = False","title":"toolbar_reset()"},{"location":"geemap/#geemap.geemap.Map.ts_inspector","text":"Creates a split-panel map for inspecting timeseries images. Parameters: Name Type Description Default left_ts object An ee.ImageCollection to show on the left panel. required right_ts object An ee.ImageCollection to show on the right panel. required left_names list A list of names to show under the left dropdown. required right_names list A list of names to show under the right dropdown. required left_vis dict Visualization parameters for the left layer. Defaults to {}. {} right_vis dict Visualization parameters for the right layer. Defaults to {}. {} Source code in geemap/geemap.py def ts_inspector ( self , left_ts , right_ts , left_names , right_names , left_vis = {}, right_vis = {}): \"\"\"Creates a split-panel map for inspecting timeseries images. Args: left_ts (object): An ee.ImageCollection to show on the left panel. right_ts (object): An ee.ImageCollection to show on the right panel. left_names (list): A list of names to show under the left dropdown. right_names (list): A list of names to show under the right dropdown. left_vis (dict, optional): Visualization parameters for the left layer. Defaults to {}. right_vis (dict, optional): Visualization parameters for the right layer. Defaults to {}. \"\"\" left_count = int ( left_ts . size () . getInfo ()) right_count = int ( right_ts . size () . getInfo ()) if left_count != len ( left_names ): print ( 'The number of images in left_ts must match the number of layer names in left_names.' ) return if right_count != len ( right_names ): print ( 'The number of images in right_ts must match the number of layer names in right_names.' ) return left_layer = TileLayer ( url = 'https://mt1.google.com/vt/lyrs=m&x= {x} &y= {y} &z= {z} ' , attribution = 'Google' , name = 'Google Maps' ) right_layer = TileLayer ( url = 'https://mt1.google.com/vt/lyrs=m&x= {x} &y= {y} &z= {z} ' , attribution = 'Google' , name = 'Google Maps' ) self . clear_controls () left_dropdown = widgets . Dropdown ( options = left_names , value = None ) right_dropdown = widgets . Dropdown ( options = right_names , value = None ) left_dropdown . layout . max_width = '130px' right_dropdown . layout . max_width = '130px' left_control = WidgetControl ( widget = left_dropdown , position = 'topleft' ) right_control = WidgetControl ( widget = right_dropdown , position = 'topright' ) self . add_control ( control = left_control ) self . add_control ( control = right_control ) self . add_control ( ZoomControl ( position = 'topleft' )) self . add_control ( ScaleControl ( position = 'bottomleft' )) self . add_control ( FullScreenControl ()) def left_dropdown_change ( change ): left_dropdown_index = left_dropdown . index if left_dropdown_index is not None and left_dropdown_index >= 0 : try : if isinstance ( left_ts , ee . ImageCollection ): left_image = left_ts . toList ( left_ts . size ()) . get ( left_dropdown_index ) elif isinstance ( left_ts , ee . List ): left_image = left_ts . get ( left_dropdown_index ) else : print ( 'The left_ts argument must be an ImageCollection.' ) return if isinstance ( left_image , ee . ImageCollection ): left_image = ee . Image ( left_image . mosaic ()) elif isinstance ( left_image , ee . Image ): pass else : left_image = ee . Image ( left_image ) left_image = ee_tile_layer ( left_image , left_vis , left_names [ left_dropdown_index ]) left_layer . url = left_image . url except Exception as e : print ( e ) return left_dropdown . observe ( left_dropdown_change , names = 'value' ) def right_dropdown_change ( change ): right_dropdown_index = right_dropdown . index if right_dropdown_index is not None and right_dropdown_index >= 0 : try : if isinstance ( right_ts , ee . ImageCollection ): right_image = right_ts . toList ( left_ts . size ()) . get ( right_dropdown_index ) elif isinstance ( right_ts , ee . List ): right_image = right_ts . get ( right_dropdown_index ) else : print ( 'The left_ts argument must be an ImageCollection.' ) return if isinstance ( right_image , ee . ImageCollection ): right_image = ee . Image ( right_image . mosaic ()) elif isinstance ( right_image , ee . Image ): pass else : right_image = ee . Image ( right_image ) right_image = ee_tile_layer ( right_image , right_vis , right_names [ right_dropdown_index ]) right_layer . url = right_image . url except Exception as e : print ( e ) return right_dropdown . observe ( right_dropdown_change , names = 'value' ) try : split_control = ipyleaflet . SplitMapControl ( left_layer = left_layer , right_layer = right_layer ) self . add_control ( split_control ) except Exception as e : print ( e )","title":"ts_inspector()"},{"location":"geemap/#geemap.geemap.Map.video_overlay","text":"Overlays a video from the Internet on the map. Parameters: Name Type Description Default url str http URL of the video, such as \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\" required bounds tuple bounding box of the video in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)). required name str name of the layer to show on the layer control. required Source code in geemap/geemap.py def video_overlay ( self , url , bounds , name ): \"\"\"Overlays a video from the Internet on the map. Args: url (str): http URL of the video, such as \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\" bounds (tuple): bounding box of the video in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)). name (str): name of the layer to show on the layer control. \"\"\" try : video = ipyleaflet . VideoOverlay ( url = url , bounds = bounds , name = name ) self . add_layer ( video ) except Exception as e : print ( e )","title":"video_overlay()"},{"location":"geemap/#geemap.geemap.add_image_to_gif","text":"Adds an image logo to a GIF image. Parameters: Name Type Description Default in_gif str Input file path to the GIF image. required out_gif str Output file path to the GIF image. required in_image str Input file path to the image. required xy tuple Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. None image_size tuple Resize image. Defaults to (80, 80). (80, 80) circle_mask bool Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False. False Source code in geemap/geemap.py def add_image_to_gif ( in_gif , out_gif , in_image , xy = None , image_size = ( 80 , 80 ), circle_mask = False ): \"\"\"Adds an image logo to a GIF image. Args: in_gif (str): Input file path to the GIF image. out_gif (str): Output file path to the GIF image. in_image (str): Input file path to the image. xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. image_size (tuple, optional): Resize image. Defaults to (80, 80). circle_mask (bool, optional): Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False. \"\"\" import io import warnings from PIL import Image , ImageDraw , ImageSequence , ImageFilter warnings . simplefilter ( 'ignore' ) in_gif = os . path . abspath ( in_gif ) is_url = False if in_image . startswith ( 'http' ): is_url = True if not os . path . exists ( in_gif ): print ( 'The input gif file does not exist.' ) return if ( not is_url ) and ( not os . path . exists ( in_image )): print ( 'The provided logo file does not exist.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) try : image = Image . open ( in_gif ) except Exception as e : print ( 'An error occurred while opening the image.' ) print ( e ) return try : if in_image . startswith ( 'http' ): logo_raw_image = open_image_from_url ( in_image ) else : in_image = os . path . abspath ( in_image ) logo_raw_image = Image . open ( in_image ) except Exception as e : print ( e ) logo_raw_size = logo_raw_image . size image_size = min ( logo_raw_size [ 0 ], image_size [ 0 ]), min ( logo_raw_size [ 1 ], image_size [ 1 ]) logo_image = logo_raw_image . convert ( 'RGBA' ) logo_image . thumbnail ( image_size , Image . ANTIALIAS ) W , H = image . size mask_im = None if circle_mask : mask_im = Image . new ( \"L\" , image_size , 0 ) draw = ImageDraw . Draw ( mask_im ) draw . ellipse (( 0 , 0 , image_size [ 0 ], image_size [ 1 ]), fill = 255 ) if has_transparency ( logo_raw_image ): mask_im = logo_image . copy () if xy is None : # default logo location is 5% width and 5% height of the image. xy = ( int ( 0.05 * W ), int ( 0.05 * H )) elif ( xy is not None ) and ( not isinstance ( xy , tuple )) and ( len ( xy ) == 2 ): print ( \"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\" ) return elif all ( isinstance ( item , int ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( x > 0 ) and ( x < W ) and ( y > 0 ) and ( y < H ): pass else : print ( 'xy is out of bounds. x must be within [0, {} ], and y must be within [0, {} ]' . format ( W , H )) return elif all ( isinstance ( item , str ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( '%' in x ) and ( '%' in y ): try : x = int ( float ( x . replace ( '%' , '' )) / 100.0 * W ) y = int ( float ( y . replace ( '%' , '' )) / 100.0 * H ) xy = ( x , y ) except Exception as e : print ( \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\" ) return else : print ( \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\" ) return try : frames = [] for index , frame in enumerate ( ImageSequence . Iterator ( image )): frame = frame . convert ( 'RGBA' ) frame . paste ( logo_image , xy , mask_im ) b = io . BytesIO () frame . save ( b , format = \"GIF\" ) frame = Image . open ( b ) frames . append ( frame ) frames [ 0 ] . save ( out_gif , save_all = True , append_images = frames [ 1 :]) except Exception as e : print ( e )","title":"add_image_to_gif()"},{"location":"geemap/#geemap.geemap.add_text_to_gif","text":"Adds animated text to a GIF image. Parameters: Name Type Description Default in_gif str The file path to the input GIF image. required out_gif str The file path to the output GIF image. required xy tuple Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. None text_sequence int, str, list Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None. None font_type str Font type. Defaults to \"arial.ttf\". 'arial.ttf' font_size int Font size. Defaults to 20. 20 font_color str Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff'). Defaults to '#000000'. '#000000' add_progress_bar bool Whether to add a progress bar at the bottom of the GIF. Defaults to True. True progress_bar_color str Color for the progress bar. Defaults to 'white'. 'white' progress_bar_height int Height of the progress bar. Defaults to 5. 5 duration int controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100. 100 loop int controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0. 0 Source code in geemap/geemap.py def add_text_to_gif ( in_gif , out_gif , xy = None , text_sequence = None , font_type = \"arial.ttf\" , font_size = 20 , font_color = '#000000' , add_progress_bar = True , progress_bar_color = 'white' , progress_bar_height = 5 , duration = 100 , loop = 0 ): \"\"\"Adds animated text to a GIF image. Args: in_gif (str): The file path to the input GIF image. out_gif (str): The file path to the output GIF image. xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None. text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None. font_type (str, optional): Font type. Defaults to \"arial.ttf\". font_size (int, optional): Font size. Defaults to 20. font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff'). Defaults to '#000000'. add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True. progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'. progress_bar_height (int, optional): Height of the progress bar. Defaults to 5. duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100. loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0. \"\"\" import io import pkg_resources import warnings from PIL import Image , ImageDraw , ImageSequence , ImageFont warnings . simplefilter ( 'ignore' ) pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) default_font = os . path . join ( pkg_dir , 'data/fonts/arial.ttf' ) in_gif = os . path . abspath ( in_gif ) out_gif = os . path . abspath ( out_gif ) if not os . path . exists ( in_gif ): print ( 'The input gif file does not exist.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) if font_type == 'arial.ttf' : font = ImageFont . truetype ( default_font , font_size ) else : try : font_list = system_fonts ( show_full_path = True ) font_names = [ os . path . basename ( f ) for f in font_list ] if ( font_type in font_list ) or ( font_type in font_names ): font = ImageFont . truetype ( font_type , font_size ) else : print ( 'The specified font type could not be found on your system. Using the default font instead.' ) font = ImageFont . truetype ( default_font , font_size ) except Exception as e : print ( e ) font = ImageFont . truetype ( default_font , font_size ) color = check_color ( font_color ) progress_bar_color = check_color ( progress_bar_color ) try : image = Image . open ( in_gif ) except Exception as e : print ( 'An error occurred while opening the gif.' ) print ( e ) return count = image . n_frames W , H = image . size progress_bar_widths = [ i * 1.0 / count * W for i in range ( 1 , count + 1 )] progress_bar_shapes = [[( 0 , H - progress_bar_height ), ( x , H )] for x in progress_bar_widths ] if xy is None : # default text location is 5% width and 5% height of the image. xy = ( int ( 0.05 * W ), int ( 0.05 * H )) elif ( xy is not None ) and ( not isinstance ( xy , tuple )) and ( len ( xy ) == 2 ): print ( \"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\" ) return elif all ( isinstance ( item , int ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( x > 0 ) and ( x < W ) and ( y > 0 ) and ( y < H ): pass else : print ( 'xy is out of bounds. x must be within [0, {} ], and y must be within [0, {} ]' . format ( W , H )) return elif all ( isinstance ( item , str ) for item in xy ) and ( len ( xy ) == 2 ): x , y = xy if ( '%' in x ) and ( '%' in y ): try : x = int ( float ( x . replace ( '%' , '' )) / 100.0 * W ) y = int ( float ( y . replace ( '%' , '' )) / 100.0 * H ) xy = ( x , y ) except Exception as e : print ( \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\" ) return else : print ( \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\" ) return if text_sequence is None : text = [ str ( x ) for x in range ( 1 , count + 1 )] elif isinstance ( text_sequence , int ): text = [ str ( x ) for x in range ( text_sequence , text_sequence + count + 1 )] elif isinstance ( text_sequence , str ): try : text_sequence = int ( text_sequence ) text = [ str ( x ) for x in range ( text_sequence , text_sequence + count + 1 )] except Exception as e : text = [ text_sequence ] * count elif isinstance ( text_sequence , list ) and len ( text_sequence ) != count : print ( 'The length of the text sequence must be equal to the number ( {} ) of frames in the gif.' . format ( count )) return else : text = [ str ( x ) for x in text_sequence ] try : frames = [] # Loop over each frame in the animated image for index , frame in enumerate ( ImageSequence . Iterator ( image )): # Draw the text on the frame frame = frame . convert ( 'RGB' ) draw = ImageDraw . Draw ( frame ) # w, h = draw.textsize(text[index]) draw . text ( xy , text [ index ], font = font , fill = color ) if add_progress_bar : draw . rectangle ( progress_bar_shapes [ index ], fill = progress_bar_color ) del draw b = io . BytesIO () frame . save ( b , format = \"GIF\" ) frame = Image . open ( b ) frames . append ( frame ) # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/ # Save the frames as a new image frames [ 0 ] . save ( out_gif , save_all = True , append_images = frames [ 1 :], duration = duration , loop = loop , optimize = True ) except Exception as e : print ( e )","title":"add_text_to_gif()"},{"location":"geemap/#geemap.geemap.adjust_longitude","text":"Adjusts longitude if it is less than -180 or greater than 180. Parameters: Name Type Description Default in_fc dict The input dictionary containing coordinates. required Returns: Type Description dict A dictionary containing the converted longitudes Source code in geemap/geemap.py def adjust_longitude ( in_fc ): \"\"\"Adjusts longitude if it is less than -180 or greater than 180. Args: in_fc (dict): The input dictionary containing coordinates. Returns: dict: A dictionary containing the converted longitudes \"\"\" try : keys = in_fc . keys () if 'geometry' in keys : coordinates = in_fc [ 'geometry' ][ 'coordinates' ] if in_fc [ 'geometry' ][ 'type' ] == 'Point' : longitude = coordinates [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'geometry' ][ 'coordinates' ][ 0 ] = longitude elif in_fc [ 'geometry' ][ 'type' ] == 'Polygon' : for index1 , item in enumerate ( coordinates ): for index2 , element in enumerate ( item ): longitude = element [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'geometry' ][ 'coordinates' ][ index1 ][ index2 ][ 0 ] = longitude elif in_fc [ 'geometry' ][ 'type' ] == 'LineString' : for index , element in enumerate ( coordinates ): longitude = element [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'geometry' ][ 'coordinates' ][ index ][ 0 ] = longitude elif 'type' in keys : coordinates = in_fc [ 'coordinates' ] if in_fc [ 'type' ] == 'Point' : longitude = coordinates [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'coordinates' ][ 0 ] = longitude elif in_fc [ 'type' ] == 'Polygon' : for index1 , item in enumerate ( coordinates ): for index2 , element in enumerate ( item ): longitude = element [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'coordinates' ][ index1 ][ index2 ][ 0 ] = longitude elif in_fc [ 'type' ] == 'LineString' : for index , element in enumerate ( coordinates ): longitude = element [ 0 ] if longitude < - 180 : longitude = 360 + longitude elif longitude > 180 : longitude = longitude - 360 in_fc [ 'coordinates' ][ index ][ 0 ] = longitude return in_fc except Exception as e : print ( e ) return None","title":"adjust_longitude()"},{"location":"geemap/#geemap.geemap.api_docs","text":"Open a browser and navigate to the geemap API documentation. Source code in geemap/geemap.py def api_docs (): \"\"\"Open a browser and navigate to the geemap API documentation. \"\"\" import webbrowser url = 'https://giswqs.github.io/geemap/geemap' webbrowser . open_new_tab ( url )","title":"api_docs()"},{"location":"geemap/#geemap.geemap.build_api_tree","text":"Builds an Earth Engine API tree view. Parameters: Name Type Description Default api_dict dict The dictionary containing information about each Earth Engine API function. required output_widget object An Output widget. required layout_width str The percentage width of the widget. Defaults to '100%'. '100%' Returns: Type Description tuple Returns a tuple containing two items: a tree Output widget and a tree dictionary. Source code in geemap/geemap.py def build_api_tree ( api_dict , output_widget , layout_width = '100%' ): \"\"\"Builds an Earth Engine API tree view. Args: api_dict (dict): The dictionary containing information about each Earth Engine API function. output_widget (object): An Output widget. layout_width (str, optional): The percentage width of the widget. Defaults to '100%'. Returns: tuple: Returns a tuple containing two items: a tree Output widget and a tree dictionary. \"\"\" import warnings warnings . filterwarnings ( 'ignore' ) tree = Tree () tree_dict = {} names = api_dict . keys () def handle_click ( event ): if event [ 'new' ]: name = event [ 'owner' ] . name values = api_dict [ name ] with output_widget : output_widget . clear_output () html_widget = widgets . HTML ( value = values [ 'html' ]) display ( html_widget ) for name in names : func_list = ee_function_tree ( name ) first = func_list [ 0 ] if first not in tree_dict . keys (): tree_dict [ first ] = Node ( first ) tree_dict [ first ] . opened = False tree . add_node ( tree_dict [ first ]) for index , func in enumerate ( func_list ): if index > 0 : if func not in tree_dict . keys (): node = tree_dict [ func_list [ index - 1 ]] node . opened = False tree_dict [ func ] = Node ( func ) node . add_node ( tree_dict [ func ]) if index == len ( func_list ) - 1 : node = tree_dict [ func_list [ index ]] node . icon = 'file' node . observe ( handle_click , 'selected' ) return tree , tree_dict","title":"build_api_tree()"},{"location":"geemap/#geemap.geemap.build_repo_tree","text":"Builds a repo tree for GEE account. Parameters: Name Type Description Default out_dir str The output directory for the repos. Defaults to None. None name str The output name for the repo directory. Defaults to 'gee_repos'. 'gee_repos' Returns: Type Description tuple Returns a tuple containing a tree widget, an output widget, and a tree dictionary containing nodes. Source code in geemap/geemap.py def build_repo_tree ( out_dir = None , name = 'gee_repos' ): \"\"\"Builds a repo tree for GEE account. Args: out_dir (str): The output directory for the repos. Defaults to None. name (str, optional): The output name for the repo directory. Defaults to 'gee_repos'. Returns: tuple: Returns a tuple containing a tree widget, an output widget, and a tree dictionary containing nodes. \"\"\" import warnings warnings . filterwarnings ( 'ignore' ) if out_dir is None : out_dir = os . path . join ( os . path . expanduser ( '~' )) repo_dir = os . path . join ( out_dir , name ) if not os . path . exists ( repo_dir ): os . makedirs ( repo_dir ) URLs = { # 'Owner': 'https://earthengine.googlesource.com/{}/default'.format(ee_user_id()), 'Writer' : '' , 'Reader' : 'https://github.com/giswqs/geemap' , 'Examples' : 'https://github.com/giswqs/earthengine-py-examples' , 'Archive' : 'https://earthengine.googlesource.com/EGU2017-EE101' } user_id = ee_user_id () if user_id is not None : URLs [ 'Owner' ] = 'https://earthengine.googlesource.com/ {} /default' . format ( ee_user_id ()) path_widget = widgets . Text ( placeholder = 'Enter the link to a Git repository here...' ) path_widget . layout . width = '475px' clone_widget = widgets . Button ( description = 'Clone' , button_style = 'primary' , tooltip = 'Clone the repository to folder.' ) info_widget = widgets . HBox () groups = [ 'Owner' , 'Writer' , 'Reader' , 'Examples' , 'Archive' ] for group in groups : group_dir = os . path . join ( repo_dir , group ) if not os . path . exists ( group_dir ): os . makedirs ( group_dir ) example_dir = os . path . join ( repo_dir , 'Examples/earthengine-py-examples' ) if not os . path . exists ( example_dir ): clone_github_repo ( URLs [ 'Examples' ], out_dir = example_dir ) left_widget , right_widget , tree_dict = file_browser ( in_dir = repo_dir , add_root_node = False , search_description = 'Filter scripts...' , use_import = True , return_sep_widgets = True ) info_widget . children = [ right_widget ] def handle_folder_click ( event ): if event [ 'new' ]: url = '' selected = event [ 'owner' ] if selected . name in URLs . keys (): url = URLs [ selected . name ] path_widget . value = url clone_widget . disabled = False info_widget . children = [ path_widget , clone_widget ] else : info_widget . children = [ right_widget ] for group in groups : dirname = os . path . join ( repo_dir , group ) node = tree_dict [ dirname ] node . observe ( handle_folder_click , 'selected' ) def handle_clone_click ( b ): url = path_widget . value default_dir = os . path . join ( repo_dir , 'Examples' ) if url == '' : path_widget . value = 'Please enter a valid URL to the repository.' else : for group in groups : key = os . path . join ( repo_dir , group ) node = tree_dict [ key ] if node . selected : default_dir = key try : path_widget . value = 'Cloning...' clone_dir = os . path . join ( default_dir , os . path . basename ( url )) if 'github.com' in url : clone_github_repo ( url , out_dir = clone_dir ) elif 'googlesource' in url : clone_google_repo ( url , out_dir = clone_dir ) path_widget . value = 'Cloned to {} ' . format ( clone_dir ) clone_widget . disabled = True except Exception as e : path_widget . value = 'An error occurred when trying to clone the repository ' + \\ str ( e ) clone_widget . disabled = True clone_widget . on_click ( handle_clone_click ) return left_widget , info_widget , tree_dict","title":"build_repo_tree()"},{"location":"geemap/#geemap.geemap.check_color","text":"Checks the input color and returns the corresponding hex color code. Parameters: Name Type Description Default in_color str or tuple It can be a string (e.g., 'red', '#ffff00') or tuple (e.g., (255, 127, 0)). required Returns: Type Description str A hex color code. Source code in geemap/geemap.py def check_color ( in_color ): \"\"\"Checks the input color and returns the corresponding hex color code. Args: in_color (str or tuple): It can be a string (e.g., 'red', '#ffff00') or tuple (e.g., (255, 127, 0)). Returns: str: A hex color code. \"\"\" out_color = '#000000' # default black color if isinstance ( in_color , tuple ) and len ( in_color ) == 3 : if all ( isinstance ( item , int ) for item in in_color ): rescaled_color = [ x / 255.0 for x in in_color ] out_color = colour . Color ( rgb = tuple ( rescaled_color )) return out_color . hex_l else : print ( 'RGB color must be a tuple with three integer values ranging from 0 to 255.' ) return else : try : out_color = colour . Color ( in_color ) return out_color . hex_l except Exception as e : print ( 'The provided color is invalid. Using the default black color.' ) print ( e ) return out_color","title":"check_color()"},{"location":"geemap/#geemap.geemap.check_git_install","text":"Checks if Git is installed. Returns: Type Description bool Returns True if Git is installed, otherwise returns False. Source code in geemap/geemap.py def check_git_install (): \"\"\"Checks if Git is installed. Returns: bool: Returns True if Git is installed, otherwise returns False. \"\"\" import webbrowser cmd = 'git --version' output = os . popen ( cmd ) . read () if 'git version' in output : return True else : url = 'https://git-scm.com/downloads' print ( \"Git is not installed. Please download Git from {} and install it.\" . format ( url )) webbrowser . open_new_tab ( url ) return False","title":"check_git_install()"},{"location":"geemap/#geemap.geemap.check_install","text":"Checks whether a package is installed. If not, it will install the package. Parameters: Name Type Description Default package str The name of the package to check. required Source code in geemap/geemap.py def check_install ( package ): \"\"\"Checks whether a package is installed. If not, it will install the package. Args: package (str): The name of the package to check. \"\"\" import subprocess try : __import__ ( package ) # print('{} is already installed.'.format(package)) except ImportError : print ( ' {} is not installed. Installing ...' . format ( package )) try : subprocess . check_call ([ \"python\" , '-m' , 'pip' , 'install' , package ]) except Exception as e : print ( 'Failed to install {} ' . format ( package )) print ( e ) print ( \" {} has been installed successfully.\" . format ( package ))","title":"check_install()"},{"location":"geemap/#geemap.geemap.clone_github_repo","text":"Clones a GitHub repository. Parameters: Name Type Description Default url str The link to the GitHub repository required out_dir str The output directory for the cloned repository. required Source code in geemap/geemap.py def clone_github_repo ( url , out_dir ): \"\"\"Clones a GitHub repository. Args: url (str): The link to the GitHub repository out_dir (str): The output directory for the cloned repository. \"\"\" import zipfile repo_name = os . path . basename ( url ) # url_zip = os.path.join(url, 'archive/master.zip') url_zip = url + '/archive/master.zip' if os . path . exists ( out_dir ): print ( 'The specified output directory already exists. Please choose a new directory.' ) return parent_dir = os . path . dirname ( out_dir ) out_file_path = os . path . join ( parent_dir , repo_name + '.zip' ) try : urllib . request . urlretrieve ( url_zip , out_file_path ) except : print ( \"The provided URL is invalid. Please double check the URL.\" ) return with zipfile . ZipFile ( out_file_path , \"r\" ) as zip_ref : zip_ref . extractall ( parent_dir ) src = out_file_path . replace ( '.zip' , '-master' ) os . rename ( src , out_dir ) os . remove ( out_file_path )","title":"clone_github_repo()"},{"location":"geemap/#geemap.geemap.clone_github_repo2","text":"Clones a GitHub repository. Parameters: Name Type Description Default url str The link to the GitHub repository required out_dir str The output directory for the cloned repository. Defaults to None. None Source code in geemap/geemap.py def clone_github_repo2 ( url , out_dir = None ): \"\"\"Clones a GitHub repository. Args: url (str): The link to the GitHub repository out_dir (str, optional): The output directory for the cloned repository. Defaults to None. \"\"\" check_install ( 'dulwich' ) from dulwich import porcelain repo_name = os . path . basename ( url ) if out_dir is None : out_dir = os . path . join ( os . getcwd (), repo_name ) if not os . path . exists ( os . path . dirname ( out_dir )): os . makedirs ( os . path . dirname ( out_dir )) if os . path . exists ( out_dir ): print ( 'The specified output directory already exists. Please choose a new directory.' ) return try : porcelain . clone ( url , out_dir ) except Exception as e : print ( 'Failed to clone the repository.' ) print ( e )","title":"clone_github_repo2()"},{"location":"geemap/#geemap.geemap.clone_google_repo","text":"Clones an Earth Engine repository from https://earthengine.googlesource.com, such as https://earthengine.googlesource.com/users/google/datasets Parameters: Name Type Description Default url str The link to the Earth Engine repository required out_dir str The output directory for the cloned repository. Defaults to None. None Source code in geemap/geemap.py def clone_google_repo ( url , out_dir = None ): \"\"\"Clones an Earth Engine repository from https://earthengine.googlesource.com, such as https://earthengine.googlesource.com/users/google/datasets Args: url (str): The link to the Earth Engine repository out_dir (str, optional): The output directory for the cloned repository. Defaults to None. \"\"\" repo_name = os . path . basename ( url ) if out_dir is None : out_dir = os . path . join ( os . getcwd (), repo_name ) if not os . path . exists ( os . path . dirname ( out_dir )): os . makedirs ( os . path . dirname ( out_dir )) if os . path . exists ( out_dir ): print ( 'The specified output directory already exists. Please choose a new directory.' ) return if check_git_install (): cmd = 'git clone \" {} \" \" {} \"' . format ( url , out_dir ) os . popen ( cmd ) . read ()","title":"clone_google_repo()"},{"location":"geemap/#geemap.geemap.clone_repo","text":"Clones the geemap GitHub repository. Parameters: Name Type Description Default out_dir str Output folder for the repo. Defaults to '.'. '.' unzip bool Whether to unzip the repository. Defaults to True. True Source code in geemap/geemap.py def clone_repo ( out_dir = '.' , unzip = True ): \"\"\"Clones the geemap GitHub repository. Args: out_dir (str, optional): Output folder for the repo. Defaults to '.'. unzip (bool, optional): Whether to unzip the repository. Defaults to True. \"\"\" url = 'https://github.com/giswqs/geemap/archive/master.zip' filename = 'geemap-master.zip' download_from_url ( url , out_file_name = filename , out_dir = out_dir , unzip = unzip )","title":"clone_repo()"},{"location":"geemap/#geemap.geemap.copy_credentials_to_colab","text":"Copies ee credentials from Google Drive to Google Colab. Source code in geemap/geemap.py def copy_credentials_to_colab (): \"\"\"Copies ee credentials from Google Drive to Google Colab. \"\"\" import shutil src = '/content/drive/My Drive/.config/earthengine/credentials' dst = '/root/.config/earthengine/credentials' wd = os . path . dirname ( dst ) if not os . path . exists ( wd ): os . makedirs ( wd ) shutil . copyfile ( src , dst )","title":"copy_credentials_to_colab()"},{"location":"geemap/#geemap.geemap.copy_credentials_to_drive","text":"Copies ee credentials from Google Colab to Google Drive. Source code in geemap/geemap.py def copy_credentials_to_drive (): \"\"\"Copies ee credentials from Google Colab to Google Drive. \"\"\" import shutil src = '/root/.config/earthengine/credentials' dst = '/content/drive/My Drive/.config/earthengine/credentials' wd = os . path . dirname ( dst ) if not os . path . exists ( wd ): os . makedirs ( wd ) shutil . copyfile ( src , dst )","title":"copy_credentials_to_drive()"},{"location":"geemap/#geemap.geemap.create_code_cell","text":"Creates a code cell in the IPython Notebook. Parameters: Name Type Description Default code str Code to fill the new code cell with. Defaults to ''. '' where str Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. 'below' Source code in geemap/geemap.py def create_code_cell ( code = '' , where = 'below' ): \"\"\"Creates a code cell in the IPython Notebook. Args: code (str, optional): Code to fill the new code cell with. Defaults to ''. where (str, optional): Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. \"\"\" import base64 from IPython.display import Javascript , display encoded_code = ( base64 . b64encode ( str . encode ( code ))) . decode () display ( Javascript ( \"\"\" var code = IPython.notebook.insert_cell_ {0} ('code'); code.set_text(atob(\" {1} \")); \"\"\" . format ( where , encoded_code )))","title":"create_code_cell()"},{"location":"geemap/#geemap.geemap.create_colorbar","text":"Creates a colorbar based on the provided palette. Parameters: Name Type Description Default width int Width of the colorbar in pixels. Defaults to 150. 150 height int Height of the colorbar in pixels. Defaults to 30. 30 palette list Palette for the colorbar. Each color can be provided as a string (e.g., 'red'), a hex string (e.g., '#ff0000'), or an RGB tuple (255, 0, 255). Defaults to ['blue', 'green', 'red']. ['blue', 'green', 'red'] add_ticks bool Whether to add tick markers to the colorbar. Defaults to True. True add_labels bool Whether to add labels to the colorbar. Defaults to True. True labels list A list of labels to add to the colorbar. Defaults to None. None vertical bool Whether to rotate the colorbar vertically. Defaults to False. False out_file str File path to the output colorbar in png format. Defaults to None. None font_type str Font type to use for labels. Defaults to 'arial.ttf'. 'arial.ttf' font_size int Font size to use for labels. Defaults to 12. 12 font_color str Font color to use for labels. Defaults to 'black'. 'black' add_outline bool Whether to add an outline to the colorbar. Defaults to True. True outline_color str Color for the outline of the colorbar. Defaults to 'black'. 'black' Returns: Type Description str File path of the output colorbar in png format. Source code in geemap/geemap.py def create_colorbar ( width = 150 , height = 30 , palette = [ 'blue' , 'green' , 'red' ], add_ticks = True , add_labels = True , labels = None , vertical = False , out_file = None , font_type = 'arial.ttf' , font_size = 12 , font_color = 'black' , add_outline = True , outline_color = 'black' ): \"\"\"Creates a colorbar based on the provided palette. Args: width (int, optional): Width of the colorbar in pixels. Defaults to 150. height (int, optional): Height of the colorbar in pixels. Defaults to 30. palette (list, optional): Palette for the colorbar. Each color can be provided as a string (e.g., 'red'), a hex string (e.g., '#ff0000'), or an RGB tuple (255, 0, 255). Defaults to ['blue', 'green', 'red']. add_ticks (bool, optional): Whether to add tick markers to the colorbar. Defaults to True. add_labels (bool, optional): Whether to add labels to the colorbar. Defaults to True. labels (list, optional): A list of labels to add to the colorbar. Defaults to None. vertical (bool, optional): Whether to rotate the colorbar vertically. Defaults to False. out_file (str, optional): File path to the output colorbar in png format. Defaults to None. font_type (str, optional): Font type to use for labels. Defaults to 'arial.ttf'. font_size (int, optional): Font size to use for labels. Defaults to 12. font_color (str, optional): Font color to use for labels. Defaults to 'black'. add_outline (bool, optional): Whether to add an outline to the colorbar. Defaults to True. outline_color (str, optional): Color for the outline of the colorbar. Defaults to 'black'. Returns: str: File path of the output colorbar in png format. \"\"\" import decimal import io import pkg_resources import warnings from colour import Color from PIL import Image , ImageDraw , ImageFont warnings . simplefilter ( 'ignore' ) pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) if out_file is None : filename = 'colorbar_' + random_string () + '.png' out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) out_file = os . path . join ( out_dir , filename ) elif not out_file . endswith ( '.png' ): print ( 'The output file must end with .png' ) return else : out_file = os . path . abspath ( out_file ) if not os . path . exists ( os . path . dirname ( out_file )): os . makedirs ( os . path . dirname ( out_file )) im = Image . new ( 'RGBA' , ( width , height )) ld = im . load () def float_range ( start , stop , step ): while start < stop : yield float ( start ) start += decimal . Decimal ( step ) n_colors = len ( palette ) decimal_places = 2 rgb_colors = [ Color ( check_color ( c )) . rgb for c in palette ] keys = [ round ( c , decimal_places ) for c in list ( float_range ( 0 , 1.0001 , 1.0 / ( n_colors - 1 )))] heatmap = [] for index , item in enumerate ( keys ): pair = [ item , rgb_colors [ index ]] heatmap . append ( pair ) def gaussian ( x , a , b , c , d = 0 ): return a * math . exp ( - ( x - b ) ** 2 / ( 2 * c ** 2 )) + d def pixel ( x , width = 100 , map = [], spread = 1 ): width = float ( width ) r = sum ([ gaussian ( x , p [ 1 ][ 0 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) g = sum ([ gaussian ( x , p [ 1 ][ 1 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) b = sum ([ gaussian ( x , p [ 1 ][ 2 ], p [ 0 ] * width , width / ( spread * len ( map ))) for p in map ]) return min ( 1.0 , r ), min ( 1.0 , g ), min ( 1.0 , b ) for x in range ( im . size [ 0 ]): r , g , b = pixel ( x , width = width , map = heatmap ) r , g , b = [ int ( 256 * v ) for v in ( r , g , b )] for y in range ( im . size [ 1 ]): ld [ x , y ] = r , g , b if add_outline : draw = ImageDraw . Draw ( im ) draw . rectangle ([( 0 , 0 ), ( width - 1 , height - 1 )], outline = check_color ( outline_color )) del draw if add_ticks : tick_length = height * 0.1 x = [ key * width for key in keys ] y_top = height - tick_length y_bottom = height draw = ImageDraw . Draw ( im ) for i in x : shape = [( i , y_top ), ( i , y_bottom )] draw . line ( shape , fill = 'black' , width = 0 ) del draw if vertical : im = im . transpose ( Image . ROTATE_90 ) width , height = im . size if labels is None : labels = [ str ( c ) for c in keys ] elif len ( labels ) == 2 : try : lowerbound = float ( labels [ 0 ]) upperbound = float ( labels [ 1 ]) step = ( upperbound - lowerbound ) / ( len ( palette ) - 1 ) labels = [ str ( lowerbound + c * step ) for c in range ( 0 , len ( palette ))] except Exception as e : print ( e ) print ( 'The labels are invalid.' ) return elif len ( labels ) == len ( palette ): labels = [ str ( c ) for c in labels ] else : print ( 'The labels must have the same length as the palette.' ) return if add_labels : default_font = os . path . join ( pkg_dir , 'data/fonts/arial.ttf' ) if font_type == 'arial.ttf' : font = ImageFont . truetype ( default_font , font_size ) else : try : font_list = system_fonts ( show_full_path = True ) font_names = [ os . path . basename ( f ) for f in font_list ] if ( font_type in font_list ) or ( font_type in font_names ): font = ImageFont . truetype ( font_type , font_size ) else : print ( 'The specified font type could not be found on your system. Using the default font instead.' ) font = ImageFont . truetype ( default_font , font_size ) except Exception as e : print ( e ) font = ImageFont . truetype ( default_font , font_size ) font_color = check_color ( font_color ) draw = ImageDraw . Draw ( im ) w , h = draw . textsize ( labels [ 0 ], font = font ) for label in labels : w_tmp , h_tmp = draw . textsize ( label , font ) if w_tmp > w : w = w_tmp if h_tmp > h : h = h_tmp W , H = width + w * 2 , height + h * 2 background = Image . new ( 'RGBA' , ( W , H )) draw = ImageDraw . Draw ( background ) if vertical : xy = ( 0 , h ) else : xy = ( w , 0 ) background . paste ( im , xy , im ) for index , label in enumerate ( labels ): w_tmp , h_tmp = draw . textsize ( label , font ) if vertical : spacing = 5 x = width + spacing y = int ( height + h - keys [ index ] * height - h_tmp / 2 - 1 ) draw . text (( x , y ), label , font = font , fill = font_color ) else : x = int ( keys [ index ] * width + w - w_tmp / 2 ) spacing = int ( h * 0.05 ) y = height + spacing draw . text (( x , y ), label , font = font , fill = font_color ) im = background . copy () im . save ( out_file ) return out_file","title":"create_colorbar()"},{"location":"geemap/#geemap.geemap.create_download_link","text":"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578 Parameters: Name Type Description Default filename str The file path to the file to download required title str str. Defaults to \"Click here to download: \". 'Click here to download: ' Returns: Type Description str HTML download URL. Source code in geemap/geemap.py def create_download_link ( filename , title = \"Click here to download: \" ): \"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578 Args: filename (str): The file path to the file to download title (str, optional): str. Defaults to \"Click here to download: \". Returns: str: HTML download URL. \"\"\" import base64 from IPython.display import HTML data = open ( filename , \"rb\" ) . read () b64 = base64 . b64encode ( data ) payload = b64 . decode () basename = os . path . basename ( filename ) html = '<a download=\" {filename} \" href=\"data:text/csv;base64, {payload} \" style=\"color:#0000FF;\" target=\"_blank\"> {title} </a>' html = html . format ( payload = payload , title = title + f ' { basename } ' , filename = basename ) return HTML ( html )","title":"create_download_link()"},{"location":"geemap/#geemap.geemap.credentials_in_colab","text":"Checks if the ee credentials file exists in Google Colab. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/geemap.py def credentials_in_colab (): \"\"\"Checks if the ee credentials file exists in Google Colab. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" credentials_path = '/root/.config/earthengine/credentials' if os . path . exists ( credentials_path ): return True else : return False","title":"credentials_in_colab()"},{"location":"geemap/#geemap.geemap.credentials_in_drive","text":"Checks if the ee credentials file exists in Google Drive. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/geemap.py def credentials_in_drive (): \"\"\"Checks if the ee credentials file exists in Google Drive. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" credentials_path = '/content/drive/My Drive/.config/earthengine/credentials' if os . path . exists ( credentials_path ): return True else : return False","title":"credentials_in_drive()"},{"location":"geemap/#geemap.geemap.csv_to_shp","text":"Converts a csv file with latlon info to a point shapefile. Parameters: Name Type Description Default in_csv str The input csv file containing longitude and latitude columns. required out_shp str The file path to the output shapefile. required longitude str The column name of the longitude column. Defaults to 'longitude'. 'longitude' latitude str The column name of the latitude column. Defaults to 'latitude'. 'latitude' Source code in geemap/geemap.py def csv_to_shp ( in_csv , out_shp , longitude = 'longitude' , latitude = 'latitude' ): \"\"\"Converts a csv file with latlon info to a point shapefile. Args: in_csv (str): The input csv file containing longitude and latitude columns. out_shp (str): The file path to the output shapefile. longitude (str, optional): The column name of the longitude column. Defaults to 'longitude'. latitude (str, optional): The column name of the latitude column. Defaults to 'latitude'. \"\"\" import csv import shapefile as shp if not os . path . exists ( in_csv ): print ( 'The provided CSV file does not exist.' ) return if not in_csv . endswith ( '.csv' ): print ( 'The input file must end with .csv' ) return out_dir = os . path . dirname ( out_shp ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) try : points = shp . Writer ( out_shp , shapeType = shp . POINT ) with open ( in_csv ) as csvfile : csvreader = csv . DictReader ( csvfile ) header = csvreader . fieldnames [ points . field ( field ) for field in header ] for row in csvreader : points . point (( float ( row [ longitude ])), ( float ( row [ latitude ]))) points . record ( * tuple ([ row [ f ] for f in header ])) out_prj = out_shp . replace ( '.shp' , '.prj' ) with open ( out_prj , 'w' ) as f : prj_str = 'GEOGCS[\"GCS_WGS_1984\",DATUM[\"D_WGS_1984\",SPHEROID[\"WGS_1984\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"Degree\",0.0174532925199433]] ' f . write ( prj_str ) except Exception as e : print ( e )","title":"csv_to_shp()"},{"location":"geemap/#geemap.geemap.date_sequence","text":"Creates a date sequence. Parameters: Name Type Description Default start str The start date, e.g., '2000-01-01'. required end str The end date, e.g., '2000-12-31'. required unit str One of 'year', 'month' 'week', 'day', 'hour', 'minute', or 'second'. required date_format str A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'. 'YYYY-MM-dd' Returns: Type Description ee.List A list of date sequence. Source code in geemap/geemap.py def date_sequence ( start , end , unit , date_format = 'YYYY-MM-dd' ): \"\"\"Creates a date sequence. Args: start (str): The start date, e.g., '2000-01-01'. end (str): The end date, e.g., '2000-12-31'. unit (str): One of 'year', 'month' 'week', 'day', 'hour', 'minute', or 'second'. date_format (str, optional): A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'. Returns: ee.List: A list of date sequence. \"\"\" start_date = ee . Date ( start ) end_date = ee . Date ( end ) count = ee . Number ( end_date . difference ( start_date , unit )) . toInt () num_seq = ee . List . sequence ( 0 , count ) date_seq = num_seq . map ( lambda d : start_date . advance ( d , unit ) . format ( date_format )) return date_seq","title":"date_sequence()"},{"location":"geemap/#geemap.geemap.download_ee_video","text":"Downloads a video thumbnail as a GIF image from Earth Engine. Parameters: Name Type Description Default collection object An ee.ImageCollection. required video_args object Parameters for expring the video thumbnail. required out_gif str File path to the output GIF. required Source code in geemap/geemap.py def download_ee_video ( collection , video_args , out_gif ): \"\"\"Downloads a video thumbnail as a GIF image from Earth Engine. Args: collection (object): An ee.ImageCollection. video_args (object): Parameters for expring the video thumbnail. out_gif (str): File path to the output GIF. \"\"\" import requests out_gif = os . path . abspath ( out_gif ) if not out_gif . endswith ( \".gif\" ): print ( 'The output file must have an extension of .gif.' ) return if not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) if 'region' in video_args . keys (): roi = video_args [ 'region' ] if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return video_args [ 'region' ] = roi try : print ( 'Generating URL...' ) url = collection . getVideoThumbURL ( video_args ) print ( 'Downloading GIF image from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading.' ) return else : with open ( out_gif , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) print ( 'The GIF image has been saved to: {} ' . format ( out_gif )) except Exception as e : print ( e )","title":"download_ee_video()"},{"location":"geemap/#geemap.geemap.edit_download_html","text":"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058 Parameters: Name Type Description Default htmlWidget object The HTML widget to display the URL. required filename str File path to download. required title str Download description. Defaults to \"Click here to download: \". 'Click here to download: ' Source code in geemap/geemap.py def edit_download_html ( htmlWidget , filename , title = \"Click here to download: \" ): \"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058 Args: htmlWidget (object): The HTML widget to display the URL. filename (str): File path to download. title (str, optional): Download description. Defaults to \"Click here to download: \". \"\"\" from IPython.display import HTML import ipywidgets as widgets import base64 # Change widget html temperarily to a font-awesome spinner htmlWidget . value = \"<i class= \\\" fa fa-spinner fa-spin fa-2x fa-fw \\\" ></i><span class= \\\" sr-only \\\" >Loading...</span>\" # Process raw data data = open ( filename , \"rb\" ) . read () b64 = base64 . b64encode ( data ) payload = b64 . decode () basename = os . path . basename ( filename ) # Create and assign html to widget html = '<a download=\" {filename} \" href=\"data:text/csv;base64, {payload} \" target=\"_blank\"> {title} </a>' htmlWidget . value = html . format ( payload = payload , title = title + basename , filename = basename )","title":"edit_download_html()"},{"location":"geemap/#geemap.geemap.ee_api_to_csv","text":"Extracts Earth Engine API documentation from https://developers.google.com/earth-engine/api_docs as a csv file. Parameters: Name Type Description Default outfile str The output file path to a csv file. Defaults to None. None Source code in geemap/geemap.py def ee_api_to_csv ( outfile = None ): \"\"\"Extracts Earth Engine API documentation from https://developers.google.com/earth-engine/api_docs as a csv file. Args: outfile (str, optional): The output file path to a csv file. Defaults to None. \"\"\" import csv import requests from bs4 import BeautifulSoup pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) data_dir = os . path . join ( pkg_dir , 'data' ) template_dir = os . path . join ( data_dir , 'template' ) csv_file = os . path . join ( template_dir , 'ee_api_docs.csv' ) if outfile is None : outfile = csv_file else : if not outfile . endswith ( '.csv' ): print ( 'The output file must end with .csv' ) return else : out_dir = os . path . dirname ( outfile ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) url = 'https://developers.google.com/earth-engine/api_docs' try : r = requests . get ( url ) soup = BeautifulSoup ( r . content , 'html.parser' ) names = [] descriptions = [] functions = [] returns = [] arguments = [] types = [] details = [] names = [ h2 . text for h2 in soup . find_all ( 'h2' )] descriptions = [ h2 . next_sibling . next_sibling . text for h2 in soup . find_all ( 'h2' )] func_tables = soup . find_all ( 'table' , class_ = 'blue' ) functions = [ func_table . find ( 'code' ) . text for func_table in func_tables ] returns = [ func_table . find_all ( 'td' )[ 1 ] . text for func_table in func_tables ] detail_tables = [] tables = soup . find_all ( 'table' , class_ = 'blue' ) for table in tables : item = table . next_sibling if item . attrs == { 'class' : [ 'details' ]}: detail_tables . append ( item ) else : detail_tables . append ( \"\" ) for detail_table in detail_tables : if detail_table != '' : items = [ item . text for item in detail_table . find_all ( 'code' )] else : items = \"\" arguments . append ( items ) for detail_table in detail_tables : if detail_table != '' : items = [ item . text for item in detail_table . find_all ( 'td' )] items = items [ 1 :: 3 ] else : items = \"\" types . append ( items ) for detail_table in detail_tables : if detail_table != '' : items = [ item . text for item in detail_table . find_all ( 'p' )] else : items = \"\" details . append ( items ) csv_file = open ( outfile , 'w' , encoding = 'utf-8' ) csv_writer = csv . writer ( csv_file , delimiter = ' \\t ' ) csv_writer . writerow ( [ 'name' , 'description' , 'function' , 'returns' , 'argument' , 'type' , 'details' ]) for i in range ( len ( names )): name = names [ i ] description = descriptions [ i ] function = functions [ i ] return_type = returns [ i ] argument = '|' . join ( arguments [ i ]) argu_type = '|' . join ( types [ i ]) detail = '|' . join ( details [ i ]) csv_writer . writerow ( [ name , description , function , return_type , argument , argu_type , detail ]) csv_file . close () except Exception as e : print ( e )","title":"ee_api_to_csv()"},{"location":"geemap/#geemap.geemap.ee_data_html","text":"Generates HTML from an asset to be used in the HTML widget. Parameters: Name Type Description Default asset dict A dictionary containing an Earth Engine asset. required Returns: Type Description str A string containing HTML. Source code in geemap/geemap.py def ee_data_html ( asset ): \"\"\"Generates HTML from an asset to be used in the HTML widget. Args: asset (dict): A dictionary containing an Earth Engine asset. Returns: str: A string containing HTML. \"\"\" template = ''' <html> <body> <h3>asset_title</h3> <h4>Dataset Availability</h4> <p style=\"margin-left: 40px\">asset_dates</p> <h4>Earth Engine Snippet</h4> <p style=\"margin-left: 40px\">ee_id_snippet</p> <h4>Earth Engine Data Catalog</h4> <p style=\"margin-left: 40px\"><a href=\"asset_url\" target=\"_blank\">asset_id</a></p> <h4>Dataset Thumbnail</h4> <img src=\"thumbnail_url\"> </body> </html> ''' try : text = template . replace ( 'asset_title' , asset [ 'title' ]) text = text . replace ( 'asset_dates' , asset [ 'dates' ]) text = text . replace ( 'ee_id_snippet' , asset [ 'ee_id_snippet' ]) text = text . replace ( 'asset_id' , asset [ 'id' ]) text = text . replace ( 'asset_url' , asset [ 'asset_url' ]) # asset['thumbnail'] = ee_data_thumbnail(asset['id']) text = text . replace ( 'thumbnail_url' , asset [ 'thumbnail_url' ]) return text except Exception as e : print ( e )","title":"ee_data_html()"},{"location":"geemap/#geemap.geemap.ee_data_thumbnail","text":"Retrieves the thumbnail URL of an Earth Engine asset. Parameters: Name Type Description Default asset_id str An Earth Engine asset id. required Returns: Type Description str An http url of the thumbnail. Source code in geemap/geemap.py def ee_data_thumbnail ( asset_id ): \"\"\"Retrieves the thumbnail URL of an Earth Engine asset. Args: asset_id (str): An Earth Engine asset id. Returns: str: An http url of the thumbnail. \"\"\" import requests import urllib from bs4 import BeautifulSoup asset_uid = asset_id . replace ( '/' , '_' ) asset_url = \"https://developers.google.com/earth-engine/datasets/catalog/ {} \" . format ( asset_uid ) thumbnail_url = 'https://mw1.google.com/ges/dd/images/ {} _sample.png' . format ( asset_uid ) r = requests . get ( thumbnail_url ) try : if r . status_code != 200 : html_page = urllib . request . urlopen ( asset_url ) soup = BeautifulSoup ( html_page , features = \"html.parser\" ) for img in soup . findAll ( 'img' ): if 'sample.png' in img . get ( 'src' ): thumbnail_url = img . get ( 'src' ) return thumbnail_url return thumbnail_url except Exception as e : print ( e )","title":"ee_data_thumbnail()"},{"location":"geemap/#geemap.geemap.ee_export_geojson","text":"Exports Earth Engine FeatureCollection to geojson. Parameters: Name Type Description Default ee_object object ee.FeatureCollection to export. required filename str Output file name. Defaults to None. None selectors list A list of attributes to export. Defaults to None. None Source code in geemap/geemap.py def ee_export_geojson ( ee_object , filename = None , selectors = None ): \"\"\"Exports Earth Engine FeatureCollection to geojson. Args: ee_object (object): ee.FeatureCollection to export. filename (str): Output file name. Defaults to None. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" import requests import zipfile # ee_initialize() if not isinstance ( ee_object , ee . FeatureCollection ): print ( 'The ee_object must be an ee.FeatureCollection.' ) return if filename is None : out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) filename = os . path . join ( out_dir , random_string ( 6 ) + '.geojson' ) allowed_formats = [ 'geojson' ] filename = os . path . abspath ( filename ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () if not ( filetype . lower () in allowed_formats ): print ( 'The output file type must be geojson.' ) return if selectors is None : selectors = ee_object . first () . propertyNames () . getInfo () selectors = [ '.geo' ] + selectors elif not isinstance ( selectors , list ): print ( \"selectors must be a list, such as ['attribute1', 'attribute2']\" ) return else : allowed_attributes = ee_object . first () . propertyNames () . getInfo () for attribute in selectors : if not ( attribute in allowed_attributes ): print ( 'Attributes must be one chosen from: {} ' . format ( ', ' . join ( allowed_attributes ))) return try : # print('Generating URL ...') url = ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) # print('Downloading data from {}\\nPlease wait ...'.format(url)) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading. \\n Retrying ...' ) try : new_ee_object = ee_object . map ( filter_polygons ) print ( 'Generating URL ...' ) url = new_ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) except Exception as e : print ( e ) with open ( filename , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) except Exception as e : print ( 'An error occurred while downloading.' ) print ( e ) return with open ( filename ) as f : geojson = f . read () return geojson","title":"ee_export_geojson()"},{"location":"geemap/#geemap.geemap.ee_export_image","text":"Exports an ee.Image as a GeoTIFF. Parameters: Name Type Description Default ee_object object The ee.Image to download. required filename str Output filename for the exported image. required scale float A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. None crs str A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. None region object A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. None file_per_band bool Whether to produce a different GeoTIFF per band. Defaults to False. False Source code in geemap/geemap.py def ee_export_image ( ee_object , filename , scale = None , crs = None , region = None , file_per_band = False ): \"\"\"Exports an ee.Image as a GeoTIFF. Args: ee_object (object): The ee.Image to download. filename (str): Output filename for the exported image. scale (float, optional): A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. crs (str, optional): A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. region (object, optional): A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. file_per_band (bool, optional): Whether to produce a different GeoTIFF per band. Defaults to False. \"\"\" import requests import zipfile # ee_initialize() if not isinstance ( ee_object , ee . Image ): print ( 'The ee_object must be an ee.Image.' ) return filename = os . path . abspath ( filename ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () filename_zip = filename . replace ( '.tif' , '.zip' ) if filetype != 'tif' : print ( 'The filename must end with .tif' ) return try : print ( 'Generating URL ...' ) params = { 'name' : name , 'filePerBand' : file_per_band } if scale is None : scale = ee_object . projection () . nominalScale () . multiply ( 10 ) params [ 'scale' ] = scale if region is None : region = ee_object . geometry () params [ 'region' ] = region if crs is not None : params [ 'crs' ] = crs url = ee_object . getDownloadURL ( params ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading.' ) return with open ( filename_zip , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) except Exception as e : print ( 'An error occurred while downloading.' ) print ( e ) return try : z = zipfile . ZipFile ( filename_zip ) z . extractall ( os . path . dirname ( filename )) z . close () os . remove ( filename_zip ) if file_per_band : print ( 'Data downloaded to {} ' . format ( os . path . dirname ( filename ))) else : print ( 'Data downloaded to {} ' . format ( filename )) except Exception as e : print ( e )","title":"ee_export_image()"},{"location":"geemap/#geemap.geemap.ee_export_image_collection","text":"Exports an ImageCollection as GeoTIFFs. Parameters: Name Type Description Default ee_object object The ee.Image to download. required out_dir str The output directory for the exported images. required scale float A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. None crs str A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. None region object A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. None file_per_band bool Whether to produce a different GeoTIFF per band. Defaults to False. False Source code in geemap/geemap.py def ee_export_image_collection ( ee_object , out_dir , scale = None , crs = None , region = None , file_per_band = False ): \"\"\"Exports an ImageCollection as GeoTIFFs. Args: ee_object (object): The ee.Image to download. out_dir (str): The output directory for the exported images. scale (float, optional): A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None. crs (str, optional): A default CRS string to use for any bands that do not explicitly specify one. Defaults to None. region (object, optional): A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None. file_per_band (bool, optional): Whether to produce a different GeoTIFF per band. Defaults to False. \"\"\" import requests import zipfile # ee_initialize() if not isinstance ( ee_object , ee . ImageCollection ): print ( 'The ee_object must be an ee.ImageCollection.' ) return if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) try : count = int ( ee_object . size () . getInfo ()) print ( \"Total number of images: {} \\n \" . format ( count )) for i in range ( 0 , count ): image = ee . Image ( ee_object . toList ( count ) . get ( i )) name = image . get ( 'system:index' ) . getInfo () + '.tif' filename = os . path . join ( os . path . abspath ( out_dir ), name ) print ( 'Exporting {} / {} : {} ' . format ( i + 1 , count , name )) ee_export_image ( image , filename = filename , scale = scale , crs = crs , region = region , file_per_band = file_per_band ) print ( ' \\n ' ) except Exception as e : print ( e )","title":"ee_export_image_collection()"},{"location":"geemap/#geemap.geemap.ee_export_image_collection_to_drive","text":"Creates a batch task to export an ImageCollection as raster images to Google Drive. Parameters: Name Type Description Default ee_object object The image to export. required descriptions list A list of human-readable names of the tasks. None folder str The Google Drive Folder that the export will reside in. Defaults to None. None region object A LinearRing, Polygon, or coordinates representing region to export. These may be specified as the Geometry objects or coordinates serialized as a string. If not specified, the region defaults to the viewport at the time of invocation. Defaults to None. None scale float Resolution in meters per pixel. Defaults to 10 times of the image resolution. None crs str CRS to use for the exported image.. Defaults to None. None max_pixels int Restrict the number of pixels in the export. Defaults to 1.0E13. 10000000000000.0 file_format str The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported. Defaults to 'GeoTIFF'. 'GeoTIFF' format_options dict A dictionary of string keys to format specific options, e.g., {'compressed': True, 'cloudOptimized': True} {} Source code in geemap/geemap.py def ee_export_image_collection_to_drive ( ee_object , descriptions = None , folder = None , region = None , scale = None , crs = None , max_pixels = 1.0E13 , file_format = 'GeoTIFF' , format_options = {}): \"\"\"Creates a batch task to export an ImageCollection as raster images to Google Drive. Args: ee_object (object): The image to export. descriptions (list): A list of human-readable names of the tasks. folder (str, optional): The Google Drive Folder that the export will reside in. Defaults to None. region (object, optional): A LinearRing, Polygon, or coordinates representing region to export. These may be specified as the Geometry objects or coordinates serialized as a string. If not specified, the region defaults to the viewport at the time of invocation. Defaults to None. scale (float, optional): Resolution in meters per pixel. Defaults to 10 times of the image resolution. crs (str, optional): CRS to use for the exported image.. Defaults to None. max_pixels (int, optional): Restrict the number of pixels in the export. Defaults to 1.0E13. file_format (str, optional): The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported. Defaults to 'GeoTIFF'. format_options (dict, optional): A dictionary of string keys to format specific options, e.g., {'compressed': True, 'cloudOptimized': True} \"\"\" # ee_initialize() if not isinstance ( ee_object , ee . ImageCollection ): print ( 'The ee_object must be an ee.ImageCollection.' ) return try : count = int ( ee_object . size () . getInfo ()) print ( \"Total number of images: {} \\n \" . format ( count )) if ( descriptions is not None ) and ( len ( descriptions ) != count ): print ( 'The number of descriptions is not equal to the number of images.' ) return if descriptions is None : descriptions = ee_object . aggregate_array ( 'system:index' ) . getInfo () images = ee_object . toList ( count ) for i in range ( 0 , count ): image = ee . Image ( images . get ( i )) name = descriptions [ i ] ee_export_image_to_drive ( image , name , folder , region , scale , crs , max_pixels , file_format , format_options ) except Exception as e : print ( e )","title":"ee_export_image_collection_to_drive()"},{"location":"geemap/#geemap.geemap.ee_export_image_to_drive","text":"Creates a batch task to export an Image as a raster to Google Drive. Parameters: Name Type Description Default ee_object object The image to export. required description str A human-readable name of the task. required folder str The Google Drive Folder that the export will reside in. Defaults to None. None region object A LinearRing, Polygon, or coordinates representing region to export. These may be specified as the Geometry objects or coordinates serialized as a string. If not specified, the region defaults to the viewport at the time of invocation. Defaults to None. None scale float Resolution in meters per pixel. Defaults to 10 times of the image resolution. None crs str CRS to use for the exported image.. Defaults to None. None max_pixels int Restrict the number of pixels in the export. Defaults to 1.0E13. 10000000000000.0 file_format str The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported. Defaults to 'GeoTIFF'. 'GeoTIFF' format_options dict A dictionary of string keys to format specific options, e.g., {'compressed': True, 'cloudOptimized': True} {} Source code in geemap/geemap.py def ee_export_image_to_drive ( ee_object , description , folder = None , region = None , scale = None , crs = None , max_pixels = 1.0E13 , file_format = 'GeoTIFF' , format_options = {}): \"\"\"Creates a batch task to export an Image as a raster to Google Drive. Args: ee_object (object): The image to export. description (str): A human-readable name of the task. folder (str, optional): The Google Drive Folder that the export will reside in. Defaults to None. region (object, optional): A LinearRing, Polygon, or coordinates representing region to export. These may be specified as the Geometry objects or coordinates serialized as a string. If not specified, the region defaults to the viewport at the time of invocation. Defaults to None. scale (float, optional): Resolution in meters per pixel. Defaults to 10 times of the image resolution. crs (str, optional): CRS to use for the exported image.. Defaults to None. max_pixels (int, optional): Restrict the number of pixels in the export. Defaults to 1.0E13. file_format (str, optional): The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported. Defaults to 'GeoTIFF'. format_options (dict, optional): A dictionary of string keys to format specific options, e.g., {'compressed': True, 'cloudOptimized': True} \"\"\" # ee_initialize() if not isinstance ( ee_object , ee . Image ): print ( 'The ee_object must be an ee.Image.' ) return try : params = {} if folder is not None : params [ 'driveFolder' ] = folder if region is not None : params [ 'region' ] = region if scale is None : scale = ee_object . projection () . nominalScale () . multiply ( 10 ) params [ 'scale' ] = scale if crs is not None : params [ 'crs' ] = crs params [ 'maxPixels' ] = max_pixels params [ 'fileFormat' ] = file_format params [ 'formatOptions' ] = format_options task = ee . batch . Export . image ( ee_object , description , params ) task . start () print ( 'Exporting {} ...' . format ( description )) except Exception as e : print ( e )","title":"ee_export_image_to_drive()"},{"location":"geemap/#geemap.geemap.ee_export_vector","text":"Exports Earth Engine FeatureCollection to other formats, including shp, csv, json, kml, and kmz. Parameters: Name Type Description Default ee_object object ee.FeatureCollection to export. required filename str Output file name. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/geemap.py def ee_export_vector ( ee_object , filename , selectors = None ): \"\"\"Exports Earth Engine FeatureCollection to other formats, including shp, csv, json, kml, and kmz. Args: ee_object (object): ee.FeatureCollection to export. filename (str): Output file name. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" import requests import zipfile # ee_initialize() if not isinstance ( ee_object , ee . FeatureCollection ): raise ValueError ( 'ee_object must be an ee.FeatureCollection' ) allowed_formats = [ 'csv' , 'geojson' , 'kml' , 'kmz' , 'shp' ] # allowed_formats = ['csv', 'kml', 'kmz'] filename = os . path . abspath ( filename ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () if filetype == 'shp' : filename = filename . replace ( '.shp' , '.zip' ) if not ( filetype . lower () in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) print ( 'Earth Engine no longer supports downloading featureCollection as shapefile or json. \\n Please use geemap.ee_export_vector_to_drive() to export featureCollection to Google Drive.' ) raise ValueError if selectors is None : selectors = ee_object . first () . propertyNames () . getInfo () if filetype == 'csv' : # remove .geo coordinate field ee_object = ee_object . select ([ \".*\" ], None , False ) if filetype == 'geojson' : selectors = [ '.geo' ] + selectors elif not isinstance ( selectors , list ): raise ValueError ( \"selectors must be a list, such as ['attribute1', 'attribute2']\" ) else : allowed_attributes = ee_object . first () . propertyNames () . getInfo () for attribute in selectors : if not ( attribute in allowed_attributes ): raise ValueError ( 'Attributes must be one chosen from: {} ' . format ( ', ' . join ( allowed_attributes ))) try : print ( 'Generating URL ...' ) url = ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) if r . status_code != 200 : print ( 'An error occurred while downloading. \\n Retrying ...' ) try : new_ee_object = ee_object . map ( filter_polygons ) print ( 'Generating URL ...' ) url = new_ee_object . getDownloadURL ( filetype = filetype , selectors = selectors , filename = name ) print ( 'Downloading data from {} \\n Please wait ...' . format ( url )) r = requests . get ( url , stream = True ) except Exception as e : print ( e ) raise ValueError with open ( filename , 'wb' ) as fd : for chunk in r . iter_content ( chunk_size = 1024 ): fd . write ( chunk ) except Exception as e : print ( 'An error occurred while downloading.' ) raise ValueError ( e ) try : if filetype == 'shp' : z = zipfile . ZipFile ( filename ) z . extractall ( os . path . dirname ( filename )) os . remove ( filename ) filename = filename . replace ( '.zip' , '.shp' ) print ( 'Data downloaded to {} ' . format ( filename )) except Exception as e : raise ValueError ( e )","title":"ee_export_vector()"},{"location":"geemap/#geemap.geemap.ee_export_vector_to_drive","text":"Exports Earth Engine FeatureCollection to Google Drive. other formats, including shp, csv, json, kml, and kmz. Parameters: Name Type Description Default ee_object object ee.FeatureCollection to export. required description str File name of the output file. required folder str Folder name within Google Drive to save the exported file. required file_format str The supported file format include shp, csv, json, kml, kmz, and TFRecord. Defaults to 'shp'. 'shp' selectors list The list of attributes to export. Defaults to None. None Source code in geemap/geemap.py def ee_export_vector_to_drive ( ee_object , description , folder , file_format = 'shp' , selectors = None ): \"\"\"Exports Earth Engine FeatureCollection to Google Drive. other formats, including shp, csv, json, kml, and kmz. Args: ee_object (object): ee.FeatureCollection to export. description (str): File name of the output file. folder (str): Folder name within Google Drive to save the exported file. file_format (str, optional): The supported file format include shp, csv, json, kml, kmz, and TFRecord. Defaults to 'shp'. selectors (list, optional): The list of attributes to export. Defaults to None. \"\"\" if not isinstance ( ee_object , ee . FeatureCollection ): print ( 'The ee_object must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' , 'tfrecord' ] if not ( file_format . lower () in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return task_config = { 'folder' : folder , 'fileFormat' : file_format , } if selectors is not None : task_config [ 'selectors' ] = selectors elif ( selectors is None ) and ( file_format . lower () == 'csv' ): # remove .geo coordinate field ee_object = ee_object . select ([ \".*\" ], None , False ) print ( 'Exporting {} ...' . format ( description )) task = ee . batch . Export . table . toDrive ( ee_object , description , ** task_config ) task . start ()","title":"ee_export_vector_to_drive()"},{"location":"geemap/#geemap.geemap.ee_function_tree","text":"Construct the tree structure based on an Earth Engine function. For example, the function \"ee.Algorithms.FMask.matchClouds\" will return a list [\"ee.Algorithms\", \"ee.Algorithms.FMask\", \"ee.Algorithms.FMask.matchClouds\"] Parameters: Name Type Description Default name str The name of the Earth Engine function required Returns: Type Description list The list for parent functions. Source code in geemap/geemap.py def ee_function_tree ( name ): \"\"\"Construct the tree structure based on an Earth Engine function. For example, the function \"ee.Algorithms.FMask.matchClouds\" will return a list [\"ee.Algorithms\", \"ee.Algorithms.FMask\", \"ee.Algorithms.FMask.matchClouds\"] Args: name (str): The name of the Earth Engine function Returns: list: The list for parent functions. \"\"\" func_list = [] try : items = name . split ( '.' ) if items [ 0 ] == 'ee' : for i in range ( 2 , len ( items ) + 1 ): func_list . append ( '.' . join ( items [ 0 : i ])) else : for i in range ( 1 , len ( items ) + 1 ): func_list . append ( '.' . join ( items [ 0 : i ])) return func_list except Exception as e : print ( e ) print ( 'The provided function name is invalid.' )","title":"ee_function_tree()"},{"location":"geemap/#geemap.geemap.ee_initialize","text":"Authenticates Earth Engine and initialize an Earth Engine session Source code in geemap/geemap.py def ee_initialize ( token_name = 'EARTHENGINE_TOKEN' ): \"\"\"Authenticates Earth Engine and initialize an Earth Engine session \"\"\" try : ee_token = os . environ . get ( token_name ) if ee_token is not None : credential = '{\"refresh_token\":\" %s \"}' % ee_token credential_file_path = os . path . expanduser ( \"~/.config/earthengine/\" ) os . makedirs ( credential_file_path , exist_ok = True ) with open ( credential_file_path + 'credentials' , 'w' ) as file : file . write ( credential ) elif in_colab_shell (): if credentials_in_drive () and ( not credentials_in_colab ()): copy_credentials_to_colab () elif not credentials_in_colab : ee . Authenticate () if is_drive_mounted () and ( not credentials_in_drive ()): copy_credentials_to_drive () else : if is_drive_mounted (): copy_credentials_to_drive () ee . Initialize () except : ee . Authenticate () ee . Initialize ()","title":"ee_initialize()"},{"location":"geemap/#geemap.geemap.ee_search","text":"Search Earth Engine API and user assets. If you received a warning (IOPub message rate exceeded) in Jupyter notebook, you can relaunch Jupyter notebook using the following command: jupyter notebook --NotebookApp.iopub_msg_rate_limit=10000 Parameters: Name Type Description Default asset_limit int The number of assets to display for each asset type, i.e., Image, ImageCollection, and FeatureCollection. Defaults to 100. 100 Source code in geemap/geemap.py def ee_search ( asset_limit = 100 ): \"\"\"Search Earth Engine API and user assets. If you received a warning (IOPub message rate exceeded) in Jupyter notebook, you can relaunch Jupyter notebook using the following command: jupyter notebook --NotebookApp.iopub_msg_rate_limit=10000 Args: asset_limit (int, optional): The number of assets to display for each asset type, i.e., Image, ImageCollection, and FeatureCollection. Defaults to 100. \"\"\" import warnings warnings . filterwarnings ( 'ignore' ) class Flags : def __init__ ( self , repos = None , docs = None , assets = None , docs_dict = None , asset_dict = None , asset_import = None ): self . repos = repos self . docs = docs self . assets = assets self . docs_dict = docs_dict self . asset_dict = asset_dict self . asset_import = asset_import flags = Flags () search_type = widgets . ToggleButtons ( options = [ 'Scripts' , 'Docs' , 'Assets' ], tooltips = [ 'Search Earth Engine Scripts' , 'Search Earth Engine API' , 'Search Earth Engine Assets' ], button_style = 'primary' ) search_type . style . button_width = '100px' search_box = widgets . Text ( placeholder = 'Filter scripts...' , value = 'Loading...' ) search_box . layout . width = '310px' tree_widget = widgets . Output () left_widget = widgets . VBox () right_widget = widgets . VBox () output_widget = widgets . Output () output_widget . layout . max_width = '650px' search_widget = widgets . HBox () search_widget . children = [ left_widget , right_widget ] display ( search_widget ) repo_tree , repo_output , _ = build_repo_tree () left_widget . children = [ search_type , repo_tree ] right_widget . children = [ repo_output ] flags . repos = repo_tree search_box . value = '' def search_type_changed ( change ): search_box . value = '' output_widget . clear_output () tree_widget . clear_output () if change [ 'new' ] == 'Scripts' : search_box . placeholder = 'Filter scripts...' left_widget . children = [ search_type , repo_tree ] right_widget . children = [ repo_output ] elif change [ 'new' ] == 'Docs' : search_box . placeholder = 'Filter methods...' search_box . value = 'Loading...' left_widget . children = [ search_type , search_box , tree_widget ] right_widget . children = [ output_widget ] if flags . docs is None : api_dict = read_api_csv () ee_api_tree , tree_dict = build_api_tree ( api_dict , output_widget ) flags . docs = ee_api_tree flags . docs_dict = tree_dict else : ee_api_tree = flags . docs with tree_widget : tree_widget . clear_output () display ( ee_api_tree ) right_widget . children = [ output_widget ] search_box . value = '' elif change [ 'new' ] == 'Assets' : search_box . placeholder = 'Filter assets...' left_widget . children = [ search_type , search_box , tree_widget ] right_widget . children = [ output_widget ] search_box . value = 'Loading...' if flags . assets is None : asset_tree , asset_widget , asset_dict = build_asset_tree ( limit = asset_limit ) flags . assets = asset_tree flags . asset_dict = asset_dict flags . asset_import = asset_widget with tree_widget : tree_widget . clear_output () display ( flags . assets ) right_widget . children = [ flags . asset_import ] search_box . value = '' search_type . observe ( search_type_changed , names = 'value' ) def search_box_callback ( text ): if search_type . value == 'Docs' : with tree_widget : if text . value == '' : print ( 'Loading...' ) tree_widget . clear_output ( wait = True ) display ( flags . docs ) else : tree_widget . clear_output () print ( 'Searching...' ) tree_widget . clear_output ( wait = True ) sub_tree = search_api_tree ( text . value , flags . docs_dict ) display ( sub_tree ) elif search_type . value == 'Assets' : with tree_widget : if text . value == '' : print ( 'Loading...' ) tree_widget . clear_output ( wait = True ) display ( flags . assets ) else : tree_widget . clear_output () print ( 'Searching...' ) tree_widget . clear_output ( wait = True ) sub_tree = search_api_tree ( text . value , flags . asset_dict ) display ( sub_tree ) search_box . on_submit ( search_box_callback )","title":"ee_search()"},{"location":"geemap/#geemap.geemap.ee_tile_layer","text":"Converts and Earth Engine layer to ipyleaflet TileLayer. Parameters: Name Type Description Default ee_object Collection|Feature|Image|MapId The object to add to the map. required vis_params dict The visualization parameters. Defaults to {}. {} name str The name of the layer. Defaults to 'Layer untitled'. 'Layer untitled' shown bool A flag indicating whether the layer should be on by default. Defaults to True. True opacity float The layer's opacity represented as a number between 0 and 1. Defaults to 1. 1.0 Source code in geemap/geemap.py def ee_tile_layer ( ee_object , vis_params = {}, name = 'Layer untitled' , shown = True , opacity = 1.0 ): \"\"\"Converts and Earth Engine layer to ipyleaflet TileLayer. Args: ee_object (Collection|Feature|Image|MapId): The object to add to the map. vis_params (dict, optional): The visualization parameters. Defaults to {}. name (str, optional): The name of the layer. Defaults to 'Layer untitled'. shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True. opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1. \"\"\" # ee_initialize() image = None if not isinstance ( ee_object , ee . Image ) and not isinstance ( ee_object , ee . ImageCollection ) and not isinstance ( ee_object , ee . FeatureCollection ) and not isinstance ( ee_object , ee . Feature ) and not isinstance ( ee_object , ee . Geometry ): err_str = \" \\n\\n The image argument in 'addLayer' function must be an instace of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\" raise AttributeError ( err_str ) if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): features = ee . FeatureCollection ( ee_object ) width = 2 if 'width' in vis_params : width = vis_params [ 'width' ] color = '000000' if 'color' in vis_params : color = vis_params [ 'color' ] image_fill = features . style ( ** { 'fillColor' : color }) . updateMask ( ee . Image . constant ( 0.5 )) image_outline = features . style ( ** { 'color' : color , 'fillColor' : '00000000' , 'width' : width }) image = image_fill . blend ( image_outline ) elif isinstance ( ee_object , ee . image . Image ): image = ee_object elif isinstance ( ee_object , ee . imagecollection . ImageCollection ): image = ee_object . mosaic () map_id_dict = ee . Image ( image ) . getMapId ( vis_params ) tile_layer = ipyleaflet . TileLayer ( url = map_id_dict [ 'tile_fetcher' ] . url_format , attribution = 'Google Earth Engine' , name = name , opacity = opacity , visible = True # visible=shown ) return tile_layer","title":"ee_tile_layer()"},{"location":"geemap/#geemap.geemap.ee_to_csv","text":"Downloads an ee.FeatureCollection as a CSV file. Parameters: Name Type Description Default ee_object object ee.FeatureCollection required filename str The output filepath of the CSV file. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/geemap.py def ee_to_csv ( ee_object , filename , selectors = None ): \"\"\"Downloads an ee.FeatureCollection as a CSV file. Args: ee_object (object): ee.FeatureCollection filename (str): The output filepath of the CSV file. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" # ee_initialize() try : if filename . lower () . endswith ( '.csv' ): ee_export_vector ( ee_object = ee_object , filename = filename , selectors = selectors ) else : print ( 'The filename must end with .csv' ) except Exception as e : print ( e )","title":"ee_to_csv()"},{"location":"geemap/#geemap.geemap.ee_to_geojson","text":"Converts Earth Engine object to geojson. Parameters: Name Type Description Default ee_object object An Earth Engine object. required Returns: Type Description object GeoJSON object. Source code in geemap/geemap.py def ee_to_geojson ( ee_object , out_json = None ): \"\"\"Converts Earth Engine object to geojson. Args: ee_object (object): An Earth Engine object. Returns: object: GeoJSON object. \"\"\" from json import dumps # ee_initialize() try : if isinstance ( ee_object , ee . geometry . Geometry ) or isinstance ( ee_object , ee . feature . Feature ) or isinstance ( ee_object , ee . featurecollection . FeatureCollection ): json_object = ee_object . getInfo () if out_json is not None : out_json = os . path . abspath ( out_json ) if not os . path . exists ( os . path . dirname ( out_json )): os . makedirs ( os . path . dirname ( out_json )) geojson = open ( out_json , \"w\" ) geojson . write ( dumps ({ \"type\" : \"FeatureCollection\" , \"features\" : json_object }, indent = 2 ) + \" \\n \" ) geojson . close () return json_object else : print ( \"Could not convert the Earth Engine object to geojson\" ) except Exception as e : print ( e )","title":"ee_to_geojson()"},{"location":"geemap/#geemap.geemap.ee_to_numpy","text":"Extracts a rectangular region of pixels from an image into a 2D numpy array per band. Parameters: Name Type Description Default ee_object object The image to sample. required bands list The list of band names to extract. Please make sure that all bands have the same spatial resolution. Defaults to None. None region object The region whose projected bounding box is used to sample the image. The maximum number of pixels you can export is 262,144. Resampling and reprojecting all bands to a fixed scale can be useful. Defaults to the footprint in each band. None properties list The properties to copy over from the sampled image. Defaults to all non-system properties. None default_value float A default value used when a sampled pixel is masked or outside a band's footprint. Defaults to None. None Returns: Type Description array A 3D numpy array. Source code in geemap/geemap.py def ee_to_numpy ( ee_object , bands = None , region = None , properties = None , default_value = None ): \"\"\"Extracts a rectangular region of pixels from an image into a 2D numpy array per band. Args: ee_object (object): The image to sample. bands (list, optional): The list of band names to extract. Please make sure that all bands have the same spatial resolution. Defaults to None. region (object, optional): The region whose projected bounding box is used to sample the image. The maximum number of pixels you can export is 262,144. Resampling and reprojecting all bands to a fixed scale can be useful. Defaults to the footprint in each band. properties (list, optional): The properties to copy over from the sampled image. Defaults to all non-system properties. default_value (float, optional): A default value used when a sampled pixel is masked or outside a band's footprint. Defaults to None. Returns: array: A 3D numpy array. \"\"\" import numpy as np if not isinstance ( ee_object , ee . Image ): print ( 'The input must be an ee.Image.' ) return if region is None : region = ee_object . geometry () try : if bands is not None : ee_object = ee_object . select ( bands ) else : bands = ee_object . bandNames () . getInfo () band_count = len ( bands ) band_arrs = ee_object . sampleRectangle ( region = region , properties = properties , defaultValue = default_value ) band_values = [] for band in bands : band_arr = band_arrs . get ( band ) . getInfo () band_value = np . array ( band_arr ) band_values . append ( band_value ) image = np . dstack ( band_values ) return image except Exception as e : print ( e )","title":"ee_to_numpy()"},{"location":"geemap/#geemap.geemap.ee_to_shp","text":"Downloads an ee.FeatureCollection as a shapefile. Parameters: Name Type Description Default ee_object object ee.FeatureCollection required filename str The output filepath of the shapefile. required selectors list A list of attributes to export. Defaults to None. None Source code in geemap/geemap.py def ee_to_shp ( ee_object , filename , selectors = None ): \"\"\"Downloads an ee.FeatureCollection as a shapefile. Args: ee_object (object): ee.FeatureCollection filename (str): The output filepath of the shapefile. selectors (list, optional): A list of attributes to export. Defaults to None. \"\"\" # ee_initialize() try : if filename . lower () . endswith ( '.shp' ): ee_export_vector ( ee_object = ee_object , filename = filename , selectors = selectors ) else : print ( 'The filename must end with .shp' ) except Exception as e : print ( e )","title":"ee_to_shp()"},{"location":"geemap/#geemap.geemap.ee_user_id","text":"Gets Earth Engine account user id. Returns: Type Description str A string containing the user id. Source code in geemap/geemap.py def ee_user_id (): \"\"\"Gets Earth Engine account user id. Returns: str: A string containing the user id. \"\"\" # ee_initialize() roots = ee . data . getAssetRoots () if len ( roots ) == 0 : return None else : root = ee . data . getAssetRoots ()[ 0 ] user_id = root [ 'id' ] . replace ( \"projects/earthengine-legacy/assets/\" , \"\" ) return user_id","title":"ee_user_id()"},{"location":"geemap/#geemap.geemap.file_browser","text":"Creates a simple file browser and text editor. Parameters: Name Type Description Default in_dir str The input directory. Defaults to None, which will use the current working directory. None show_hidden bool Whether to show hidden files/folders. Defaults to False. False add_root_node bool Whether to add the input directory as a root node. Defaults to True. True search_description str The description of the search box. Defaults to None. None use_import bool Whether to show the import button. Defaults to False. False return_sep_widgets bool Whether to return the results as separate widgets. Defaults to False. False Returns: Type Description object An ipywidget. Source code in geemap/geemap.py def file_browser ( in_dir = None , show_hidden = False , add_root_node = True , search_description = None , use_import = False , return_sep_widgets = False ): \"\"\"Creates a simple file browser and text editor. Args: in_dir (str, optional): The input directory. Defaults to None, which will use the current working directory. show_hidden (bool, optional): Whether to show hidden files/folders. Defaults to False. add_root_node (bool, optional): Whether to add the input directory as a root node. Defaults to True. search_description (str, optional): The description of the search box. Defaults to None. use_import (bool, optional): Whether to show the import button. Defaults to False. return_sep_widgets (bool, optional): Whether to return the results as separate widgets. Defaults to False. Returns: object: An ipywidget. \"\"\" import platform if in_dir is None : in_dir = os . getcwd () if not os . path . exists ( in_dir ): print ( 'The provided directory does not exist.' ) return elif not os . path . isdir ( in_dir ): print ( 'The provided path is not a valid directory.' ) return sep = '/' if platform . system () == \"Windows\" : sep = ' \\\\ ' if in_dir . endswith ( sep ): in_dir = in_dir [: - 1 ] full_widget = widgets . HBox () left_widget = widgets . VBox () right_widget = widgets . VBox () import_btn = widgets . Button ( description = 'import' , button_style = 'primary' , tooltip = 'import the content to a new cell' , disabled = True ) import_btn . layout . width = '70px' path_widget = widgets . Text () path_widget . layout . min_width = '400px' # path_widget.layout.max_width = '400px' save_widget = widgets . Button ( description = 'Save' , button_style = 'primary' , tooltip = 'Save edits to file.' , disabled = True ) info_widget = widgets . HBox () info_widget . children = [ path_widget , save_widget ] if use_import : info_widget . children = [ import_btn , path_widget , save_widget ] text_widget = widgets . Textarea () text_widget . layout . width = '630px' text_widget . layout . height = '600px' right_widget . children = [ info_widget , text_widget ] full_widget . children = [ left_widget ] if search_description is None : search_description = 'Search files/folders...' search_box = widgets . Text ( placeholder = search_description ) search_box . layout . width = '310px' tree_widget = widgets . Output () tree_widget . layout . max_width = '310px' tree_widget . overflow = 'auto' left_widget . children = [ search_box , tree_widget ] tree = Tree ( multiple_selection = False ) tree_dict = {} def on_button_clicked ( b ): content = text_widget . value out_file = path_widget . value out_dir = os . path . dirname ( out_file ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) with open ( out_file , 'w' ) as f : f . write ( content ) text_widget . disabled = True text_widget . value = 'The content has been saved successfully.' save_widget . disabled = True path_widget . disabled = True if ( out_file not in tree_dict . keys ()) and ( out_dir in tree_dict . keys ()): node = Node ( os . path . basename ( out_file )) tree_dict [ out_file ] = node parent_node = tree_dict [ out_dir ] parent_node . add_node ( node ) save_widget . on_click ( on_button_clicked ) def import_btn_clicked ( b ): if ( text_widget . value != '' ) and ( path_widget . value . endswith ( '.py' )): create_code_cell ( text_widget . value ) import_btn . on_click ( import_btn_clicked ) def search_box_callback ( text ): with tree_widget : if text . value == '' : print ( 'Loading...' ) tree_widget . clear_output ( wait = True ) display ( tree ) else : tree_widget . clear_output () print ( 'Searching...' ) tree_widget . clear_output ( wait = True ) sub_tree = search_api_tree ( text . value , tree_dict ) display ( sub_tree ) search_box . on_submit ( search_box_callback ) def handle_file_click ( event ): if event [ 'new' ]: cur_node = event [ 'owner' ] for key in tree_dict . keys (): if ( cur_node is tree_dict [ key ]) and ( os . path . isfile ( key )): if key . endswith ( '.py' ): import_btn . disabled = False else : import_btn . disabled = True try : with open ( key ) as f : content = f . read () text_widget . value = content text_widget . disabled = False path_widget . value = key path_widget . disabled = False save_widget . disabled = False full_widget . children = [ left_widget , right_widget ] except Exception as e : path_widget . value = key path_widget . disabled = True save_widget . disabled = True text_widget . disabled = True text_widget . value = 'Failed to open {} .' . format ( cur_node . name ) + ' \\n\\n ' + str ( e ) full_widget . children = [ left_widget , right_widget ] return break def handle_folder_click ( event ): if event [ 'new' ]: full_widget . children = [ left_widget ] text_widget . value = '' if add_root_node : root_name = in_dir . split ( sep )[ - 1 ] root_node = Node ( root_name ) tree_dict [ in_dir ] = root_node tree . add_node ( root_node ) root_node . observe ( handle_folder_click , 'selected' ) for root , d_names , f_names in os . walk ( in_dir ): if not show_hidden : folders = root . split ( sep ) for folder in folders : if folder . startswith ( '.' ): continue for d_name in d_names : if d_name . startswith ( '.' ): d_names . remove ( d_name ) for f_name in f_names : if f_name . startswith ( '.' ): f_names . remove ( f_name ) d_names . sort () f_names . sort () if ( not add_root_node ) and ( root == in_dir ): for d_name in d_names : node = Node ( d_name ) tree_dict [ os . path . join ( in_dir , d_name )] = node tree . add_node ( node ) node . opened = False node . observe ( handle_folder_click , 'selected' ) if ( root != in_dir ) and ( root not in tree_dict . keys ()): name = root . split ( sep )[ - 1 ] dir_name = os . path . dirname ( root ) parent_node = tree_dict [ dir_name ] node = Node ( name ) tree_dict [ root ] = node parent_node . add_node ( node ) node . observe ( handle_folder_click , 'selected' ) if len ( f_names ) > 0 : parent_node = tree_dict [ root ] parent_node . opened = False for f_name in f_names : node = Node ( f_name ) node . icon = 'file' full_path = os . path . join ( root , f_name ) tree_dict [ full_path ] = node parent_node . add_node ( node ) node . observe ( handle_file_click , 'selected' ) with tree_widget : tree_widget . clear_output () display ( tree ) if return_sep_widgets : return left_widget , right_widget , tree_dict else : return full_widget","title":"file_browser()"},{"location":"geemap/#geemap.geemap.filter_polygons","text":"Converts GeometryCollection to Polygon/MultiPolygon Parameters: Name Type Description Default ftr object ee.Feature required Returns: Type Description object ee.Feature Source code in geemap/geemap.py def filter_polygons ( ftr ): \"\"\"Converts GeometryCollection to Polygon/MultiPolygon Args: ftr (object): ee.Feature Returns: object: ee.Feature \"\"\" # ee_initialize() geometries = ftr . geometry () . geometries () geometries = geometries . map ( lambda geo : ee . Feature ( ee . Geometry ( geo )) . set ( 'geoType' , ee . Geometry ( geo ) . type ())) polygons = ee . FeatureCollection ( geometries ) . filter ( ee . Filter . eq ( 'geoType' , 'Polygon' )) . geometry () return ee . Feature ( polygons ) . copyProperties ( ftr )","title":"filter_polygons()"},{"location":"geemap/#geemap.geemap.geocode","text":"Search location by address and lat/lon coordinates. Parameters: Name Type Description Default location str Place name or address required max_rows int Maximum number of records to return. Defaults to 10. 10 reverse bool Search place based on coordinates. Defaults to False. False Returns: Type Description list Returns a list of locations. Source code in geemap/geemap.py def geocode ( location , max_rows = 10 , reverse = False ): \"\"\"Search location by address and lat/lon coordinates. Args: location (str): Place name or address max_rows (int, optional): Maximum number of records to return. Defaults to 10. reverse (bool, optional): Search place based on coordinates. Defaults to False. Returns: list: Returns a list of locations. \"\"\" if not isinstance ( location , str ): print ( 'The location must be a string.' ) return None if not reverse : locations = [] addresses = set () g = geocoder . arcgis ( location , maxRows = max_rows ) for result in g : address = result . address if not address in addresses : addresses . add ( address ) locations . append ( result ) if len ( locations ) > 0 : return locations else : return None else : try : if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return g = geocoder . arcgis ( latlon , method = 'reverse' ) locations = [] addresses = set () for result in g : address = result . address if not address in addresses : addresses . add ( address ) locations . append ( result ) if len ( locations ) > 0 : return locations else : return None except Exception as e : print ( e ) return None","title":"geocode()"},{"location":"geemap/#geemap.geemap.geojson_to_ee","text":"Converts a geojson to ee.Geometry() Parameters: Name Type Description Default geo_json dict A geojson geometry dictionary or file path. required Returns: Type Description ee_object An ee.Geometry object Source code in geemap/geemap.py def geojson_to_ee ( geo_json , geodesic = True ): \"\"\"Converts a geojson to ee.Geometry() Args: geo_json (dict): A geojson geometry dictionary or file path. Returns: ee_object: An ee.Geometry object \"\"\" # ee_initialize() try : import json if not isinstance ( geo_json , dict ) and os . path . isfile ( geo_json ): with open ( os . path . abspath ( geo_json )) as f : geo_json = json . load ( f ) if geo_json [ 'type' ] == 'FeatureCollection' : features = ee . FeatureCollection ( geo_json [ 'features' ]) return features elif geo_json [ 'type' ] == 'Feature' : geom = None keys = geo_json [ 'properties' ][ 'style' ] . keys () if 'radius' in keys : # Checks whether it is a circle geom = ee . Geometry ( geo_json [ 'geometry' ]) radius = geo_json [ 'properties' ][ 'style' ][ 'radius' ] geom = geom . buffer ( radius ) elif geo_json [ 'geometry' ][ 'type' ] == 'Point' : # Checks whether it is a point coordinates = geo_json [ 'geometry' ][ 'coordinates' ] longitude = coordinates [ 0 ] latitude = coordinates [ 1 ] geom = ee . Geometry . Point ( longitude , latitude ) else : geom = ee . Geometry ( geo_json [ 'geometry' ], \"\" , geodesic ) return geom else : print ( \"Could not convert the geojson to ee.Geometry()\" ) except Exception as e : print ( \"Could not convert the geojson to ee.Geometry()\" ) print ( e )","title":"geojson_to_ee()"},{"location":"geemap/#geemap.geemap.has_transparency","text":"Checks whether an image has transparency. Parameters: Name Type Description Default img object a PIL Image object. required Returns: Type Description bool True if it has transparency, False otherwise. Source code in geemap/geemap.py def has_transparency ( img ): \"\"\"Checks whether an image has transparency. Args: img (object): a PIL Image object. Returns: bool: True if it has transparency, False otherwise. \"\"\" if img . mode == \"P\" : transparent = img . info . get ( \"transparency\" , - 1 ) for _ , index in img . getcolors (): if index == transparent : return True elif img . mode == \"RGBA\" : extrema = img . getextrema () if extrema [ 3 ][ 0 ] < 255 : return True return False","title":"has_transparency()"},{"location":"geemap/#geemap.geemap.hex_to_rgb","text":"Converts hex color to RGB color. Parameters: Name Type Description Default value str Hex color code as a string. Defaults to 'FFFFFF'. 'FFFFFF' Returns: Type Description tuple RGB color as a tuple. Source code in geemap/geemap.py def hex_to_rgb ( value = 'FFFFFF' ): \"\"\"Converts hex color to RGB color. Args: value (str, optional): Hex color code as a string. Defaults to 'FFFFFF'. Returns: tuple: RGB color as a tuple. \"\"\" value = value . lstrip ( '#' ) lv = len ( value ) return tuple ( int ( value [ i : i + lv // 3 ], 16 ) for i in range ( 0 , lv , lv // 3 ))","title":"hex_to_rgb()"},{"location":"geemap/#geemap.geemap.image_props","text":"Gets image properties. Parameters: Name Type Description Default img ee.Image The input image. required date_format str The output date format. Defaults to 'YYYY-MM-dd HH:mm:ss'. 'YYYY-MM-dd' Returns: Type Description dd.Dictionary The dictionary containing image properties. Source code in geemap/geemap.py def image_props ( img , date_format = 'YYYY-MM-dd' ): \"\"\"Gets image properties. Args: img (ee.Image): The input image. date_format (str, optional): The output date format. Defaults to 'YYYY-MM-dd HH:mm:ss'. Returns: dd.Dictionary: The dictionary containing image properties. \"\"\" if not isinstance ( img , ee . Image ): print ( 'The input object must be an ee.Image' ) return keys = img . propertyNames () . remove ( 'system:footprint' ) . remove ( 'system:bands' ) values = keys . map ( lambda p : img . get ( p )) bands = img . bandNames () scales = bands . map ( lambda b : img . select ([ b ]) . projection () . nominalScale ()) scale = ee . Algorithms . If ( scales . distinct () . size () . gt ( 1 ), ee . Dictionary . fromLists ( bands . getInfo (), scales ), scales . get ( 0 )) image_date = ee . Date ( img . get ( 'system:time_start' )) . format ( date_format ) time_start = ee . Date ( img . get ( 'system:time_start' ) ) . format ( 'YYYY-MM-dd HH:mm:ss' ) # time_end = ee.Date(img.get('system:time_end')).format('YYYY-MM-dd HH:mm:ss') time_end = ee . Algorithms . If ( ee . List ( img . propertyNames ()) . contains ( 'system:time_end' ), ee . Date ( img . get ( 'system:time_end' )) . format ( 'YYYY-MM-dd HH:mm:ss' ), time_start ) asset_size = ee . Number ( img . get ( 'system:asset_size' )) . divide ( 1e6 ) . format () . cat ( ee . String ( ' MB' )) props = ee . Dictionary . fromLists ( keys , values ) props = props . set ( 'system:time_start' , time_start ) props = props . set ( 'system:time_end' , time_end ) props = props . set ( 'system:asset_size' , asset_size ) props = props . set ( 'NOMINAL_SCALE' , scale ) props = props . set ( 'IMAGE_DATE' , image_date ) return props","title":"image_props()"},{"location":"geemap/#geemap.geemap.image_stats","text":"Gets image descriptive statistics. Parameters: Name Type Description Default img ee.Image The input image to calculate descriptive statistics. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description ee.Dictionary A dictionary containing the description statistics of the input image. Source code in geemap/geemap.py def image_stats ( img , region = None , scale = None ): \"\"\"Gets image descriptive statistics. Args: img (ee.Image): The input image to calculate descriptive statistics. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: ee.Dictionary: A dictionary containing the description statistics of the input image. \"\"\" import geemap.utils as utils if not isinstance ( img , ee . Image ): print ( 'The input object must be an ee.Image' ) return stat_types = [ 'min' , 'max' , 'mean' , 'std' , 'sum' ] image_min = utils . image_min_value ( img , region , scale ) image_max = utils . image_max_value ( img , region , scale ) image_mean = utils . image_mean_value ( img , region , scale ) image_std = utils . image_std_value ( img , region , scale ) image_sum = utils . image_sum_value ( img , region , scale ) stat_results = ee . List ( [ image_min , image_max , image_mean , image_std , image_sum ]) stats = ee . Dictionary . fromLists ( stat_types , stat_results ) return stats","title":"image_stats()"},{"location":"geemap/#geemap.geemap.in_colab_shell","text":"Tests if the code is being executed within Google Colab. Source code in geemap/geemap.py def in_colab_shell (): \"\"\"Tests if the code is being executed within Google Colab.\"\"\" try : import google.colab # pylint: disable=unused-variable return True except ImportError : return False","title":"in_colab_shell()"},{"location":"geemap/#geemap.geemap.install_from_github","text":"Install a package from a GitHub repository. Parameters: Name Type Description Default url str The URL of the GitHub repository. required Source code in geemap/geemap.py def install_from_github ( url ): \"\"\"Install a package from a GitHub repository. Args: url (str): The URL of the GitHub repository. \"\"\" try : download_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) if not os . path . exists ( download_dir ): os . makedirs ( download_dir ) repo_name = os . path . basename ( url ) zip_url = os . path . join ( url , 'archive/master.zip' ) filename = repo_name + '-master.zip' download_from_url ( url = zip_url , out_file_name = filename , out_dir = download_dir , unzip = True ) pkg_dir = os . path . join ( download_dir , repo_name + '-master' ) pkg_name = os . path . basename ( url ) work_dir = os . getcwd () os . chdir ( pkg_dir ) print ( 'Installing {} ...' . format ( pkg_name )) cmd = 'pip install .' os . system ( cmd ) os . chdir ( work_dir ) print ( ' {} has been installed successfully.' . format ( pkg_name )) # print(\"\\nPlease comment out 'install_from_github()' and restart the kernel to take effect:\\nJupyter menu -> Kernel -> Restart & Clear Output\") except Exception as e : print ( e )","title":"install_from_github()"},{"location":"geemap/#geemap.geemap.is_drive_mounted","text":"Checks whether Google Drive is mounted in Google Colab. Returns: Type Description bool Returns True if Google Drive is mounted, False otherwise. Source code in geemap/geemap.py def is_drive_mounted (): \"\"\"Checks whether Google Drive is mounted in Google Colab. Returns: bool: Returns True if Google Drive is mounted, False otherwise. \"\"\" drive_path = '/content/drive/My Drive' if os . path . exists ( drive_path ): return True else : return False","title":"is_drive_mounted()"},{"location":"geemap/#geemap.geemap.is_latlon_valid","text":"Checks whether a pair of coordinates is valid. Parameters: Name Type Description Default location str A pair of latlon coordinates separated by comma or space. required Returns: Type Description bool Returns True if valid. Source code in geemap/geemap.py def is_latlon_valid ( location ): \"\"\"Checks whether a pair of coordinates is valid. Args: location (str): A pair of latlon coordinates separated by comma or space. Returns: bool: Returns True if valid. \"\"\" latlon = [] if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return False try : lat , lon = float ( latlon [ 0 ]), float ( latlon [ 1 ]) if lat >= - 90 and lat <= 90 and lon >= - 180 and lat <= 180 : return True else : return False except Exception as e : print ( e ) return False","title":"is_latlon_valid()"},{"location":"geemap/#geemap.geemap.is_tool","text":"Check whether name is on PATH and marked as executable. Source code in geemap/geemap.py def is_tool ( name ): \"\"\"Check whether `name` is on PATH and marked as executable.\"\"\" from shutil import which return which ( name ) is not None","title":"is_tool()"},{"location":"geemap/#geemap.geemap.landsat_timeseries","text":"Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Parameters: Name Type Description Default roi object Region of interest to create the timelapse. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 1984. 1984 end_year int Ending year for the timelapse. Defaults to 2020. 2020 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. '06-10' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. '09-20' apply_fmask bool Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. True Returns: Type Description object Returns an ImageCollection containing annual Landsat images. Source code in geemap/geemap.py def landsat_timeseries ( roi = None , start_year = 1984 , end_year = 2020 , start_date = '06-10' , end_date = '09-20' , apply_fmask = True ): \"\"\"Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Args: roi (object, optional): Region of interest to create the timelapse. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 1984. end_year (int, optional): Ending year for the timelapse. Defaults to 2020. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. Returns: object: Returns an ImageCollection containing annual Landsat images. \"\"\" ################################################################################ # Input and output parameters. import re import datetime if roi is None : roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return ################################################################################ # Setup vars to get dates. if isinstance ( start_year , int ) and ( start_year >= 1984 ) and ( start_year < 2020 ): pass else : print ( 'The start year must be an integer >= 1984.' ) return if isinstance ( end_year , int ) and ( end_year > 1984 ) and ( end_year <= 2020 ): pass else : print ( 'The end year must be an integer <= 2020.' ) return if re . match ( \"[0-9] {2} \\-[0-9] {2} \" , start_date ) and re . match ( \"[0-9] {2} \\-[0-9] {2} \" , end_date ): pass else : print ( 'The start date and end date must be month-day, such as 06-10, 09-20' ) return try : datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) except Exception as e : print ( 'The input dates are invalid.' ) return def days_between ( d1 , d2 ): d1 = datetime . datetime . strptime ( d1 , \"%Y-%m- %d \" ) d2 = datetime . datetime . strptime ( d2 , \"%Y-%m- %d \" ) return abs (( d2 - d1 ) . days ) n_days = days_between ( str ( start_year ) + '-' + start_date , str ( start_year ) + '-' + end_date ) start_month = int ( start_date [: 2 ]) start_day = int ( start_date [ 3 : 5 ]) start_date = str ( start_year ) + '-' + start_date end_date = str ( end_year ) + '-' + end_date # Define a collection filter by date, bounds, and quality. def colFilter ( col , aoi ): # , startDate, endDate): return ( col . filterBounds ( aoi )) # Landsat collection preprocessingEnabled # Get Landsat surface reflectance collections for OLI, ETM+ and TM sensors. LC08col = ee . ImageCollection ( 'LANDSAT/LC08/C01/T1_SR' ) LE07col = ee . ImageCollection ( 'LANDSAT/LE07/C01/T1_SR' ) LT05col = ee . ImageCollection ( 'LANDSAT/LT05/C01/T1_SR' ) LT04col = ee . ImageCollection ( 'LANDSAT/LT04/C01/T1_SR' ) # Define a collection filter by date, bounds, and quality. def colFilter ( col , roi , start_date , end_date ): return ( col . filterBounds ( roi ) . filterDate ( start_date , end_date )) # .filter('CLOUD_COVER < 5') # .filter('GEOMETRIC_RMSE_MODEL < 15') # .filter('IMAGE_QUALITY == 9 || IMAGE_QUALITY_OLI == 9')) # Function to get and rename bands of interest from OLI. def renameOli ( img ): return ( img . select ( [ 'B2' , 'B3' , 'B4' , 'B5' , 'B6' , 'B7' , 'pixel_qa' ], [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ])) # Function to get and rename bands of interest from ETM+. def renameEtm ( img ): return ( img . select ( [ 'B1' , 'B2' , 'B3' , 'B4' , 'B5' , 'B7' , 'pixel_qa' ], [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ])) # Add NBR for LandTrendr segmentation. def calcNbr ( img ): return ( img . addBands ( img . normalizedDifference ([ 'NIR' , 'SWIR2' ]) . multiply ( - 10000 ) . rename ( 'NBR' )) . int16 ()) # Define function to mask out clouds and cloud shadows in images. # Use CFmask band included in USGS Landsat SR image product. def fmask ( img ): cloudShadowBitMask = 1 << 3 cloudsBitMask = 1 << 5 qa = img . select ( 'pixel_qa' ) mask = qa . bitwiseAnd ( cloudShadowBitMask ) . eq ( 0 ) \\ . And ( qa . bitwiseAnd ( cloudsBitMask ) . eq ( 0 )) return ( img . updateMask ( mask )) # Define function to prepare OLI images. def prepOli ( img ): orig = img img = renameOli ( img ) if apply_fmask : img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Define function to prepare ETM+ images. def prepEtm ( img ): orig = img img = renameEtm ( img ) if apply_fmask : img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Get annual median collection. def getAnnualComp ( y ): startDate = ee . Date . fromYMD ( ee . Number ( y ), ee . Number ( start_month ), ee . Number ( start_day )) endDate = startDate . advance ( ee . Number ( n_days ), 'day' ) # Filter collections and prepare them for merging. LC08coly = colFilter ( LC08col , roi , startDate , endDate ) . map ( prepOli ) LE07coly = colFilter ( LE07col , roi , startDate , endDate ) . map ( prepEtm ) LT05coly = colFilter ( LT05col , roi , startDate , endDate ) . map ( prepEtm ) LT04coly = colFilter ( LT04col , roi , startDate , endDate ) . map ( prepEtm ) # Merge the collections. col = LC08coly . merge ( LE07coly ) . merge ( LT05coly ) . merge ( LT04coly ) yearImg = col . median () nBands = yearImg . bandNames () . size () yearImg = ee . Image ( ee . Algorithms . If ( nBands , yearImg , dummyImg )) return ( calcNbr ( yearImg ) . set ({ 'year' : y , 'system:time_start' : startDate . millis (), 'nBands' : nBands })) ################################################################################ # Make a dummy image for missing years. bandNames = ee . List ([ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ]) fillerValues = ee . List . repeat ( 0 , bandNames . size ()) dummyImg = ee . Image . constant ( fillerValues ) . rename ( bandNames ) \\ . selfMask () . int16 () ################################################################################ # Get a list of years years = ee . List . sequence ( start_year , end_year ) ################################################################################ # Make list of annual image composites. imgList = years . map ( getAnnualComp ) # Convert image composite list to collection imgCol = ee . ImageCollection . fromImages ( imgList ) imgCol = imgCol . map ( lambda img : img . clip ( roi ) . set ({ 'coordinates' : roi . coordinates ()})) return imgCol","title":"landsat_timeseries()"},{"location":"geemap/#geemap.geemap.landsat_ts_gif","text":"Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work. Parameters: Name Type Description Default roi object Region of interest to create the timelapse. Defaults to None. None out_gif str File path to the output animated GIF. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 1984. 1984 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. '06-10' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. '09-20' bands list Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. ['NIR', 'Red', 'Green'] vis_params dict Visualization parameters. Defaults to None. None dimensions int a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. 768 frames_per_second int Animation speed. Defaults to 10. 10 apply_fmask bool Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. True nd_bands list A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1). None nd_threshold float The threshold for extacting pixels from the normalized difference band. 0 nd_palette list The color palette to use for displaying the normalized difference band. ['black', 'blue'] Returns: Type Description str File path to the output GIF image. Source code in geemap/geemap.py def landsat_ts_gif ( roi = None , out_gif = None , start_year = 1984 , end_year = 2019 , start_date = '06-10' , end_date = '09-20' , bands = [ 'NIR' , 'Red' , 'Green' ], vis_params = None , dimensions = 768 , frames_per_second = 10 , apply_fmask = True , nd_bands = None , nd_threshold = 0 , nd_palette = [ 'black' , 'blue' ]): \"\"\"Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work. Args: roi (object, optional): Region of interest to create the timelapse. Defaults to None. out_gif (str, optional): File path to the output animated GIF. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 1984. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'. bands (list, optional): Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green']. vis_params (dict, optional): Visualization parameters. Defaults to None. dimensions (int, optional): a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. frames_per_second (int, optional): Animation speed. Defaults to 10. apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking. nd_bands (list, optional): A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1). nd_threshold (float, optional): The threshold for extacting pixels from the normalized difference band. nd_palette (list, optional): The color palette to use for displaying the normalized difference band. Returns: str: File path to the output GIF image. \"\"\" # ee_initialize() if roi is None : roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) elif isinstance ( roi , ee . Feature ) or isinstance ( roi , ee . FeatureCollection ): roi = roi . geometry () elif isinstance ( roi , ee . Geometry ): pass else : print ( 'The provided roi is invalid. It must be an ee.Geometry' ) return if out_gif is None : out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) filename = 'landsat_ts_' + random_string () + '.gif' out_gif = os . path . join ( out_dir , filename ) elif not out_gif . endswith ( '.gif' ): print ( 'The output file must end with .gif' ) return # elif not os.path.isfile(out_gif): # print('The output file must be a file') # return else : out_gif = os . path . abspath ( out_gif ) out_dir = os . path . dirname ( out_gif ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) allowed_bands = [ 'Blue' , 'Green' , 'Red' , 'NIR' , 'SWIR1' , 'SWIR2' , 'pixel_qa' ] if len ( bands ) == 3 and all ( x in allowed_bands for x in bands ): pass else : raise Exception ( 'You can only select 3 bands from the following: {} ' . format ( ', ' . join ( allowed_bands ))) if nd_bands is not None : if len ( nd_bands ) == 2 and all ( x in allowed_bands [: - 1 ] for x in nd_bands ): pass else : raise Exception ( 'You can only select two bands from the following: {} ' . format ( ', ' . join ( allowed_bands [: - 1 ]))) try : col = landsat_timeseries ( roi , start_year , end_year , start_date , end_date , apply_fmask ) if vis_params is None : vis_params = {} vis_params [ 'bands' ] = bands vis_params [ 'min' ] = 0 vis_params [ 'max' ] = 4000 vis_params [ 'gamma' ] = [ 1 , 1 , 1 ] video_args = vis_params . copy () video_args [ 'dimensions' ] = dimensions video_args [ 'region' ] = roi video_args [ 'framesPerSecond' ] = frames_per_second video_args [ 'crs' ] = 'EPSG:3857' if 'bands' not in video_args . keys (): video_args [ 'bands' ] = bands if 'min' not in video_args . keys (): video_args [ 'min' ] = 0 if 'max' not in video_args . keys (): video_args [ 'max' ] = 4000 if 'gamma' not in video_args . keys (): video_args [ 'gamma' ] = [ 1 , 1 , 1 ] download_ee_video ( col , video_args , out_gif ) if nd_bands is not None : nd_images = landsat_ts_norm_diff ( col , bands = nd_bands , threshold = nd_threshold ) out_nd_gif = out_gif . replace ( '.gif' , '_nd.gif' ) landsat_ts_norm_diff_gif ( nd_images , out_gif = out_nd_gif , vis_params = None , palette = nd_palette , dimensions = dimensions , frames_per_second = frames_per_second ) return out_gif except Exception as e : print ( e )","title":"landsat_ts_gif()"},{"location":"geemap/#geemap.geemap.landsat_ts_norm_diff","text":"Computes a normalized difference index based on a Landsat timeseries. Parameters: Name Type Description Default collection ee.ImageCollection A Landsat timeseries. required bands list The bands to use for computing normalized difference. Defaults to ['Green', 'SWIR1']. ['Green', 'SWIR1'] threshold float The threshold to extract features. Defaults to 0. 0 Returns: Type Description ee.ImageCollection An ImageCollection containing images with values greater than the specified threshold. Source code in geemap/geemap.py def landsat_ts_norm_diff ( collection , bands = [ 'Green' , 'SWIR1' ], threshold = 0 ): \"\"\"Computes a normalized difference index based on a Landsat timeseries. Args: collection (ee.ImageCollection): A Landsat timeseries. bands (list, optional): The bands to use for computing normalized difference. Defaults to ['Green', 'SWIR1']. threshold (float, optional): The threshold to extract features. Defaults to 0. Returns: ee.ImageCollection: An ImageCollection containing images with values greater than the specified threshold. \"\"\" nd_images = collection . map ( lambda img : img . normalizedDifference ( bands ) . gt ( threshold ) . copyProperties ( img , img . propertyNames ())) return nd_images","title":"landsat_ts_norm_diff()"},{"location":"geemap/#geemap.geemap.landsat_ts_norm_diff_gif","text":"[summary] Parameters: Name Type Description Default collection ee.ImageCollection The normalized difference Landsat timeseires. required out_gif str File path to the output animated GIF. Defaults to None. None vis_params dict Visualization parameters. Defaults to None. None palette list The palette to use for visualizing the timelapse. Defaults to ['black', 'blue']. The first color in the list is the background color. ['black', 'blue'] dimensions int a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. 768 frames_per_second int Animation speed. Defaults to 10. 10 Returns: Type Description str File path to the output animated GIF. Source code in geemap/geemap.py def landsat_ts_norm_diff_gif ( collection , out_gif = None , vis_params = None , palette = [ 'black' , 'blue' ], dimensions = 768 , frames_per_second = 10 ): \"\"\"[summary] Args: collection (ee.ImageCollection): The normalized difference Landsat timeseires. out_gif (str, optional): File path to the output animated GIF. Defaults to None. vis_params (dict, optional): Visualization parameters. Defaults to None. palette (list, optional): The palette to use for visualizing the timelapse. Defaults to ['black', 'blue']. The first color in the list is the background color. dimensions (int, optional): a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768. frames_per_second (int, optional): Animation speed. Defaults to 10. Returns: str: File path to the output animated GIF. \"\"\" coordinates = ee . Image ( collection . first ()) . get ( 'coordinates' ) roi = ee . Geometry . Polygon ( coordinates , None , False ) if out_gif is None : out_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) filename = 'landsat_ts_nd_' + random_string () + '.gif' out_gif = os . path . join ( out_dir , filename ) elif not out_gif . endswith ( '.gif' ): raise Exception ( 'The output file must end with .gif' ) bands = [ 'nd' ] if vis_params is None : vis_params = {} vis_params [ 'bands' ] = bands vis_params [ 'palette' ] = palette video_args = vis_params . copy () video_args [ 'dimensions' ] = dimensions video_args [ 'region' ] = roi video_args [ 'framesPerSecond' ] = frames_per_second video_args [ 'crs' ] = 'EPSG:3857' if 'bands' not in video_args . keys (): video_args [ 'bands' ] = bands download_ee_video ( collection , video_args , out_gif ) return out_gif","title":"landsat_ts_norm_diff_gif()"},{"location":"geemap/#geemap.geemap.latlon_from_text","text":"Extracts latlon from text. Parameters: Name Type Description Default location str A pair of latlon coordinates separated by comma or space. required Returns: Type Description bool Returns (lat, lon) if valid. Source code in geemap/geemap.py def latlon_from_text ( location ): \"\"\"Extracts latlon from text. Args: location (str): A pair of latlon coordinates separated by comma or space. Returns: bool: Returns (lat, lon) if valid. \"\"\" latlon = [] try : if ',' in location : latlon = [ float ( x ) for x in location . split ( ',' )] elif ' ' in location : latlon = [ float ( x ) for x in location . split ( ' ' )] else : print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return None lat , lon = latlon [ 0 ], latlon [ 1 ] if lat >= - 90 and lat <= 90 and lon >= - 180 and lat <= 180 : return lat , lon else : return None except Exception as e : print ( e ) print ( 'The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3' ) return None","title":"latlon_from_text()"},{"location":"geemap/#geemap.geemap.legend_from_ee","text":"Extract legend from an Earth Engine class table on the Earth Engine Data Catalog page such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1 Value Color Description 0 1c0dff Water 1 05450a Evergreen needleleaf forest 2 086a10 Evergreen broadleaf forest 3 54a708 Deciduous needleleaf forest 4 78d203 Deciduous broadleaf forest 5 009900 Mixed forest 6 c6b044 Closed shrublands 7 dcd159 Open shrublands 8 dade48 Woody savannas 9 fbff13 Savannas 10 b6ff05 Grasslands 11 27ff87 Permanent wetlands 12 c24f44 Croplands 13 a5a5a5 Urban and built-up 14 ff6d4c Cropland/natural vegetation mosaic 15 69fff8 Snow and ice 16 f9ffa4 Barren or sparsely vegetated 254 ffffff Unclassified Parameters: Name Type Description Default ee_class_table str An Earth Engine class table with triple quotes. required Returns: Type Description dict Returns a legend dictionary that can be used to create a legend. Source code in geemap/geemap.py def legend_from_ee ( ee_class_table ): \"\"\"Extract legend from an Earth Engine class table on the Earth Engine Data Catalog page such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1 Value Color Description 0 1c0dff Water 1 05450a Evergreen needleleaf forest 2 086a10 Evergreen broadleaf forest 3 54a708 Deciduous needleleaf forest 4 78d203 Deciduous broadleaf forest 5 009900 Mixed forest 6 c6b044 Closed shrublands 7 dcd159 Open shrublands 8 dade48 Woody savannas 9 fbff13 Savannas 10 b6ff05 Grasslands 11 27ff87 Permanent wetlands 12 c24f44 Croplands 13 a5a5a5 Urban and built-up 14 ff6d4c Cropland/natural vegetation mosaic 15 69fff8 Snow and ice 16 f9ffa4 Barren or sparsely vegetated 254 ffffff Unclassified Args: ee_class_table (str): An Earth Engine class table with triple quotes. Returns: dict: Returns a legend dictionary that can be used to create a legend. \"\"\" try : ee_class_table = ee_class_table . strip () lines = ee_class_table . split ( ' \\n ' )[ 1 :] if lines [ 0 ] == 'Value \\t Color \\t Description' : lines = lines [ 1 :] legend_dict = {} for index , line in enumerate ( lines ): items = line . split ( \" \\t \" ) items = [ item . strip () for item in items ] color = items [ 1 ] key = items [ 0 ] + \" \" + items [ 2 ] legend_dict [ key ] = color return legend_dict except Exception as e : print ( e )","title":"legend_from_ee()"},{"location":"geemap/#geemap.geemap.load_GeoTIFF","text":"Loads a Cloud Optimized GeoTIFF (COG) as an Image. Only Google Cloud Storage is supported. The URL can be one of the following formats: Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF Parameters: Name Type Description Default URL str The Cloud Storage URL of the GeoTIFF to load. required Returns: Type Description ee.Image an Earth Engine image. Source code in geemap/geemap.py def load_GeoTIFF ( URL ): \"\"\"Loads a Cloud Optimized GeoTIFF (COG) as an Image. Only Google Cloud Storage is supported. The URL can be one of the following formats: Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF Args: URL (str): The Cloud Storage URL of the GeoTIFF to load. Returns: ee.Image: an Earth Engine image. \"\"\" uri = URL . strip () if uri . startswith ( 'https://storage.googleapis.com/' ): uri = uri . replace ( 'https://storage.googleapis.com/' , 'gs://' ) elif uri . startswith ( 'https://storage.cloud.google.com/' ): uri = uri . replace ( 'https://storage.cloud.google.com/' , 'gs://' ) if not uri . startswith ( 'gs://' ): raise Exception ( 'Invalid GCS URL: {} . Expected something of the form \"gs://bucket/path/to/object.tif\".' . format ( uri )) if not uri . lower () . endswith ( '.tif' ): raise Exception ( 'Invalid GCS URL: {} . Expected something of the form \"gs://bucket/path/to/object.tif\".' . format ( uri )) cloud_image = ee . Image . loadGeoTIFF ( uri ) return cloud_image","title":"load_GeoTIFF()"},{"location":"geemap/#geemap.geemap.load_GeoTIFFs","text":"Loads a list of Cloud Optimized GeoTIFFs (COG) as an ImageCollection. URLs is a list of URL, which can be one of the following formats: Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF Parameters: Name Type Description Default URLs list A list of Cloud Storage URL of the GeoTIFF to load. required Returns: Type Description ee.ImageCollection An Earth Engine ImageCollection. Source code in geemap/geemap.py def load_GeoTIFFs ( URLs ): \"\"\"Loads a list of Cloud Optimized GeoTIFFs (COG) as an ImageCollection. URLs is a list of URL, which can be one of the following formats: Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF Args: URLs (list): A list of Cloud Storage URL of the GeoTIFF to load. Returns: ee.ImageCollection: An Earth Engine ImageCollection. \"\"\" if not isinstance ( URLs , list ): raise Exception ( 'The URLs argument must be a list.' ) URIs = [] for URL in URLs : uri = URL . strip () if uri . startswith ( 'https://storage.googleapis.com/' ): uri = uri . replace ( 'https://storage.googleapis.com/' , 'gs://' ) elif uri . startswith ( 'https://storage.cloud.google.com/' ): uri = uri . replace ( 'https://storage.cloud.google.com/' , 'gs://' ) if not uri . startswith ( 'gs://' ): raise Exception ( 'Invalid GCS URL: {} . Expected something of the form \"gs://bucket/path/to/object.tif\".' . format ( uri )) if not uri . lower () . endswith ( '.tif' ): raise Exception ( 'Invalid GCS URL: {} . Expected something of the form \"gs://bucket/path/to/object.tif\".' . format ( uri )) URIs . append ( uri ) URIs = ee . List ( URIs ) collection = URIs . map ( lambda uri : ee . Image . loadGeoTIFF ( uri )) return ee . ImageCollection ( collection )","title":"load_GeoTIFFs()"},{"location":"geemap/#geemap.geemap.minimum_bounding_box","text":"Gets the minimum bounding box for a geojson polygon. Parameters: Name Type Description Default geojson dict A geojson dictionary. required Returns: Type Description tuple Returns a tuple containing the minimum bounding box in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -120)). Source code in geemap/geemap.py def minimum_bounding_box ( geojson ): \"\"\"Gets the minimum bounding box for a geojson polygon. Args: geojson (dict): A geojson dictionary. Returns: tuple: Returns a tuple containing the minimum bounding box in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -120)). \"\"\" coordinates = [] try : if 'geometry' in geojson . keys (): coordinates = geojson [ 'geometry' ][ 'coordinates' ][ 0 ] else : coordinates = geojson [ 'coordinates' ][ 0 ] lower_left = min ([ x [ 1 ] for x in coordinates ]), min ( [ x [ 0 ] for x in coordinates ]) # (lat, lon) upper_right = max ([ x [ 1 ] for x in coordinates ]), max ([ x [ 0 ] for x in coordinates ]) # (lat, lon) bounds = ( lower_left , upper_right ) return bounds except Exception as e : # print(e) return None","title":"minimum_bounding_box()"},{"location":"geemap/#geemap.geemap.naip_timeseries","text":"Creates NAIP annual timeseries Parameters: Name Type Description Default roi object An ee.Geometry representing the region of interest. Defaults to None. None start_year int Starting year for the timeseries. Defaults to2009. 2009 end_year int Ending year for the timeseries. Defaults to 2018. 2018 Returns: Type Description object An ee.ImageCollection representing annual NAIP imagery. Source code in geemap/geemap.py def naip_timeseries ( roi = None , start_year = 2009 , end_year = 2018 ): \"\"\"Creates NAIP annual timeseries Args: roi (object, optional): An ee.Geometry representing the region of interest. Defaults to None. start_year (int, optional): Starting year for the timeseries. Defaults to2009. end_year (int, optional): Ending year for the timeseries. Defaults to 2018. Returns: object: An ee.ImageCollection representing annual NAIP imagery. \"\"\" # ee_initialize() try : def get_annual_NAIP ( year ): try : collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) if roi is not None : collection = collection . filterBounds ( roi ) start_date = ee . Date . fromYMD ( year , 1 , 1 ) end_date = ee . Date . fromYMD ( year , 12 , 31 ) naip = collection . filterDate ( start_date , end_date ) \\ . filter ( ee . Filter . listContains ( \"system:band_names\" , \"N\" )) naip = ee . Image ( ee . ImageCollection ( naip ) . mosaic ()) return naip except Exception as e : print ( e ) years = ee . List . sequence ( start_year , end_year ) collection = years . map ( get_annual_NAIP ) return collection except Exception as e : print ( e )","title":"naip_timeseries()"},{"location":"geemap/#geemap.geemap.open_github","text":"Opens the GitHub repository for this package. Parameters: Name Type Description Default subdir str Sub-directory of the repository. Defaults to None. None Source code in geemap/geemap.py def open_github ( subdir = None ): \"\"\"Opens the GitHub repository for this package. Args: subdir (str, optional): Sub-directory of the repository. Defaults to None. \"\"\" import webbrowser url = 'https://github.com/giswqs/geemap' if subdir == 'source' : url += '/tree/master/geemap/' elif subdir == 'examples' : url += '/tree/master/examples' elif subdir == 'tutorials' : url += '/tree/master/tutorials' webbrowser . open_new_tab ( url )","title":"open_github()"},{"location":"geemap/#geemap.geemap.open_image_from_url","text":"Loads an image from the specified URL. Parameters: Name Type Description Default url str URL of the image. required Returns: Type Description object Image object. Source code in geemap/geemap.py def open_image_from_url ( url ): \"\"\"Loads an image from the specified URL. Args: url (str): URL of the image. Returns: object: Image object. \"\"\" from PIL import Image import requests from io import BytesIO from urllib.parse import urlparse try : # if url.endswith('.gif'): # out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') # if not os.path.exists(out_dir): # os.makedirs(out_dir) # a = urlparse(url) # out_name = os.path.basename(a.path) # out_path = os.path.join(out_dir, out_name) # download_from_url(url, out_name, out_dir, unzip=False) # img = Image.open(out_path) # else: response = requests . get ( url ) img = Image . open ( BytesIO ( response . content )) return img except Exception as e : print ( e )","title":"open_image_from_url()"},{"location":"geemap/#geemap.geemap.open_youtube","text":"Opens the YouTube tutorials for geemap. Source code in geemap/geemap.py def open_youtube (): \"\"\"Opens the YouTube tutorials for geemap. \"\"\" import webbrowser url = 'https://www.youtube.com/playlist?list=PLAxJ4-o7ZoPccOFv1dCwvGI6TYnirRTg3' webbrowser . open_new_tab ( url )","title":"open_youtube()"},{"location":"geemap/#geemap.geemap.read_api_csv","text":"Extracts Earth Engine API from a csv file and returns a dictionary containing information about each function. Returns: Type Description dict The dictionary containing information about each function, including name, description, function form, return type, arguments, html. Source code in geemap/geemap.py def read_api_csv (): \"\"\"Extracts Earth Engine API from a csv file and returns a dictionary containing information about each function. Returns: dict: The dictionary containing information about each function, including name, description, function form, return type, arguments, html. \"\"\" import copy import csv pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) data_dir = os . path . join ( pkg_dir , 'data' ) template_dir = os . path . join ( data_dir , 'template' ) csv_file = os . path . join ( template_dir , 'ee_api_docs.csv' ) html_file = os . path . join ( template_dir , 'ee_api_docs.html' ) with open ( html_file ) as f : in_html_lines = f . readlines () api_dict = {} with open ( csv_file , 'r' , encoding = 'utf-8' ) as f : csv_reader = csv . DictReader ( f , delimiter = ' \\t ' ) for line in csv_reader : out_html_lines = copy . copy ( in_html_lines ) out_html_lines [ 65 ] = in_html_lines [ 65 ] . replace ( 'function_name' , line [ 'name' ]) out_html_lines [ 66 ] = in_html_lines [ 66 ] . replace ( 'function_description' , line . get ( 'description' )) out_html_lines [ 74 ] = in_html_lines [ 74 ] . replace ( 'function_usage' , line . get ( 'function' )) out_html_lines [ 75 ] = in_html_lines [ 75 ] . replace ( 'function_returns' , line . get ( 'returns' )) arguments = line . get ( 'argument' ) types = line . get ( 'type' ) details = line . get ( 'details' ) if '|' in arguments : argument_items = arguments . split ( '|' ) else : argument_items = [ arguments ] if '|' in types : types_items = types . split ( '|' ) else : types_items = [ types ] if '|' in details : details_items = details . split ( '|' ) else : details_items = [ details ] out_argument_lines = [] for index in range ( len ( argument_items )): in_argument_lines = in_html_lines [ 87 : 92 ] in_argument_lines [ 1 ] = in_argument_lines [ 1 ] . replace ( 'function_argument' , argument_items [ index ]) in_argument_lines [ 2 ] = in_argument_lines [ 2 ] . replace ( 'function_type' , types_items [ index ]) in_argument_lines [ 3 ] = in_argument_lines [ 3 ] . replace ( 'function_details' , details_items [ index ]) out_argument_lines . append ( \"\" . join ( in_argument_lines )) out_html_lines = out_html_lines [: 87 ] + \\ out_argument_lines + out_html_lines [ 92 :] contents = '' . join ( out_html_lines ) api_dict [ line [ 'name' ]] = { 'description' : line . get ( 'description' ), 'function' : line . get ( 'function' ), 'returns' : line . get ( 'returns' ), 'argument' : line . get ( 'argument' ), 'type' : line . get ( 'type' ), 'details' : line . get ( 'details' ), 'html' : contents } return api_dict","title":"read_api_csv()"},{"location":"geemap/#geemap.geemap.reduce_gif_size","text":"Reduces a GIF image using ffmpeg. Parameters: Name Type Description Default in_gif str The input file path to the GIF image. required out_gif str The output file path to the GIF image. Defaults to None. None Source code in geemap/geemap.py def reduce_gif_size ( in_gif , out_gif = None ): \"\"\"Reduces a GIF image using ffmpeg. Args: in_gif (str): The input file path to the GIF image. out_gif (str, optional): The output file path to the GIF image. Defaults to None. \"\"\" import ffmpeg import shutil if not is_tool ( 'ffmpeg' ): print ( 'ffmpeg is not installed on your computer.' ) return if not os . path . exists ( in_gif ): print ( 'The input gif file does not exist.' ) return if out_gif is None : out_gif = in_gif elif not os . path . exists ( os . path . dirname ( out_gif )): os . makedirs ( os . path . dirname ( out_gif )) if in_gif == out_gif : tmp_gif = in_gif . replace ( '.gif' , '_tmp.gif' ) shutil . copyfile ( in_gif , tmp_gif ) stream = ffmpeg . input ( tmp_gif ) stream = ffmpeg . output ( stream , in_gif ) . overwrite_output () ffmpeg . run ( stream ) os . remove ( tmp_gif ) else : stream = ffmpeg . input ( in_gif ) stream = ffmpeg . output ( stream , out_gif ) . overwrite_output () ffmpeg . run ( stream )","title":"reduce_gif_size()"},{"location":"geemap/#geemap.geemap.rgb_to_hex","text":"Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255. Parameters: Name Type Description Default rgb tuple RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255). (255, 255, 255) Returns: Type Description str hex color code Source code in geemap/geemap.py def rgb_to_hex ( rgb = ( 255 , 255 , 255 )): \"\"\"Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255. Args: rgb (tuple, optional): RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255). Returns: str: hex color code \"\"\" return ' %02x%02x%02x ' % rgb","title":"rgb_to_hex()"},{"location":"geemap/#geemap.geemap.screen_capture","text":"Takes a full screenshot of the selected monitor. Parameters: Name Type Description Default outfile str The output file path to the screenshot. required monitor int The monitor to take the screenshot. Defaults to 1. 1 Source code in geemap/geemap.py def screen_capture ( outfile , monitor = 1 ): \"\"\"Takes a full screenshot of the selected monitor. Args: outfile (str): The output file path to the screenshot. monitor (int, optional): The monitor to take the screenshot. Defaults to 1. \"\"\" from mss import mss out_dir = os . path . dirname ( outfile ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) if not isinstance ( monitor , int ): print ( 'The monitor number must be an integer.' ) return try : with mss () as sct : sct . shot ( output = outfile , mon = monitor ) return outfile except Exception as e : print ( e )","title":"screen_capture()"},{"location":"geemap/#geemap.geemap.search_api_tree","text":"Search Earth Engine API and return functions containing the specified keywords Parameters: Name Type Description Default keywords str The keywords to search for. required api_tree dict The dictionary containing the Earth Engine API tree. required Returns: Type Description object An ipytree object/widget. Source code in geemap/geemap.py def search_api_tree ( keywords , api_tree ): \"\"\"Search Earth Engine API and return functions containing the specified keywords Args: keywords (str): The keywords to search for. api_tree (dict): The dictionary containing the Earth Engine API tree. Returns: object: An ipytree object/widget. \"\"\" import warnings warnings . filterwarnings ( 'ignore' ) sub_tree = Tree () for key in api_tree . keys (): if keywords in key : sub_tree . add_node ( api_tree [ key ]) return sub_tree","title":"search_api_tree()"},{"location":"geemap/#geemap.geemap.search_ee_data","text":"Searches Earth Engine data catalog. Parameters: Name Type Description Default keywords str Keywords to search for can be id, provider, tag and so on required Returns: Type Description list Returns a lit of assets. Source code in geemap/geemap.py def search_ee_data ( keywords ): \"\"\"Searches Earth Engine data catalog. Args: keywords (str): Keywords to search for can be id, provider, tag and so on Returns: list: Returns a lit of assets. \"\"\" try : cmd = 'geeadd search --keywords \" {} \"' . format ( str ( keywords )) output = os . popen ( cmd ) . read () start_index = output . index ( '[' ) assets = eval ( output [ start_index :]) results = [] for asset in assets : asset_dates = asset [ 'start_date' ] + ' - ' + asset [ 'end_date' ] asset_snippet = asset [ 'ee_id_snippet' ] start_index = asset_snippet . index ( \"'\" ) + 1 end_index = asset_snippet . index ( \"'\" , start_index ) asset_id = asset_snippet [ start_index : end_index ] asset [ 'dates' ] = asset_dates asset [ 'id' ] = asset_id asset [ 'uid' ] = asset_id . replace ( '/' , '_' ) # asset['url'] = 'https://developers.google.com/earth-engine/datasets/catalog/' + asset['uid'] # asset['thumbnail'] = 'https://mw1.google.com/ges/dd/images/{}_sample.png'.format( # asset['uid']) results . append ( asset ) return results except Exception as e : print ( e )","title":"search_ee_data()"},{"location":"geemap/#geemap.geemap.sentinel2_timeseries","text":"Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Images include both level 1C and level 2A imagery. Parameters: Name Type Description Default roi object Region of interest to create the timelapse. Defaults to None. None start_year int Starting year for the timelapse. Defaults to 2015. 2015 end_year int Ending year for the timelapse. Defaults to 2019. 2019 start_date str Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'. '01-01' end_date str Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'. '12-31' Returns: Type Description object Returns an ImageCollection containing annual Sentinel 2 images. Source code in geemap/geemap.py def sentinel2_timeseries ( roi = None , start_year = 2015 , end_year = 2019 , start_date = '01-01' , end_date = '12-31' ): \"\"\"Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work. Images include both level 1C and level 2A imagery. Args: roi (object, optional): Region of interest to create the timelapse. Defaults to None. start_year (int, optional): Starting year for the timelapse. Defaults to 2015. end_year (int, optional): Ending year for the timelapse. Defaults to 2019. start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'. end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'. Returns: object: Returns an ImageCollection containing annual Sentinel 2 images. \"\"\" ################################################################################ ################################################################################ # Input and output parameters. import re import datetime # ee_initialize() if roi is None : # roi = ee.Geometry.Polygon( # [[[-180, -80], # [-180, 80], # [180, 80], # [180, -80], # [-180, -80]]], None, False) roi = ee . Geometry . Polygon ( [[[ - 115.471773 , 35.892718 ], [ - 115.471773 , 36.409454 ], [ - 114.271283 , 36.409454 ], [ - 114.271283 , 35.892718 ], [ - 115.471773 , 35.892718 ]]], None , False ) if not isinstance ( roi , ee . Geometry ): try : roi = roi . geometry () except Exception as e : print ( 'Could not convert the provided roi to ee.Geometry' ) print ( e ) return # Adjusts longitudes less than -180 degrees or greater than 180 degrees. geojson = ee_to_geojson ( roi ) geojson = adjust_longitude ( geojson ) roi = ee . Geometry ( geojson ) ################################################################################ # Setup vars to get dates. if isinstance ( start_year , int ) and ( start_year >= 2015 ) and ( start_year <= 2020 ): pass else : print ( 'The start year must be an integer >= 2015.' ) return if isinstance ( end_year , int ) and ( end_year >= 2015 ) and ( end_year <= 2020 ): pass else : print ( 'The end year must be an integer <= 2020.' ) return if re . match ( \"[0-9] {2} \\-[0-9] {2} \" , start_date ) and re . match ( \"[0-9] {2} \\-[0-9] {2} \" , end_date ): pass else : print ( 'The start data and end date must be month-day, such as 06-10, 09-20' ) return try : datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) except Exception as e : print ( 'The input dates are invalid.' ) print ( e ) return try : start_test = datetime . datetime ( int ( start_year ), int ( start_date [: 2 ]), int ( start_date [ 3 : 5 ])) end_test = datetime . datetime ( int ( end_year ), int ( end_date [: 2 ]), int ( end_date [ 3 : 5 ])) if start_test > end_test : raise ValueError ( 'Start date must be prior to end date' ) except Exception as e : print ( e ) return def days_between ( d1 , d2 ): d1 = datetime . datetime . strptime ( d1 , \"%Y-%m- %d \" ) d2 = datetime . datetime . strptime ( d2 , \"%Y-%m- %d \" ) return abs (( d2 - d1 ) . days ) n_days = days_between ( str ( start_year ) + '-' + start_date , str ( start_year ) + '-' + end_date ) start_month = int ( start_date [: 2 ]) start_day = int ( start_date [ 3 : 5 ]) start_date = str ( start_year ) + '-' + start_date end_date = str ( end_year ) + '-' + end_date # Define a collection filter by date, bounds, and quality. def colFilter ( col , aoi ): # , startDate, endDate): return ( col . filterBounds ( aoi )) # Get Sentinel 2 collections, both Level-1C (top of atmophere) and Level-2A (surface reflectance) MSILCcol = ee . ImageCollection ( 'COPERNICUS/S2' ) MSI2Acol = ee . ImageCollection ( 'COPERNICUS/S2_SR' ) # Define a collection filter by date, bounds, and quality. def colFilter ( col , roi , start_date , end_date ): return ( col . filterBounds ( roi ) . filterDate ( start_date , end_date )) # .filter('CLOUD_COVER < 5') # .filter('GEOMETRIC_RMSE_MODEL < 15') # .filter('IMAGE_QUALITY == 9 || IMAGE_QUALITY_OLI == 9')) # Function to get and rename bands of interest from MSI def renameMSI ( img ): return ( img . select ( [ 'B2' , 'B3' , 'B4' , 'B5' , 'B6' , 'B7' , 'B8' , 'B8A' , 'B11' , 'B12' , 'QA60' ], [ 'Blue' , 'Green' , 'Red' , 'Red Edge 1' , 'Red Edge 2' , 'Red Edge 3' , 'NIR' , 'Red Edge 4' , 'SWIR1' , 'SWIR2' , 'QA60' ])) # Add NBR for LandTrendr segmentation. def calcNbr ( img ): return ( img . addBands ( img . normalizedDifference ([ 'NIR' , 'SWIR2' ]) . multiply ( - 10000 ) . rename ( 'NBR' )) . int16 ()) # Define function to mask out clouds and cloud shadows in images. # Use CFmask band included in USGS Landsat SR image product. def fmask ( img ): cloudOpaqueBitMask = 1 << 10 cloudCirrusBitMask = 1 << 11 qa = img . select ( 'QA60' ) mask = qa . bitwiseAnd ( cloudOpaqueBitMask ) . eq ( 0 ) \\ . And ( qa . bitwiseAnd ( cloudCirrusBitMask ) . eq ( 0 )) return ( img . updateMask ( mask )) # Define function to prepare MSI images. def prepMSI ( img ): orig = img img = renameMSI ( img ) img = fmask ( img ) return ( ee . Image ( img . copyProperties ( orig , orig . propertyNames ())) . resample ( 'bicubic' )) # Get annual median collection. def getAnnualComp ( y ): startDate = ee . Date . fromYMD ( ee . Number ( y ), ee . Number ( start_month ), ee . Number ( start_day )) endDate = startDate . advance ( ee . Number ( n_days ), 'day' ) # Filter collections and prepare them for merging. MSILCcoly = colFilter ( MSILCcol , roi , startDate , endDate ) . map ( prepMSI ) MSI2Acoly = colFilter ( MSI2Acol , roi , startDate , endDate ) . map ( prepMSI ) # Merge the collections. col = MSILCcoly . merge ( MSI2Acoly ) yearImg = col . median () nBands = yearImg . bandNames () . size () yearImg = ee . Image ( ee . Algorithms . If ( nBands , yearImg , dummyImg )) return ( calcNbr ( yearImg ) . set ({ 'year' : y , 'system:time_start' : startDate . millis (), 'nBands' : nBands })) ################################################################################ # Make a dummy image for missing years. bandNames = ee . List ([ 'Blue' , 'Green' , 'Red' , 'Red Edge 1' , 'Red Edge 2' , 'Red Edge 3' , 'NIR' , 'Red Edge 4' , 'SWIR1' , 'SWIR2' , 'QA60' ]) fillerValues = ee . List . repeat ( 0 , bandNames . size ()) dummyImg = ee . Image . constant ( fillerValues ) . rename ( bandNames ) \\ . selfMask () . int16 () ################################################################################ # Get a list of years years = ee . List . sequence ( start_year , end_year ) ################################################################################ # Make list of annual image composites. imgList = years . map ( getAnnualComp ) # Convert image composite list to collection imgCol = ee . ImageCollection . fromImages ( imgList ) imgCol = imgCol . map ( lambda img : img . clip ( roi )) return imgCol","title":"sentinel2_timeseries()"},{"location":"geemap/#geemap.geemap.set_proxy","text":"Sets proxy if needed. This is only needed for countries where Google services are not available. Parameters: Name Type Description Default port int The proxy port number. Defaults to 1080. 1080 ip str The IP address. Defaults to 'http://127.0.0.1'. 'http://127.0.0.1' Source code in geemap/geemap.py def set_proxy ( port = 1080 , ip = 'http://127.0.0.1' ): \"\"\"Sets proxy if needed. This is only needed for countries where Google services are not available. Args: port (int, optional): The proxy port number. Defaults to 1080. ip (str, optional): The IP address. Defaults to 'http://127.0.0.1'. \"\"\" import os import requests try : if not ip . startswith ( 'http' ): ip = 'http://' + ip proxy = ' {} : {} ' . format ( ip , port ) os . environ [ 'HTTP_PROXY' ] = proxy os . environ [ 'HTTPS_PROXY' ] = proxy a = requests . get ( 'https://earthengine.google.com/' ) if a . status_code != 200 : print ( 'Failed to connect to Earth Engine. Please double check the port number and ip address.' ) except Exception as e : print ( e )","title":"set_proxy()"},{"location":"geemap/#geemap.geemap.show_image","text":"Shows an image within Jupyter notebook. Parameters: Name Type Description Default img_path str The image file path. required width int Width of the image in pixels. Defaults to None. None height int Height of the image in pixels. Defaults to None. None Source code in geemap/geemap.py def show_image ( img_path , width = None , height = None ): \"\"\"Shows an image within Jupyter notebook. Args: img_path (str): The image file path. width (int, optional): Width of the image in pixels. Defaults to None. height (int, optional): Height of the image in pixels. Defaults to None. \"\"\" from IPython.display import display try : out = widgets . Output () # layout={'border': '1px solid black'}) # layout={'border': '1px solid black', 'width': str(width + 20) + 'px', 'height': str(height + 10) + 'px'},) out . clear_output ( wait = True ) display ( out ) with out : file = open ( img_path , \"rb\" ) image = file . read () if ( width is None ) and ( height is None ): display ( widgets . Image ( value = image )) elif ( width is not None ) and ( height is not None ): display ( widgets . Image ( value = image , width = width , height = height )) else : print ( 'You need set both width and height.' ) return except Exception as e : print ( e )","title":"show_image()"},{"location":"geemap/#geemap.geemap.show_youtube","text":"Displays a YouTube video within Jupyter notebooks. Parameters: Name Type Description Default id str Unique ID of the video. Defaults to 'h0pz3S6Tvx0'. 'h0pz3S6Tvx0' Source code in geemap/geemap.py def show_youtube ( id = 'h0pz3S6Tvx0' ): \"\"\"Displays a YouTube video within Jupyter notebooks. Args: id (str, optional): Unique ID of the video. Defaults to 'h0pz3S6Tvx0'. \"\"\" from IPython.display import YouTubeVideo , display try : out = widgets . Output ( layout = { 'width' : '815px' }) # layout={'border': '1px solid black', 'width': '815px'}) out . clear_output ( wait = True ) display ( out ) with out : display ( YouTubeVideo ( id , width = 800 , height = 450 )) except Exception as e : print ( e )","title":"show_youtube()"},{"location":"geemap/#geemap.geemap.shp_to_ee","text":"Converts a shapefile to Earth Engine objects. Note that the CRS of the shapefile must be EPSG:4326 Parameters: Name Type Description Default in_shp str File path to a shapefile. required Returns: Type Description object Earth Engine objects representing the shapefile. Source code in geemap/geemap.py def shp_to_ee ( in_shp ): \"\"\"Converts a shapefile to Earth Engine objects. Note that the CRS of the shapefile must be EPSG:4326 Args: in_shp (str): File path to a shapefile. Returns: object: Earth Engine objects representing the shapefile. \"\"\" # ee_initialize() try : json_data = shp_to_geojson ( in_shp ) ee_object = geojson_to_ee ( json_data ) return ee_object except Exception as e : print ( e )","title":"shp_to_ee()"},{"location":"geemap/#geemap.geemap.shp_to_geojson","text":"Converts a shapefile to GeoJSON. Parameters: Name Type Description Default in_shp str File path of the input shapefile. required out_json str File path of the output GeoJSON. Defaults to None. None Returns: Type Description object The json object representing the shapefile. Source code in geemap/geemap.py def shp_to_geojson ( in_shp , out_json = None ): \"\"\"Converts a shapefile to GeoJSON. Args: in_shp (str): File path of the input shapefile. out_json (str, optional): File path of the output GeoJSON. Defaults to None. Returns: object: The json object representing the shapefile. \"\"\" # check_install('pyshp') # ee_initialize() try : import json import shapefile in_shp = os . path . abspath ( in_shp ) if out_json is None : out_json = os . path . splitext ( in_shp )[ 0 ] + \".json\" if os . path . exists ( out_json ): out_json = out_json . replace ( '.json' , '_bk.json' ) elif not os . path . exists ( os . path . dirname ( out_json )): os . makedirs ( os . path . dirname ( out_json )) reader = shapefile . Reader ( in_shp ) fields = reader . fields [ 1 :] field_names = [ field [ 0 ] for field in fields ] buffer = [] for sr in reader . shapeRecords (): atr = dict ( zip ( field_names , sr . record )) geom = sr . shape . __geo_interface__ buffer . append ( dict ( type = \"Feature\" , geometry = geom , properties = atr )) from json import dumps geojson = open ( out_json , \"w\" ) geojson . write ( dumps ({ \"type\" : \"FeatureCollection\" , \"features\" : buffer }, indent = 2 ) + \" \\n \" ) geojson . close () with open ( out_json ) as f : json_data = json . load ( f ) return json_data except Exception as e : print ( e )","title":"shp_to_geojson()"},{"location":"geemap/#geemap.geemap.system_fonts","text":"Gets a list of system fonts. # Common font locations: # Linux: /usr/share/fonts/TTF/ # Windows: C:\\Windows\\Fonts # macOS: System > Library > Fonts Parameters: Name Type Description Default show_full_path bool Whether to show the full path of each system font. Defaults to False. False Returns: Type Description list A list of system fonts. Source code in geemap/geemap.py def system_fonts ( show_full_path = False ): \"\"\"Gets a list of system fonts. # Common font locations: # Linux: /usr/share/fonts/TTF/ # Windows: C:\\Windows\\Fonts # macOS: System > Library > Fonts Args: show_full_path (bool, optional): Whether to show the full path of each system font. Defaults to False. Returns: list: A list of system fonts. \"\"\" try : import matplotlib.font_manager font_list = matplotlib . font_manager . findSystemFonts ( fontpaths = None , fontext = 'ttf' ) font_list . sort () font_names = [ os . path . basename ( f ) for f in font_list ] font_names . sort () if show_full_path : return font_list else : return font_names except Exception as e : print ( e )","title":"system_fonts()"},{"location":"geemap/#geemap.geemap.update_package","text":"Updates the geemap package from the geemap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. Source code in geemap/geemap.py def update_package (): \"\"\"Updates the geemap package from the geemap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. \"\"\" import shutil try : download_dir = os . path . join ( os . path . expanduser ( '~' ), 'Downloads' ) if not os . path . exists ( download_dir ): os . makedirs ( download_dir ) clone_repo ( out_dir = download_dir ) pkg_dir = os . path . join ( download_dir , 'geemap-master' ) work_dir = os . getcwd () os . chdir ( pkg_dir ) if shutil . which ( 'pip' ) is None : cmd = 'pip3 install .' else : cmd = 'pip install .' os . system ( cmd ) os . chdir ( work_dir ) print ( \" \\n Please comment out 'geemap.update_package()' and restart the kernel to take effect: \\n Jupyter menu -> Kernel -> Restart & Clear Output\" ) except Exception as e : print ( e )","title":"update_package()"},{"location":"geemap/#geemap.geemap.upload_to_imgur","text":"Uploads an image to imgur.com Parameters: Name Type Description Default in_gif str The file path to the image. required Source code in geemap/geemap.py def upload_to_imgur ( in_gif ): \"\"\"Uploads an image to imgur.com Args: in_gif (str): The file path to the image. \"\"\" import subprocess pkg_name = 'imgur-uploader' if not is_tool ( pkg_name ): check_install ( pkg_name ) try : IMGUR_API_ID = os . environ . get ( 'IMGUR_API_ID' , None ) IMGUR_API_SECRET = os . environ . get ( 'IMGUR_API_SECRET' , None ) credentials_path = os . path . join ( os . path . expanduser ( '~' ), '.config/imgur_uploader/uploader.cfg' ) if (( IMGUR_API_ID is not None ) and ( IMGUR_API_SECRET is not None )) or os . path . exists ( credentials_path ): proc = subprocess . Popen ( [ 'imgur-uploader' , in_gif ], stdout = subprocess . PIPE ) for i in range ( 0 , 2 ): line = proc . stdout . readline () print ( line . rstrip () . decode ( \"utf-8\" )) # while True: # line = proc.stdout.readline() # if not line: # break # print(line.rstrip().decode(\"utf-8\")) else : print ( 'Imgur API credentials could not be found. Please check https://pypi.org/project/imgur-uploader/ for instructions on how to get Imgur API credentials' ) return except Exception as e : print ( e )","title":"upload_to_imgur()"},{"location":"geemap/#geemap.geemap.zonal_statistics","text":"Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Parameters: Name Type Description Default in_value_raster object An ee.Image that contains the values on which to calculate a statistic. required in_zone_vector object An ee.FeatureCollection that defines the zones. required out_file_path str Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz required statistics_type str Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps. 'MEAN' scale float A nominal scale in meters of the projection to work in. Defaults to None. None crs str The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. None tile_scale float A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. 1.0 Source code in geemap/geemap.py def zonal_statistics ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'MEAN' , scale = None , crs = None , tile_scale = 1.0 , ** kwargs ): \"\"\"Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Args: in_value_raster (object): An ee.Image that contains the values on which to calculate a statistic. in_zone_vector (object): An ee.FeatureCollection that defines the zones. out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz statistics_type (str, optional): Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. \"\"\" if not isinstance ( in_value_raster , ee . Image ): print ( 'The input raster must be an ee.Image.' ) return if not isinstance ( in_zone_vector , ee . FeatureCollection ): print ( 'The input zone data must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' ] filename = os . path . abspath ( out_file_path ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] . lower () if not ( filetype in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return # Parameters for histogram # The maximum number of buckets to use when building a histogram; will be rounded up to a power of 2. max_buckets = None # The minimum histogram bucket width, or null to allow any power of 2. min_bucket_width = None # The number of values to accumulate before building the initial histogram. max_raw = None hist_min = 1.0 # The lower (inclusive) bound of the first bucket. hist_max = 100.0 # The upper (exclusive) bound of the last bucket. hist_steps = 10 # The number of buckets to use. if 'max_buckets' in kwargs . keys (): max_buckets = kwargs [ 'max_buckets' ] if 'min_bucket_width' in kwargs . keys (): min_bucket_width = kwargs [ 'min_bucket' ] if 'max_raw' in kwargs . keys (): max_raw = kwargs [ 'max_raw' ] if statistics_type . upper () == 'FIXED_HIST' and ( 'hist_min' in kwargs . keys ()) and ( 'hist_max' in kwargs . keys ()) and ( 'hist_steps' in kwargs . keys ()): hist_min = kwargs [ 'hist_min' ] hist_max = kwargs [ 'hist_max' ] hist_steps = kwargs [ 'hist_steps' ] elif statistics_type . upper () == 'FIXED_HIST' : print ( 'To use fixedHistogram, please provide these three parameters: hist_min, hist_max, and hist_steps.' ) return allowed_statistics = { 'MEAN' : ee . Reducer . mean (), 'MAXIMUM' : ee . Reducer . max (), 'MEDIAN' : ee . Reducer . median (), 'MINIMUM' : ee . Reducer . min (), 'STD' : ee . Reducer . stdDev (), 'MIN_MAX' : ee . Reducer . minMax (), 'SUM' : ee . Reducer . sum (), 'VARIANCE' : ee . Reducer . variance (), 'HIST' : ee . Reducer . histogram ( maxBuckets = max_buckets , minBucketWidth = min_bucket_width , maxRaw = max_raw ), 'FIXED_HIST' : ee . Reducer . fixedHistogram ( hist_min , hist_max , hist_steps ) } if not ( statistics_type . upper () in allowed_statistics . keys ()): print ( 'The statistics type must be one of the following: {} ' . format ( ', ' . join ( list ( allowed_statistics . keys ())))) return if scale is None : scale = in_value_raster . projection () . nominalScale () . multiply ( 10 ) try : print ( 'Computing statistics ...' ) result = in_value_raster . reduceRegions ( collection = in_zone_vector , reducer = allowed_statistics [ statistics_type ], scale = scale , crs = crs , tileScale = tile_scale ) ee_export_vector ( result , filename ) except Exception as e : print ( e )","title":"zonal_statistics()"},{"location":"geemap/#geemap.geemap.zonal_statistics_by_group","text":"Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Parameters: Name Type Description Default in_value_raster object An integer Image that contains the values on which to calculate area/percentage. required in_zone_vector object An ee.FeatureCollection that defines the zones. required out_file_path str Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz required statistics_type str Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'. 'SUM' decimal_places int The number of decimal places to use. Defaults to 0. 0 denominator float To covert area units (e.g., from square meters to square kilometers). Defaults to 1.0. 1.0 scale float A nominal scale in meters of the projection to work in. Defaults to None. None crs str The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. None tile_scale float A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. 1.0 Source code in geemap/geemap.py def zonal_statistics_by_group ( in_value_raster , in_zone_vector , out_file_path , statistics_type = 'SUM' , decimal_places = 0 , denominator = 1.0 , scale = None , crs = None , tile_scale = 1.0 ): \"\"\"Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz. Args: in_value_raster (object): An integer Image that contains the values on which to calculate area/percentage. in_zone_vector (object): An ee.FeatureCollection that defines the zones. out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz statistics_type (str, optional): Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'. decimal_places (int, optional): The number of decimal places to use. Defaults to 0. denominator (float, optional): To covert area units (e.g., from square meters to square kilometers). Defaults to 1.0. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None. tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0. \"\"\" if not isinstance ( in_value_raster , ee . Image ): print ( 'The input raster must be an ee.Image.' ) return band_count = in_value_raster . bandNames () . size () . getInfo () band_name = '' if band_count == 1 : band_name = in_value_raster . bandNames () . get ( 0 ) else : print ( 'The input image can only have one band.' ) return band_types = in_value_raster . bandTypes () . get ( band_name ) . getInfo () band_type = band_types . get ( 'precision' ) if band_type != 'int' : print ( 'The input image band must be integer type.' ) return if not isinstance ( in_zone_vector , ee . FeatureCollection ): print ( 'The input zone data must be an ee.FeatureCollection.' ) return allowed_formats = [ 'csv' , 'json' , 'kml' , 'kmz' , 'shp' ] filename = os . path . abspath ( out_file_path ) basename = os . path . basename ( filename ) name = os . path . splitext ( basename )[ 0 ] filetype = os . path . splitext ( basename )[ 1 ][ 1 :] if not ( filetype . lower () in allowed_formats ): print ( 'The file type must be one of the following: {} ' . format ( ', ' . join ( allowed_formats ))) return out_dir = os . path . dirname ( filename ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) allowed_statistics = [ 'SUM' , 'PERCENTAGE' ] if not ( statistics_type . upper () in allowed_statistics ): print ( 'The statistics type can only be one of {} ' . format ( ', ' . join ( allowed_statistics ))) return if scale is None : scale = in_value_raster . projection () . nominalScale () . multiply ( 10 ) try : print ( 'Computing ... ' ) geometry = in_zone_vector . geometry () hist = in_value_raster . reduceRegion ( ee . Reducer . frequencyHistogram ( ), geometry = geometry , bestEffort = True , scale = scale ) class_values = ee . Dictionary ( hist . get ( band_name )) . keys () . map ( lambda v : ee . Number . parse ( v )) . sort () class_names = class_values . map ( lambda c : ee . String ( 'Class_' ) . cat ( ee . Number ( c ) . format ())) class_count = class_values . size () . getInfo () dataset = ee . Image . pixelArea () . divide ( denominator ) . addBands ( in_value_raster ) init_result = dataset . reduceRegions ( ** { 'collection' : in_zone_vector , 'reducer' : ee . Reducer . sum () . group ( ** { 'groupField' : 1 , 'groupName' : 'group' , }), 'scale' : scale }) def build_dict ( input_list ): decimal_format = '%. {} f' . format ( decimal_places ) in_dict = input_list . map ( lambda x : ee . Dictionary () . set ( ee . String ( 'Class_' ) . cat ( ee . Number ( ee . Dictionary ( x ) . get ( 'group' )) . format ()), ee . Number . parse ( ee . Number ( ee . Dictionary ( x ) . get ( 'sum' )) . format ( decimal_format )))) return in_dict def get_keys ( input_list ): return input_list . map ( lambda x : ee . String ( 'Class_' ) . cat ( ee . Number ( ee . Dictionary ( x ) . get ( 'group' )) . format ())) def get_values ( input_list ): decimal_format = '%. {} f' . format ( decimal_places ) return input_list . map ( lambda x : ee . Number . parse ( ee . Number ( ee . Dictionary ( x ) . get ( 'sum' )) . format ( decimal_format ))) def set_attribute ( f ): groups = ee . List ( f . get ( 'groups' )) keys = get_keys ( groups ) values = get_values ( groups ) total_area = ee . List ( values ) . reduce ( ee . Reducer . sum ()) def get_class_values ( x ): cls_value = ee . Algorithms . If ( keys . contains ( x ), values . get ( keys . indexOf ( x )), 0 ) cls_value = ee . Algorithms . If ( ee . String ( statistics_type ) . compareTo ( ee . String ( 'SUM' )), ee . Number ( cls_value ) . divide ( ee . Number ( total_area )), cls_value ) return cls_value full_values = class_names . map ( lambda x : get_class_values ( x )) attr_dict = ee . Dictionary . fromLists ( class_names , full_values ) attr_dict = attr_dict . set ( 'Class_sum' , total_area ) return f . set ( attr_dict ) . set ( 'groups' , None ) final_result = init_result . map ( set_attribute ) ee_export_vector ( final_result , filename ) except Exception as e : print ( e )","title":"zonal_statistics_by_group()"},{"location":"get-started/","text":"Get Started This Get Started guide is intended as a quick way to start programming with geemap and the Earth Engine Python API. Launch Jupyter notebook conda activate gee jupyter notebook Import libraries import ee import geemap Create an interactive map Map = geemap.Map(center=(40, -100), zoom=4) Map Add Earth Engine data # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LE7_TOA_5YEAR/1999_2003') states = ee.FeatureCollection(\"TIGER/2018/States\") Set visualization parameters dem_vis = { 'min': 0, 'max': 4000, 'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']} landsat_vis = { 'min': 20, 'max': 200, 'bands': ['B4', 'B3', 'B2'] } Display data on the map Map.addLayer(dem, dem_vis, 'STRM DEM', True, 0.5) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(landsat7, landsat_vis, 'Landsat 7') Map.addLayer(states, {}, \"US States\") Interact with the map Once data are added to the map, you can interact with data using vairous tools, such as the drawing tools, inspector tool, plotting tool. Check the video below on how to use the Inspector tool to query Earth Engine interactively.","title":"Get Started"},{"location":"get-started/#get-started","text":"This Get Started guide is intended as a quick way to start programming with geemap and the Earth Engine Python API.","title":"Get Started"},{"location":"get-started/#launch-jupyter-notebook","text":"conda activate gee jupyter notebook","title":"Launch Jupyter notebook"},{"location":"get-started/#import-libraries","text":"import ee import geemap","title":"Import libraries"},{"location":"get-started/#create-an-interactive-map","text":"Map = geemap.Map(center=(40, -100), zoom=4) Map","title":"Create an interactive map"},{"location":"get-started/#add-earth-engine-data","text":"# Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LE7_TOA_5YEAR/1999_2003') states = ee.FeatureCollection(\"TIGER/2018/States\")","title":"Add Earth Engine data"},{"location":"get-started/#set-visualization-parameters","text":"dem_vis = { 'min': 0, 'max': 4000, 'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']} landsat_vis = { 'min': 20, 'max': 200, 'bands': ['B4', 'B3', 'B2'] }","title":"Set visualization parameters"},{"location":"get-started/#display-data-on-the-map","text":"Map.addLayer(dem, dem_vis, 'STRM DEM', True, 0.5) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(landsat7, landsat_vis, 'Landsat 7') Map.addLayer(states, {}, \"US States\")","title":"Display data on the map"},{"location":"get-started/#interact-with-the-map","text":"Once data are added to the map, you can interact with data using vairous tools, such as the drawing tools, inspector tool, plotting tool. Check the video below on how to use the Inspector tool to query Earth Engine interactively.","title":"Interact with the map"},{"location":"installation/","text":"Installation Earth Engine Account To use geemap , you must first sign up for a Google Earth Engine account. You cannot use Google Earth Engine unless your application has been approved. Once you receive the application approval email, you can log in to the Earth Engine Code Editor to get familiar with the JavaScript API. Install from PyPI geemap is available on PyPI . To install geemap , run this command in your terminal: pip install geemap Install from conda-forge geemap is also available on conda-forge . If you have Anaconda or Miniconda installed on your computer, you can create a conda Python environment to install geemap: conda create -n gee python conda activate gee conda install mamba -c conda-forge mamba install geemap -c conda-forge Optionally, you can install some Jupyter notebook extensions , which can improve your productivity in the notebook environment. Some useful extensions include Table of Contents, Gist-it, Autopep8, Variable Inspector, etc. See this post for more information. conda install jupyter_contrib_nbextensions -c conda-forge Check the YouTube video below on how to install geemap using conda. Install from GitHub To install the development version from GitHub using Git , run the following command in your terminal: pip install git+https://github.com/giswqs/geemap Upgrade geemap If you have installed geemap before and want to upgrade to the latest version, you can run the following command in your terminal: pip install -U geemap If you use conda, you can update geemap to the latest version by running the following command in your terminal: mamba update -c conda-forge geemap To install the development version from GitHub directly within Jupyter notebook without using Git, run the following code: import geemap geemap.update_package() Use Docker To use geemap in a Docker container, check out this page .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#earth-engine-account","text":"To use geemap , you must first sign up for a Google Earth Engine account. You cannot use Google Earth Engine unless your application has been approved. Once you receive the application approval email, you can log in to the Earth Engine Code Editor to get familiar with the JavaScript API.","title":"Earth Engine Account"},{"location":"installation/#install-from-pypi","text":"geemap is available on PyPI . To install geemap , run this command in your terminal: pip install geemap","title":"Install from PyPI"},{"location":"installation/#install-from-conda-forge","text":"geemap is also available on conda-forge . If you have Anaconda or Miniconda installed on your computer, you can create a conda Python environment to install geemap: conda create -n gee python conda activate gee conda install mamba -c conda-forge mamba install geemap -c conda-forge Optionally, you can install some Jupyter notebook extensions , which can improve your productivity in the notebook environment. Some useful extensions include Table of Contents, Gist-it, Autopep8, Variable Inspector, etc. See this post for more information. conda install jupyter_contrib_nbextensions -c conda-forge Check the YouTube video below on how to install geemap using conda.","title":"Install from conda-forge"},{"location":"installation/#install-from-github","text":"To install the development version from GitHub using Git , run the following command in your terminal: pip install git+https://github.com/giswqs/geemap","title":"Install from GitHub"},{"location":"installation/#upgrade-geemap","text":"If you have installed geemap before and want to upgrade to the latest version, you can run the following command in your terminal: pip install -U geemap If you use conda, you can update geemap to the latest version by running the following command in your terminal: mamba update -c conda-forge geemap To install the development version from GitHub directly within Jupyter notebook without using Git, run the following code: import geemap geemap.update_package()","title":"Upgrade geemap"},{"location":"installation/#use-docker","text":"To use geemap in a Docker container, check out this page .","title":"Use Docker"},{"location":"legends/","text":"legends module Module of sample legends for some commonly used geospatial datasets. ee_table_to_legend ( in_table , out_file ) Converts an Earth Engine color table to a dictionary Parameters: Name Type Description Default in_table str The input file path (*.txt) to the Earth Engine color table. required out_file str The output file path (*.txt) to the legend dictionary. required Source code in geemap/legends.py def ee_table_to_legend ( in_table , out_file ): \"\"\"Converts an Earth Engine color table to a dictionary Args: in_table (str): The input file path (*.txt) to the Earth Engine color table. out_file (str): The output file path (*.txt) to the legend dictionary. \"\"\" pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) ee_legend_table = os . path . join ( pkg_dir , 'data/template/ee_legend_table.txt' ) if not os . path . exists ( in_table ): print ( 'The class table does not exist.' ) out_file = os . path . abspath ( out_file ) if not os . path . exists ( os . path . dirname ( out_file )): os . makedirs ( os . path . dirname ( out_file )) legend_dict = {} with open ( in_table ) as f : lines = f . readlines () for index , line in enumerate ( lines ): if index > 0 : items = line . split ( \" \\t \" ) items = [ item . strip () for item in items ] color = items [ 1 ] key = items [ 0 ] + \" \" + items [ 2 ] legend_dict [ key ] = color out_lines = [] out_lines . append ( '{ \\n ' ) for key in legend_dict . keys (): line = \" \\t ' {} ': ' {} ', \\n \" . format ( key , legend_dict [ key ]) out_lines . append ( line ) out_lines [ - 1 ] = out_lines [ - 1 ] . rstrip ()[: - 1 ] + ' \\n ' out_lines . append ( '} \\n ' ) with open ( out_file , 'w' ) as f : f . writelines ( out_lines )","title":"legends module"},{"location":"legends/#legends-module","text":"","title":"legends module"},{"location":"legends/#geemap.legends","text":"Module of sample legends for some commonly used geospatial datasets.","title":"geemap.legends"},{"location":"legends/#geemap.legends.ee_table_to_legend","text":"Converts an Earth Engine color table to a dictionary Parameters: Name Type Description Default in_table str The input file path (*.txt) to the Earth Engine color table. required out_file str The output file path (*.txt) to the legend dictionary. required Source code in geemap/legends.py def ee_table_to_legend ( in_table , out_file ): \"\"\"Converts an Earth Engine color table to a dictionary Args: in_table (str): The input file path (*.txt) to the Earth Engine color table. out_file (str): The output file path (*.txt) to the legend dictionary. \"\"\" pkg_dir = os . path . dirname ( pkg_resources . resource_filename ( \"geemap\" , \"geemap.py\" )) ee_legend_table = os . path . join ( pkg_dir , 'data/template/ee_legend_table.txt' ) if not os . path . exists ( in_table ): print ( 'The class table does not exist.' ) out_file = os . path . abspath ( out_file ) if not os . path . exists ( os . path . dirname ( out_file )): os . makedirs ( os . path . dirname ( out_file )) legend_dict = {} with open ( in_table ) as f : lines = f . readlines () for index , line in enumerate ( lines ): if index > 0 : items = line . split ( \" \\t \" ) items = [ item . strip () for item in items ] color = items [ 1 ] key = items [ 0 ] + \" \" + items [ 2 ] legend_dict [ key ] = color out_lines = [] out_lines . append ( '{ \\n ' ) for key in legend_dict . keys (): line = \" \\t ' {} ': ' {} ', \\n \" . format ( key , legend_dict [ key ]) out_lines . append ( line ) out_lines [ - 1 ] = out_lines [ - 1 ] . rstrip ()[: - 1 ] + ' \\n ' out_lines . append ( '} \\n ' ) with open ( out_file , 'w' ) as f : f . writelines ( out_lines )","title":"ee_table_to_legend()"},{"location":"ml/","text":"ml module export_trees_to_fc ( trees , asset_id , description = 'geemap_rf_export' ) Function that creates a feature collection with a property tree which contains the string representation of decision trees and exports to ee asset for later use Parameters: Name Type Description Default trees list[str] list of string representation of the decision trees required asset_id str ee asset id path to export the feature collection to required !!! kwargs description (str): optional description to provide export information. default = \"geemap_rf_export\" Source code in geemap/ml.py def export_trees_to_fc ( trees , asset_id , description = \"geemap_rf_export\" ): \"\"\"Function that creates a feature collection with a property tree which contains the string representation of decision trees and exports to ee asset for later use args: trees (list[str]): list of string representation of the decision trees asset_id (str): ee asset id path to export the feature collection to kwargs: description (str): optional description to provide export information. default = \"geemap_rf_export\" \"\"\" # create a null geometry point. This is needed to properly export the feature collection null_island = ee . Geometry . Point ([ 0 , 0 ]) # create a list of feature over null island # set the tree property as the tree string # encode return values (\\n) as #, use to parse later features = [ ee . Feature ( null_island ,{ \"tree\" : tree . replace ( \" \\n \" , \"#\" )}) for tree in trees ] # cast as feature collection fc = ee . FeatureCollection ( features ) # get export task and start task = ee . batch . Export . table . toAsset ( collection = fc , description = description , assetId = asset_id ) task . start () fc_to_classifier ( fc ) Function that takes a feature collection resulting from export_trees_to_fc and creates a ee.Classifier that can be used with ee objects Parameters: Name Type Description Default fc ee.FeatureCollection feature collection that has trees property for each feature that represents the decision tree required Returns: Type Description classifier (ee.Classifier) ee classifier object representing an ensemble decision tree Source code in geemap/ml.py def fc_to_classifier ( fc ): \"\"\"Function that takes a feature collection resulting from `export_trees_to_fc` and creates a ee.Classifier that can be used with ee objects args: fc (ee.FeatureCollection): feature collection that has trees property for each feature that represents the decision tree returns: classifier (ee.Classifier): ee classifier object representing an ensemble decision tree \"\"\" # get a list of tree strings from feature collection tree_strings = fc . aggregate_array ( \"tree\" ) . map ( lambda x : ee . String ( x ) . replace ( \"#\" , \" \\n \" , \"g\" ) # expects that # is ecoded to be a return ) # pass list of ee.Strings to an ensemble decision tree classifier (i.e. RandomForest) classifier = ee . Classifier . decisionTreeEnsemble ( tree_strings ) return classifier rf_to_strings ( estimator , feature_names , processes = 2 ) Function to convert a ensemble of decision trees into a list of strings. Wraps tree_to_string Parameters: Name Type Description Default estimator sklearn.ensemble.estimator A decision tree classifier or regressor object created using sklearn required feature_names list[str] List of strings that define the name of features (i.e. bands) used to create the model required !!! kwargs processess (int): number of cpu processes to spawn. Increasing processes will improve speed for large models. default = 2 Returns: Type Description trees (list[str]) list of strings where each string represents a decision tree estimator and collectively represent an ensemble decision tree estimator (i.e. RandomForest) Source code in geemap/ml.py def rf_to_strings ( estimator , feature_names , processes = 2 ): \"\"\"Function to convert a ensemble of decision trees into a list of strings. Wraps `tree_to_string` args: estimator (sklearn.ensemble.estimator): A decision tree classifier or regressor object created using sklearn feature_names (list[str]): List of strings that define the name of features (i.e. bands) used to create the model kwargs: processess (int): number of cpu processes to spawn. Increasing processes will improve speed for large models. default = 2 returns: trees (list[str]): list of strings where each string represents a decision tree estimator and collectively represent an ensemble decision tree estimator (i.e. RandomForest) \"\"\" # extract out the estimator trees estimators = estimator . estimators_ # check that number of processors set to use is not more than available if processes >= mp . cpu_count (): # if so, force to use only cpu count - 1 processes = mp . cpu_count () - 1 # run the tree extraction process in parallel with mp . Pool ( processes ) as pool : proc = pool . map_async ( partial ( tree_to_string , feature_names = feature_names ), estimators ) trees = list ( proc . get ()) return trees strings_to_classifier ( trees ) Function that takes string representation of decision trees and creates a ee.Classifier that can be used with ee objects Parameters: Name Type Description Default trees list[str] list of string representation of the decision trees required Returns: Type Description classifier (ee.Classifier) ee classifier object representing an ensemble decision tree Source code in geemap/ml.py def strings_to_classifier ( trees ): \"\"\"Function that takes string representation of decision trees and creates a ee.Classifier that can be used with ee objects args: trees (list[str]): list of string representation of the decision trees returns: classifier (ee.Classifier): ee classifier object representing an ensemble decision tree \"\"\" # convert strings to ee.String objects ee_strings = [ ee . String ( tree ) for tree in trees ] # pass list of ee.Strings to an ensemble decision tree classifier (i.e. RandomForest) classifier = ee . Classifier . decisionTreeEnsemble ( ee_strings ) return classifier tree_to_string ( estimator , feature_names ) Function to convert a sklearn decision tree object to a string format that EE can interpret Parameters: Name Type Description Default estimator sklearn.tree.estimator An estimator consisting of multiple decision tree classifiers. Expects object to contain estimators_ attribute required feature_names list[str] List of strings that define the name of features (i.e. bands) used to create the model required Returns: Type Description tree_str (str) string representation of decision tree estimator Exceptions: Type Description RuntimeError raises run time error when function cannot determine if the estimator is for regression or classification problem Source code in geemap/ml.py def tree_to_string ( estimator , feature_names ): \"\"\"Function to convert a sklearn decision tree object to a string format that EE can interpret args: estimator (sklearn.tree.estimator): An estimator consisting of multiple decision tree classifiers. Expects object to contain estimators_ attribute feature_names (list[str]): List of strings that define the name of features (i.e. bands) used to create the model returns: tree_str (str): string representation of decision tree estimator raises: RuntimeError: raises run time error when function cannot determine if the estimator is for regression or classification problem \"\"\" # extract out the information need to build the tree string n_nodes = estimator . tree_ . node_count children_left = estimator . tree_ . children_left children_right = estimator . tree_ . children_right feature_idx = estimator . tree_ . feature impurities = estimator . tree_ . impurity n_samples = estimator . tree_ . n_node_samples thresholds = estimator . tree_ . threshold features = [ feature_names [ i ] for i in feature_idx ] raw_vals = estimator . tree_ . value if raw_vals . ndim == 3 : # take argmax along class axis from values values = np . squeeze ( raw_vals . argmax ( axis =- 1 )) elif raw_vals . ndim == 2 : # take values and drop un needed axis values = np . squeeze ( raw_vals ) else : raise RuntimeError ( \"could not understand estimator type and parse out the values\" ) # use iterative pre-order search to extract node depth and leaf information node_ids = np . zeros ( shape = n_nodes , dtype = np . int64 ) node_depth = np . zeros ( shape = n_nodes , dtype = np . int64 ) is_leaves = np . zeros ( shape = n_nodes , dtype = bool ) stack = [( 0 , - 1 )] # seed is the root node id and its parent depth while len ( stack ) > 0 : node_id , parent_depth = stack . pop () node_depth [ node_id ] = parent_depth + 1 node_ids [ node_id ] = node_id # If we have a test node if children_left [ node_id ] != children_right [ node_id ]: stack . append (( children_left [ node_id ], parent_depth + 1 )) stack . append (( children_right [ node_id ], parent_depth + 1 )) else : is_leaves [ node_id ] = True # create a table of the initial structure # each row is a node or leaf df = pd . DataFrame ( { \"node_id\" : node_ids , \"node_depth\" : node_depth , \"is_leaf\" : is_leaves , \"children_left\" : children_left , \"children_right\" : children_right , \"value\" : values , \"criterion\" : impurities , \"n_samples\" : n_samples , \"threshold\" : thresholds , \"feature_name\" : features , \"sign\" : [ \"<=\" ] * n_nodes , } ) # the table representation does not have lef vs right node structure # so we need to add in right nodes in the correct location # we do this by first calculating which nodes are right and then insert them at the correct index # get a dict of right node rows and assign key based on index where to insert inserts = {} for row in df . itertuples (): child_r = row . children_right if child_r > row . Index : ordered_row = np . array ( row ) ordered_row [ - 1 ] = \">\" inserts [ child_r ] = ordered_row [ 1 :] # drop index value # sort the inserts as to keep track of the additive indexing inserts_sorted = { k : inserts [ k ] for k in sorted ( inserts . keys ())} # loop through the row inserts and add to table (array) table_values = df . values for i , k in enumerate ( inserts_sorted . keys ()): table_values = np . insert ( table_values , ( k + i ), inserts_sorted [ k ], axis = 0 ) # make the ordered table array into a dataframe # note: df is dtype \"object\", need to cast later on ordered_df = pd . DataFrame ( table_values , columns = df . columns ) max_depth = np . max ( ordered_df . node_depth . astype ( int )) tree_str = f \"1) root { n_samples [ 0 ] } 9999 9999 ( { impurities . sum () } ) \\n \" previous_depth = - 1 cnts = [] # loop through the nodes and calculate the node number and values per node for row in ordered_df . itertuples (): node_depth = int ( row . node_depth ) left = int ( row . children_left ) right = int ( row . children_right ) if left != right : if row . Index == 0 : cnt = 2 elif previous_depth > node_depth : depths = ordered_df . node_depth . values [: row . Index ] idx = np . where ( depths == node_depth )[ 0 ][ - 1 ] # cnt = (cnts[row.Index-1] // 2) + 1 cnt = cnts [ idx ] + 1 elif previous_depth < node_depth : cnt = cnts [ row . Index - 1 ] * 2 elif previous_depth == node_depth : cnt = cnts [ row . Index - 1 ] + 1 if node_depth == ( max_depth - 1 ): value = float ( ordered_df . iloc [ row . Index + 1 ] . value ) samps = int ( ordered_df . iloc [ row . Index + 1 ] . n_samples ) criterion = float ( ordered_df . iloc [ row . Index + 1 ] . criterion ) tail = \" * \\n \" else : if ( ( bool ( ordered_df . loc [ ordered_df . node_id == left ] . iloc [ 0 ] . is_leaf )) and ( bool ( int ( row . Index ) < int ( ordered_df . loc [ ordered_df . node_id == left ] . index [ 0 ]) ) ) and ( str ( row . sign ) == \"<=\" ) ): rowx = ordered_df . loc [ ordered_df . node_id == left ] . iloc [ 0 ] tail = \" * \\n \" value = float ( rowx . value ) samps = int ( rowx . n_samples ) criterion = float ( rowx . criterion ) elif ( ( bool ( ordered_df . loc [ ordered_df . node_id == right ] . iloc [ 0 ] . is_leaf )) and ( bool ( int ( row . Index ) < int ( ordered_df . loc [ ordered_df . node_id == right ] . index [ 0 ]) ) ) and ( str ( row . sign ) == \">\" ) ): rowx = ordered_df . loc [ ordered_df . node_id == right ] . iloc [ 0 ] tail = \" * \\n \" value = float ( rowx . value ) samps = int ( rowx . n_samples ) criterion = float ( rowx . criterion ) else : value = float ( row . value ) samps = int ( row . n_samples ) criterion = float ( row . criterion ) tail = \" \\n \" # extract out the information needed in each line spacing = ( node_depth + 1 ) * \" \" # for pretty printing fname = str ( row . feature_name ) # name of the feature (i.e. band name) tresh = float ( row . threshold ) # threshold sign = str ( row . sign ) tree_str += f \" { spacing }{ cnt } ) { fname } { sign } { tresh : .6f } { samps } { criterion : .4f } { value : .6f }{ tail } \" previous_depth = node_depth cnts . append ( cnt ) return tree_str","title":"ml module"},{"location":"ml/#ml-module","text":"","title":"ml module"},{"location":"ml/#geemap.ml","text":"","title":"geemap.ml"},{"location":"ml/#geemap.ml.export_trees_to_fc","text":"Function that creates a feature collection with a property tree which contains the string representation of decision trees and exports to ee asset for later use Parameters: Name Type Description Default trees list[str] list of string representation of the decision trees required asset_id str ee asset id path to export the feature collection to required !!! kwargs description (str): optional description to provide export information. default = \"geemap_rf_export\" Source code in geemap/ml.py def export_trees_to_fc ( trees , asset_id , description = \"geemap_rf_export\" ): \"\"\"Function that creates a feature collection with a property tree which contains the string representation of decision trees and exports to ee asset for later use args: trees (list[str]): list of string representation of the decision trees asset_id (str): ee asset id path to export the feature collection to kwargs: description (str): optional description to provide export information. default = \"geemap_rf_export\" \"\"\" # create a null geometry point. This is needed to properly export the feature collection null_island = ee . Geometry . Point ([ 0 , 0 ]) # create a list of feature over null island # set the tree property as the tree string # encode return values (\\n) as #, use to parse later features = [ ee . Feature ( null_island ,{ \"tree\" : tree . replace ( \" \\n \" , \"#\" )}) for tree in trees ] # cast as feature collection fc = ee . FeatureCollection ( features ) # get export task and start task = ee . batch . Export . table . toAsset ( collection = fc , description = description , assetId = asset_id ) task . start ()","title":"export_trees_to_fc()"},{"location":"ml/#geemap.ml.fc_to_classifier","text":"Function that takes a feature collection resulting from export_trees_to_fc and creates a ee.Classifier that can be used with ee objects Parameters: Name Type Description Default fc ee.FeatureCollection feature collection that has trees property for each feature that represents the decision tree required Returns: Type Description classifier (ee.Classifier) ee classifier object representing an ensemble decision tree Source code in geemap/ml.py def fc_to_classifier ( fc ): \"\"\"Function that takes a feature collection resulting from `export_trees_to_fc` and creates a ee.Classifier that can be used with ee objects args: fc (ee.FeatureCollection): feature collection that has trees property for each feature that represents the decision tree returns: classifier (ee.Classifier): ee classifier object representing an ensemble decision tree \"\"\" # get a list of tree strings from feature collection tree_strings = fc . aggregate_array ( \"tree\" ) . map ( lambda x : ee . String ( x ) . replace ( \"#\" , \" \\n \" , \"g\" ) # expects that # is ecoded to be a return ) # pass list of ee.Strings to an ensemble decision tree classifier (i.e. RandomForest) classifier = ee . Classifier . decisionTreeEnsemble ( tree_strings ) return classifier","title":"fc_to_classifier()"},{"location":"ml/#geemap.ml.rf_to_strings","text":"Function to convert a ensemble of decision trees into a list of strings. Wraps tree_to_string Parameters: Name Type Description Default estimator sklearn.ensemble.estimator A decision tree classifier or regressor object created using sklearn required feature_names list[str] List of strings that define the name of features (i.e. bands) used to create the model required !!! kwargs processess (int): number of cpu processes to spawn. Increasing processes will improve speed for large models. default = 2 Returns: Type Description trees (list[str]) list of strings where each string represents a decision tree estimator and collectively represent an ensemble decision tree estimator (i.e. RandomForest) Source code in geemap/ml.py def rf_to_strings ( estimator , feature_names , processes = 2 ): \"\"\"Function to convert a ensemble of decision trees into a list of strings. Wraps `tree_to_string` args: estimator (sklearn.ensemble.estimator): A decision tree classifier or regressor object created using sklearn feature_names (list[str]): List of strings that define the name of features (i.e. bands) used to create the model kwargs: processess (int): number of cpu processes to spawn. Increasing processes will improve speed for large models. default = 2 returns: trees (list[str]): list of strings where each string represents a decision tree estimator and collectively represent an ensemble decision tree estimator (i.e. RandomForest) \"\"\" # extract out the estimator trees estimators = estimator . estimators_ # check that number of processors set to use is not more than available if processes >= mp . cpu_count (): # if so, force to use only cpu count - 1 processes = mp . cpu_count () - 1 # run the tree extraction process in parallel with mp . Pool ( processes ) as pool : proc = pool . map_async ( partial ( tree_to_string , feature_names = feature_names ), estimators ) trees = list ( proc . get ()) return trees","title":"rf_to_strings()"},{"location":"ml/#geemap.ml.strings_to_classifier","text":"Function that takes string representation of decision trees and creates a ee.Classifier that can be used with ee objects Parameters: Name Type Description Default trees list[str] list of string representation of the decision trees required Returns: Type Description classifier (ee.Classifier) ee classifier object representing an ensemble decision tree Source code in geemap/ml.py def strings_to_classifier ( trees ): \"\"\"Function that takes string representation of decision trees and creates a ee.Classifier that can be used with ee objects args: trees (list[str]): list of string representation of the decision trees returns: classifier (ee.Classifier): ee classifier object representing an ensemble decision tree \"\"\" # convert strings to ee.String objects ee_strings = [ ee . String ( tree ) for tree in trees ] # pass list of ee.Strings to an ensemble decision tree classifier (i.e. RandomForest) classifier = ee . Classifier . decisionTreeEnsemble ( ee_strings ) return classifier","title":"strings_to_classifier()"},{"location":"ml/#geemap.ml.tree_to_string","text":"Function to convert a sklearn decision tree object to a string format that EE can interpret Parameters: Name Type Description Default estimator sklearn.tree.estimator An estimator consisting of multiple decision tree classifiers. Expects object to contain estimators_ attribute required feature_names list[str] List of strings that define the name of features (i.e. bands) used to create the model required Returns: Type Description tree_str (str) string representation of decision tree estimator Exceptions: Type Description RuntimeError raises run time error when function cannot determine if the estimator is for regression or classification problem Source code in geemap/ml.py def tree_to_string ( estimator , feature_names ): \"\"\"Function to convert a sklearn decision tree object to a string format that EE can interpret args: estimator (sklearn.tree.estimator): An estimator consisting of multiple decision tree classifiers. Expects object to contain estimators_ attribute feature_names (list[str]): List of strings that define the name of features (i.e. bands) used to create the model returns: tree_str (str): string representation of decision tree estimator raises: RuntimeError: raises run time error when function cannot determine if the estimator is for regression or classification problem \"\"\" # extract out the information need to build the tree string n_nodes = estimator . tree_ . node_count children_left = estimator . tree_ . children_left children_right = estimator . tree_ . children_right feature_idx = estimator . tree_ . feature impurities = estimator . tree_ . impurity n_samples = estimator . tree_ . n_node_samples thresholds = estimator . tree_ . threshold features = [ feature_names [ i ] for i in feature_idx ] raw_vals = estimator . tree_ . value if raw_vals . ndim == 3 : # take argmax along class axis from values values = np . squeeze ( raw_vals . argmax ( axis =- 1 )) elif raw_vals . ndim == 2 : # take values and drop un needed axis values = np . squeeze ( raw_vals ) else : raise RuntimeError ( \"could not understand estimator type and parse out the values\" ) # use iterative pre-order search to extract node depth and leaf information node_ids = np . zeros ( shape = n_nodes , dtype = np . int64 ) node_depth = np . zeros ( shape = n_nodes , dtype = np . int64 ) is_leaves = np . zeros ( shape = n_nodes , dtype = bool ) stack = [( 0 , - 1 )] # seed is the root node id and its parent depth while len ( stack ) > 0 : node_id , parent_depth = stack . pop () node_depth [ node_id ] = parent_depth + 1 node_ids [ node_id ] = node_id # If we have a test node if children_left [ node_id ] != children_right [ node_id ]: stack . append (( children_left [ node_id ], parent_depth + 1 )) stack . append (( children_right [ node_id ], parent_depth + 1 )) else : is_leaves [ node_id ] = True # create a table of the initial structure # each row is a node or leaf df = pd . DataFrame ( { \"node_id\" : node_ids , \"node_depth\" : node_depth , \"is_leaf\" : is_leaves , \"children_left\" : children_left , \"children_right\" : children_right , \"value\" : values , \"criterion\" : impurities , \"n_samples\" : n_samples , \"threshold\" : thresholds , \"feature_name\" : features , \"sign\" : [ \"<=\" ] * n_nodes , } ) # the table representation does not have lef vs right node structure # so we need to add in right nodes in the correct location # we do this by first calculating which nodes are right and then insert them at the correct index # get a dict of right node rows and assign key based on index where to insert inserts = {} for row in df . itertuples (): child_r = row . children_right if child_r > row . Index : ordered_row = np . array ( row ) ordered_row [ - 1 ] = \">\" inserts [ child_r ] = ordered_row [ 1 :] # drop index value # sort the inserts as to keep track of the additive indexing inserts_sorted = { k : inserts [ k ] for k in sorted ( inserts . keys ())} # loop through the row inserts and add to table (array) table_values = df . values for i , k in enumerate ( inserts_sorted . keys ()): table_values = np . insert ( table_values , ( k + i ), inserts_sorted [ k ], axis = 0 ) # make the ordered table array into a dataframe # note: df is dtype \"object\", need to cast later on ordered_df = pd . DataFrame ( table_values , columns = df . columns ) max_depth = np . max ( ordered_df . node_depth . astype ( int )) tree_str = f \"1) root { n_samples [ 0 ] } 9999 9999 ( { impurities . sum () } ) \\n \" previous_depth = - 1 cnts = [] # loop through the nodes and calculate the node number and values per node for row in ordered_df . itertuples (): node_depth = int ( row . node_depth ) left = int ( row . children_left ) right = int ( row . children_right ) if left != right : if row . Index == 0 : cnt = 2 elif previous_depth > node_depth : depths = ordered_df . node_depth . values [: row . Index ] idx = np . where ( depths == node_depth )[ 0 ][ - 1 ] # cnt = (cnts[row.Index-1] // 2) + 1 cnt = cnts [ idx ] + 1 elif previous_depth < node_depth : cnt = cnts [ row . Index - 1 ] * 2 elif previous_depth == node_depth : cnt = cnts [ row . Index - 1 ] + 1 if node_depth == ( max_depth - 1 ): value = float ( ordered_df . iloc [ row . Index + 1 ] . value ) samps = int ( ordered_df . iloc [ row . Index + 1 ] . n_samples ) criterion = float ( ordered_df . iloc [ row . Index + 1 ] . criterion ) tail = \" * \\n \" else : if ( ( bool ( ordered_df . loc [ ordered_df . node_id == left ] . iloc [ 0 ] . is_leaf )) and ( bool ( int ( row . Index ) < int ( ordered_df . loc [ ordered_df . node_id == left ] . index [ 0 ]) ) ) and ( str ( row . sign ) == \"<=\" ) ): rowx = ordered_df . loc [ ordered_df . node_id == left ] . iloc [ 0 ] tail = \" * \\n \" value = float ( rowx . value ) samps = int ( rowx . n_samples ) criterion = float ( rowx . criterion ) elif ( ( bool ( ordered_df . loc [ ordered_df . node_id == right ] . iloc [ 0 ] . is_leaf )) and ( bool ( int ( row . Index ) < int ( ordered_df . loc [ ordered_df . node_id == right ] . index [ 0 ]) ) ) and ( str ( row . sign ) == \">\" ) ): rowx = ordered_df . loc [ ordered_df . node_id == right ] . iloc [ 0 ] tail = \" * \\n \" value = float ( rowx . value ) samps = int ( rowx . n_samples ) criterion = float ( rowx . criterion ) else : value = float ( row . value ) samps = int ( row . n_samples ) criterion = float ( row . criterion ) tail = \" \\n \" # extract out the information needed in each line spacing = ( node_depth + 1 ) * \" \" # for pretty printing fname = str ( row . feature_name ) # name of the feature (i.e. band name) tresh = float ( row . threshold ) # threshold sign = str ( row . sign ) tree_str += f \" { spacing }{ cnt } ) { fname } { sign } { tresh : .6f } { samps } { criterion : .4f } { value : .6f }{ tail } \" previous_depth = node_depth cnts . append ( cnt ) return tree_str","title":"tree_to_string()"},{"location":"tutorials/","text":"Tutorials YouTube Channel More video tutorials for geemap and Earth Engine are available on my YouTube channel . If you can't access YouTube in your country, you can try \u897f\u74dc\u89c6\u9891 or \u54d4\u54e9\u54d4\u54e9 \u3002 geemap Tutorials Introducing the geemap Python package for interactive mapping with Google Earth Engine ( video | gif | notebook ) Using basemaps in geemap and ipyleaflet for interactive mapping with Google Earth Engine ( video | gif | notebook ) Introducing the Inspector tool for Earth Engine Python API ( video | gif | notebook ) Creating a split-panel map for visualizing Earth Engine data ( video | gif | notebook ) Using drawing tools to interact with Earth Engine data ( video | gif | notebook ) Creating an interactive map with a marker cluster ( video | gif | notebook ) Converting data formats between GeoJSON and Earth Engine ( video | gif | notebook ) Automated conversion from Earth Engine JavaScripts to Python scripts and Jupyter notebooks ( video | gif | notebook ) Interactive plotting of Earth Engine data with minimal coding ( video | gif | notebook ) Using shapefiles with Earth Engine without having to upload data to GEE ( video | gif | notebook ) Exporting Earth Engine Image and ImageCollection as GeoTIFF and Numpy array ( video | gif | notebook ) Computing zonal statistics with Earth Engine and exporting results as CSV or shapefile ( video | gif | notebook ) Calculating zonal statistics by group (e.g., analyzing land cover composition of each country/state) ( video | gif | notebook ) Adding a customized legend for Earth Engine data ( video | gif | notebook ) Converting Earth Engine JavaScripts to Python code directly within Jupyter notebook ( video | gif | notebook ) Adding animated text to GIF images generated from Earth Engine data ( video | gif | notebook ) Adding colorbar and images to GIF animations generated from Earth Engine data ( video | gif | notebook ) Creating Landsat timelapse animations with animated text using Earth Engine ( video | gif | notebook ) How to search and import datasets from Earth Engine Data Catalog ( video | gif | notebook ) Using timeseries inspector to visualize landscape changes over time ( video | gif | notebook ) Exporting Earth Engine maps as HTML files and PNG images ( video | gif | notebook ) How to import Earth Engine Python scripts into Jupyter notebook ( video | gif | notebook ) How to search Earth Engine API and import assets from GEE personal account ( video | gif | notebook ) How to publish interactive Earth Engine maps ( video | gif | notebook ) How to load local raster datasets with geemap ( video | gif | notebook ) How to create and deploy Earth Engine Apps using Python ( video | gif | notebook ) How to create an interactive Earth Engine App for creating Landsat timelapse ( video | gif | notebook ) How to use your local computer as a web server for hosting Earth Engine Apps ( video | gif | notebook ) How to use pydeck for rendering Earth Engine data ( video | gif | notebook ) How to get image basic properties and descriptive statistics ( video | gif | notebook ) Machine Learning with Earth Engine - Unsupervised Classification ( video | gif | notebook ) Machine Learning with Earth Engine - Supervised Classification ( video | gif | notebook ) Machine Learning with Earth Engine - Performing Accuracy Assessment for Image Classification ( video | gif | notebook ) Interactive extraction of pixel values and interactive region reduction ( video | gif | notebook ) How to use geemap and Earth Engine in Google Colab ( video | gif | notebook ) How to find out the greenest day of the year ( video | gif | notebook ) How to use Earth Engine with pydeck for 3D terrain visualization ( video | gif | notebook )","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"tutorials/#youtube-channel","text":"More video tutorials for geemap and Earth Engine are available on my YouTube channel . If you can't access YouTube in your country, you can try \u897f\u74dc\u89c6\u9891 or \u54d4\u54e9\u54d4\u54e9 \u3002","title":"YouTube Channel"},{"location":"tutorials/#geemap-tutorials","text":"Introducing the geemap Python package for interactive mapping with Google Earth Engine ( video | gif | notebook ) Using basemaps in geemap and ipyleaflet for interactive mapping with Google Earth Engine ( video | gif | notebook ) Introducing the Inspector tool for Earth Engine Python API ( video | gif | notebook ) Creating a split-panel map for visualizing Earth Engine data ( video | gif | notebook ) Using drawing tools to interact with Earth Engine data ( video | gif | notebook ) Creating an interactive map with a marker cluster ( video | gif | notebook ) Converting data formats between GeoJSON and Earth Engine ( video | gif | notebook ) Automated conversion from Earth Engine JavaScripts to Python scripts and Jupyter notebooks ( video | gif | notebook ) Interactive plotting of Earth Engine data with minimal coding ( video | gif | notebook ) Using shapefiles with Earth Engine without having to upload data to GEE ( video | gif | notebook ) Exporting Earth Engine Image and ImageCollection as GeoTIFF and Numpy array ( video | gif | notebook ) Computing zonal statistics with Earth Engine and exporting results as CSV or shapefile ( video | gif | notebook ) Calculating zonal statistics by group (e.g., analyzing land cover composition of each country/state) ( video | gif | notebook ) Adding a customized legend for Earth Engine data ( video | gif | notebook ) Converting Earth Engine JavaScripts to Python code directly within Jupyter notebook ( video | gif | notebook ) Adding animated text to GIF images generated from Earth Engine data ( video | gif | notebook ) Adding colorbar and images to GIF animations generated from Earth Engine data ( video | gif | notebook ) Creating Landsat timelapse animations with animated text using Earth Engine ( video | gif | notebook ) How to search and import datasets from Earth Engine Data Catalog ( video | gif | notebook ) Using timeseries inspector to visualize landscape changes over time ( video | gif | notebook ) Exporting Earth Engine maps as HTML files and PNG images ( video | gif | notebook ) How to import Earth Engine Python scripts into Jupyter notebook ( video | gif | notebook ) How to search Earth Engine API and import assets from GEE personal account ( video | gif | notebook ) How to publish interactive Earth Engine maps ( video | gif | notebook ) How to load local raster datasets with geemap ( video | gif | notebook ) How to create and deploy Earth Engine Apps using Python ( video | gif | notebook ) How to create an interactive Earth Engine App for creating Landsat timelapse ( video | gif | notebook ) How to use your local computer as a web server for hosting Earth Engine Apps ( video | gif | notebook ) How to use pydeck for rendering Earth Engine data ( video | gif | notebook ) How to get image basic properties and descriptive statistics ( video | gif | notebook ) Machine Learning with Earth Engine - Unsupervised Classification ( video | gif | notebook ) Machine Learning with Earth Engine - Supervised Classification ( video | gif | notebook ) Machine Learning with Earth Engine - Performing Accuracy Assessment for Image Classification ( video | gif | notebook ) Interactive extraction of pixel values and interactive region reduction ( video | gif | notebook ) How to use geemap and Earth Engine in Google Colab ( video | gif | notebook ) How to find out the greenest day of the year ( video | gif | notebook ) How to use Earth Engine with pydeck for 3D terrain visualization ( video | gif | notebook )","title":"geemap Tutorials"},{"location":"usage/","text":"Usage Below is a list of some commonly used functions available in the geemap Python package. Please check the API Reference for a complete list of all available functions. To create an ipyleaflet-based interactive map: import geemap Map = geemap.Map(center=[40,-100], zoom=4) Map To create a folium-based interactive map: import geemap.eefolium as geemap Map = geemap.Map(center=[40,-100], zoom=4) Map To add an Earth Engine data layer to the Map: Map.addLayer(ee_object, vis_params, name, shown, opacity) To center the map view at a given coordinates with the given zoom level: Map.setCenter(lon, lat, zoom) To center the map view around an Earth Engine object: Map.centerObject(ee_object, zoom) To add LayerControl to a folium-based Map: Map.addLayerControl() To add a minimap (overview) to an ipyleaflet-based Map: Map.add_minimap() To add additional basemaps to the Map: Map.add_basemap('Esri Ocean') Map.add_basemap('Esri National Geographic') To add an XYZ tile layer to the Map: url = 'https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}' Map.add_tile_layer(url, name='Google Map', attribution='Google') To add a WMS layer to the Map: naip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?' Map.add_wms_layer(url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True) To convert a shapefile to Earth Engine object and add it to the Map: ee_object = geemap.shp_to_ee(shp_file_path) Map.addLayer(ee_object, {}, 'Layer name') To convert a GeoJSON file to Earth Engine object and add it to the Map: ee_object = geemap.geojson_to_ee(geojson_file_path) Map.addLayer(ee_object, {}, 'Layer name') To download an ee.FeatureCollection as a shapefile: geemap.ee_to_csv(ee_object, filename, selectors) To export an ee.FeatureCollection to other formats, including shp, csv, json, kml, and kmz: geemap.ee_export_vector(ee_object, filename, selectors) To export an ee.Image as a GeoTIFF file: geemap.ee_export_image(ee_object, filename, scale, crs, region, file_per_band) To export an ee.ImageCollection as GeoTIFF files: geemap.ee_export_image_collection(ee_object, output, scale, crs, region, file_per_band) To extract pixels from an ee.Image into a 3D numpy array: geemap.ee_to_numpy(ee_object, bands, region, properties, default_value) To calculate zonal statistics: geemap.zonal_statistics(in_value_raster, in_zone_vector, out_file_path, statistics_type='MEAN') To calculate zonal statistics by group: geemap.zonal_statistics_by_group(in_value_raster, in_zone_vector, out_file_path, statistics_type='SUM') To create a split-panel Map: Map.split_map(left_layer='HYBRID', right_layer='ESRI') To add a marker cluster to the Map: Map.marker_cluster() feature_collection = ee.FeatureCollection(Map.ee_markers) To add a customized legend to the Map: legend_dict = { 'one': (0, 0, 0), 'two': (255,255,0), 'three': (127, 0, 127) } Map.add_legend(legend_title='Legend', legend_dict=legend_dict, position='bottomright') Map.add_legend(builtin_legend='NLCD') To download a GIF from an Earth Engine ImageCollection: geemap.download_ee_video(tempCol, videoArgs, saved_gif) To add animated text to an existing GIF image: geemap.add_text_to_gif(in_gif, out_gif, xy=('5%', '5%'), text_sequence=1984, font_size=30, font_color='#0000ff', duration=100) To create a colorbar for an Earth Engine image: palette = ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'] create_colorbar(width=250, height=30, palette=palette, vertical=False,add_labels=True, font_size=20, labels=[-40, 35]) To create a Landsat timelapse animation and add it to the Map: Map.add_landsat_ts_gif(label='Place name', start_year=1985, bands=['NIR', 'Red', 'Green'], frames_per_second=5) To convert all GEE JavaScripts in a folder recursively to Python scripts: from geemap.conversion import * js_to_python_dir(in_dir, out_dir) To convert all GEE Python scripts in a folder recursively to Jupyter notebooks: from geemap.conversion import * template_file = get_nb_template() py_to_ipynb_dir(in_dir, template_file, out_dir) To execute all Jupyter notebooks in a folder recursively and save output cells: from geemap.conversion import * execute_notebook_dir(in_dir) To search Earth Engine API documentation with Jupyter notebooks: import geemap geemap.ee_search() To publish an interactive GEE map with Jupyter notebooks: Map.publish(name, headline, visibility) To add a local raster dataset to the map: Map.add_raster(image, bands, colormap, layer_name) To get image basic properties: geemap.image_props(image).getInfo() To get image descriptive statistics: geemap.image_stats(image, region, scale) To remove all user-drawn geometries: geemap.remove_drawn_features() To extract pixel values based on user-drawn geometries: geemap.extract_values_to_points(out_shp)","title":"Usage"},{"location":"usage/#usage","text":"Below is a list of some commonly used functions available in the geemap Python package. Please check the API Reference for a complete list of all available functions. To create an ipyleaflet-based interactive map: import geemap Map = geemap.Map(center=[40,-100], zoom=4) Map To create a folium-based interactive map: import geemap.eefolium as geemap Map = geemap.Map(center=[40,-100], zoom=4) Map To add an Earth Engine data layer to the Map: Map.addLayer(ee_object, vis_params, name, shown, opacity) To center the map view at a given coordinates with the given zoom level: Map.setCenter(lon, lat, zoom) To center the map view around an Earth Engine object: Map.centerObject(ee_object, zoom) To add LayerControl to a folium-based Map: Map.addLayerControl() To add a minimap (overview) to an ipyleaflet-based Map: Map.add_minimap() To add additional basemaps to the Map: Map.add_basemap('Esri Ocean') Map.add_basemap('Esri National Geographic') To add an XYZ tile layer to the Map: url = 'https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}' Map.add_tile_layer(url, name='Google Map', attribution='Google') To add a WMS layer to the Map: naip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?' Map.add_wms_layer(url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True) To convert a shapefile to Earth Engine object and add it to the Map: ee_object = geemap.shp_to_ee(shp_file_path) Map.addLayer(ee_object, {}, 'Layer name') To convert a GeoJSON file to Earth Engine object and add it to the Map: ee_object = geemap.geojson_to_ee(geojson_file_path) Map.addLayer(ee_object, {}, 'Layer name') To download an ee.FeatureCollection as a shapefile: geemap.ee_to_csv(ee_object, filename, selectors) To export an ee.FeatureCollection to other formats, including shp, csv, json, kml, and kmz: geemap.ee_export_vector(ee_object, filename, selectors) To export an ee.Image as a GeoTIFF file: geemap.ee_export_image(ee_object, filename, scale, crs, region, file_per_band) To export an ee.ImageCollection as GeoTIFF files: geemap.ee_export_image_collection(ee_object, output, scale, crs, region, file_per_band) To extract pixels from an ee.Image into a 3D numpy array: geemap.ee_to_numpy(ee_object, bands, region, properties, default_value) To calculate zonal statistics: geemap.zonal_statistics(in_value_raster, in_zone_vector, out_file_path, statistics_type='MEAN') To calculate zonal statistics by group: geemap.zonal_statistics_by_group(in_value_raster, in_zone_vector, out_file_path, statistics_type='SUM') To create a split-panel Map: Map.split_map(left_layer='HYBRID', right_layer='ESRI') To add a marker cluster to the Map: Map.marker_cluster() feature_collection = ee.FeatureCollection(Map.ee_markers) To add a customized legend to the Map: legend_dict = { 'one': (0, 0, 0), 'two': (255,255,0), 'three': (127, 0, 127) } Map.add_legend(legend_title='Legend', legend_dict=legend_dict, position='bottomright') Map.add_legend(builtin_legend='NLCD') To download a GIF from an Earth Engine ImageCollection: geemap.download_ee_video(tempCol, videoArgs, saved_gif) To add animated text to an existing GIF image: geemap.add_text_to_gif(in_gif, out_gif, xy=('5%', '5%'), text_sequence=1984, font_size=30, font_color='#0000ff', duration=100) To create a colorbar for an Earth Engine image: palette = ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'] create_colorbar(width=250, height=30, palette=palette, vertical=False,add_labels=True, font_size=20, labels=[-40, 35]) To create a Landsat timelapse animation and add it to the Map: Map.add_landsat_ts_gif(label='Place name', start_year=1985, bands=['NIR', 'Red', 'Green'], frames_per_second=5) To convert all GEE JavaScripts in a folder recursively to Python scripts: from geemap.conversion import * js_to_python_dir(in_dir, out_dir) To convert all GEE Python scripts in a folder recursively to Jupyter notebooks: from geemap.conversion import * template_file = get_nb_template() py_to_ipynb_dir(in_dir, template_file, out_dir) To execute all Jupyter notebooks in a folder recursively and save output cells: from geemap.conversion import * execute_notebook_dir(in_dir) To search Earth Engine API documentation with Jupyter notebooks: import geemap geemap.ee_search() To publish an interactive GEE map with Jupyter notebooks: Map.publish(name, headline, visibility) To add a local raster dataset to the map: Map.add_raster(image, bands, colormap, layer_name) To get image basic properties: geemap.image_props(image).getInfo() To get image descriptive statistics: geemap.image_stats(image, region, scale) To remove all user-drawn geometries: geemap.remove_drawn_features() To extract pixel values based on user-drawn geometries: geemap.extract_values_to_points(out_shp)","title":"Usage"},{"location":"utils/","text":"utilities module Module of various Earth Engine utility functions. annual_NAIP ( year , region ) Create an NAIP mosaic of a specified year for a specified region. Parameters: Name Type Description Default year int The specified year to create the mosaic for. required region object ee.Geometry required Returns: Type Description object ee.Image Source code in geemap/utils.py def annual_NAIP ( year , region ): \"\"\"Create an NAIP mosaic of a specified year for a specified region. Args: year (int): The specified year to create the mosaic for. region (object): ee.Geometry Returns: object: ee.Image \"\"\" start_date = ee . Date . fromYMD ( year , 1 , 1 ) end_date = ee . Date . fromYMD ( year , 12 , 31 ) collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) \\ . filterDate ( start_date , end_date ) \\ . filterBounds ( region ) time_start = ee . Date ( ee . List ( collection . aggregate_array ( 'system:time_start' )) . sort () . get ( 0 )) time_end = ee . Date ( ee . List ( collection . aggregate_array ( 'system:time_end' )) . sort () . get ( - 1 )) image = ee . Image ( collection . mosaic () . clip ( region )) NDWI = ee . Image ( image ) . normalizedDifference ( [ 'G' , 'N' ]) . select ([ 'nd' ], [ 'ndwi' ]) NDVI = ee . Image ( image ) . normalizedDifference ( [ 'N' , 'R' ]) . select ([ 'nd' ], [ 'ndvi' ]) image = image . addBands ( NDWI ) image = image . addBands ( NDVI ) return image . set ({ 'system:time_start' : time_start , 'system:time_end' : time_end }) array_mean ( arr ) Calculates the mean of an array along the given axis. Parameters: Name Type Description Default arr object Array to calculate mean. required Returns: Type Description object ee.Number Source code in geemap/utils.py def array_mean ( arr ): \"\"\"Calculates the mean of an array along the given axis. Args: arr (object): Array to calculate mean. Returns: object: ee.Number \"\"\" total = ee . Array ( arr ) . accum ( 0 ) . get ([ - 1 ]) size = arr . length () return ee . Number ( total . divide ( size )) array_sum ( arr ) Accumulates elements of an array along the given axis. Parameters: Name Type Description Default arr object Array to accumulate. required Returns: Type Description object ee.Number Source code in geemap/utils.py def array_sum ( arr ): \"\"\"Accumulates elements of an array along the given axis. Args: arr (object): Array to accumulate. Returns: object: ee.Number \"\"\" return ee . Array ( arr ) . accum ( 0 ) . get ([ - 1 ]) bands_to_image_collection ( img ) Converts all bands in an image to an image collection. Parameters: Name Type Description Default img object The image to convert. required Returns: Type Description object ee.ImageCollection Source code in geemap/utils.py def bands_to_image_collection ( img ): \"\"\"Converts all bands in an image to an image collection. Args: img (object): The image to convert. Returns: object: ee.ImageCollection \"\"\" collection = ee . ImageCollection ( img . bandNames () . map ( lambda b : img . select ([ b ]))) return collection column_stats ( collection , column , stats_type ) Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean, sample standard deviation, sample variance, total standard deviation and total variance of the selected property. Parameters: Name Type Description Default collection FeatureCollection The input feature collection to calculate statistics. required column str The name of the column to calculate statistics. required stats_type str The type of statistics to calculate. required Returns: Type Description dict The dictionary containing information about the requested statistics. Source code in geemap/utils.py def column_stats ( collection , column , stats_type ): \"\"\"Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean, sample standard deviation, sample variance, total standard deviation and total variance of the selected property. Args: collection (FeatureCollection): The input feature collection to calculate statistics. column (str): The name of the column to calculate statistics. stats_type (str): The type of statistics to calculate. Returns: dict: The dictionary containing information about the requested statistics. \"\"\" stats_type = stats_type . lower () allowed_stats = [ 'min' , 'max' , 'mean' , 'median' , 'sum' , 'stdDev' , 'variance' ] if stats_type not in allowed_stats : print ( 'The stats type must be one of the following: {} ' . format ( ',' . join ( allowed_stats ))) return stats_dict = { 'min' : ee . Reducer . min (), 'max' : ee . Reducer . max (), 'mean' : ee . Reducer . mean (), 'median' : ee . Reducer . median (), 'sum' : ee . Reducer . sum (), 'stdDev' : ee . Reducer . stdDev (), 'variance' : ee . Reducer . variance () } selectors = [ column ] stats = collection . reduceColumns ( ** { 'selectors' : selectors , 'reducer' : stats_dict [ stats_type ] }) return stats dict_to_csv ( data_dict , out_csv , by_row = False ) Downloads an ee.Dictionary as a CSV file. Parameters: Name Type Description Default data_dict ee.Dictionary The input ee.Dictionary. required out_csv str The output file path to the CSV file. required by_row bool Whether to use by row or by column. Defaults to False. False Source code in geemap/utils.py def dict_to_csv ( data_dict , out_csv , by_row = False ): \"\"\"Downloads an ee.Dictionary as a CSV file. Args: data_dict (ee.Dictionary): The input ee.Dictionary. out_csv (str): The output file path to the CSV file. by_row (bool, optional): Whether to use by row or by column. Defaults to False. \"\"\" import geemap out_dir = os . path . dirname ( out_csv ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) if not by_row : csv_feature = ee . Feature ( None , data_dict ) csv_feat_col = ee . FeatureCollection ([ csv_feature ]) else : keys = data_dict . keys () data = keys . map ( lambda k : ee . Dictionary ({ 'name' : k , 'value' : data_dict . get ( k )})) csv_feature = data . map ( lambda f : ee . Feature ( None , f )) csv_feat_col = ee . FeatureCollection ( csv_feature ) geemap . ee_export_vector ( csv_feat_col , out_csv ) ee_initialize ( token_name = 'EARTHENGINE_TOKEN' ) Authenticates Earth Engine and initialize an Earth Engine session Source code in geemap/utils.py def ee_initialize ( token_name = 'EARTHENGINE_TOKEN' ): \"\"\"Authenticates Earth Engine and initialize an Earth Engine session \"\"\" try : ee_token = os . environ . get ( token_name ) if ee_token is not None : credential = '{\"refresh_token\":\" %s \"}' % ee_token credential_file_path = os . path . expanduser ( \"~/.config/earthengine/\" ) os . makedirs ( credential_file_path , exist_ok = True ) with open ( credential_file_path + 'credentials' , 'w' ) as file : file . write ( credential ) ee . Initialize () except : ee . Authenticate () ee . Initialize () ee_num_round ( num , decimal = 2 ) Rounds a number to a specified number of decimal places. Parameters: Name Type Description Default num ee.Number The number to round. required decimal int The number of decimal places to round. Defaults to 2. 2 Returns: Type Description ee.Number The number with the specified decimal places rounded. Source code in geemap/utils.py def ee_num_round ( num , decimal = 2 ): \"\"\"Rounds a number to a specified number of decimal places. Args: num (ee.Number): The number to round. decimal (int, optional): The number of decimal places to round. Defaults to 2. Returns: ee.Number: The number with the specified decimal places rounded. \"\"\" format_str = '%. {} f' . format ( decimal ) return ee . Number . parse ( ee . Number ( num ) . format ( format_str )) extract_values_to_points ( in_points , img , label , scale = None ) Extracts image values to points. Parameters: Name Type Description Default in_points object ee.FeatureCollection required img object ee.Image required label str The column name to keep. required scale float The image resolution to use. Defaults to None. None Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def extract_values_to_points ( in_points , img , label , scale = None ): \"\"\"Extracts image values to points. Args: in_points (object): ee.FeatureCollection img (object): ee.Image label (str): The column name to keep. scale (float, optional): The image resolution to use. Defaults to None. Returns: object: ee.FeatureCollection \"\"\" if scale is None : scale = image_scale ( img ) out_fc = img . sampleRegions ( ** { 'collection' : in_points , 'properties' : [ label ], 'scale' : scale }) return out_fc filter_HUC08 ( region ) Filters HUC08 watersheds intersecting a given region. Parameters: Name Type Description Default region object ee.Geometry required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def filter_HUC08 ( region ): \"\"\"Filters HUC08 watersheds intersecting a given region. Args: region (object): ee.Geometry Returns: object: ee.FeatureCollection \"\"\" USGS_HUC08 = ee . FeatureCollection ( 'USGS/WBD/2017/HUC08' ) # Subbasins HUC08 = USGS_HUC08 . filterBounds ( region ) return HUC08 filter_HUC10 ( region ) Filters HUC10 watersheds intersecting a given region. Parameters: Name Type Description Default region object ee.Geometry required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def filter_HUC10 ( region ): \"\"\"Filters HUC10 watersheds intersecting a given region. Args: region (object): ee.Geometry Returns: object: ee.FeatureCollection \"\"\" USGS_HUC10 = ee . FeatureCollection ( 'USGS/WBD/2017/HUC10' ) # Watersheds HUC10 = USGS_HUC10 . filterBounds ( region ) return HUC10 filter_NWI ( HUC08_Id , region , exclude_riverine = True ) Retrives NWI dataset for a given HUC8 watershed. Parameters: Name Type Description Default HUC08_Id str The HUC8 watershed id. required region object ee.Geometry required exclude_riverine bool Whether to exclude riverine wetlands. Defaults to True. True Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def filter_NWI ( HUC08_Id , region , exclude_riverine = True ): \"\"\"Retrives NWI dataset for a given HUC8 watershed. Args: HUC08_Id (str): The HUC8 watershed id. region (object): ee.Geometry exclude_riverine (bool, optional): Whether to exclude riverine wetlands. Defaults to True. Returns: object: ee.FeatureCollection \"\"\" nwi_asset_prefix = 'users/wqs/NWI-HU8/HU8_' nwi_asset_suffix = '_Wetlands' nwi_asset_path = nwi_asset_prefix + HUC08_Id + nwi_asset_suffix nwi_huc = ee . FeatureCollection ( nwi_asset_path ) . filterBounds ( region ) if exclude_riverine : nwi_huc = nwi_huc . filter ( ee . Filter . notEquals ( ** { 'leftField' : 'WETLAND_TY' , 'rightValue' : 'Riverine' })) return nwi_huc find_HUC08 ( HUC08_Id ) Finds a HUC08 watershed based on a given HUC08 ID Parameters: Name Type Description Default HUC08_Id str The HUC08 ID. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def find_HUC08 ( HUC08_Id ): \"\"\"Finds a HUC08 watershed based on a given HUC08 ID Args: HUC08_Id (str): The HUC08 ID. Returns: object: ee.FeatureCollection \"\"\" USGS_HUC08 = ee . FeatureCollection ( 'USGS/WBD/2017/HUC08' ) # Subbasins HUC08 = USGS_HUC08 . filter ( ee . Filter . eq ( 'huc8' , HUC08_Id )) return HUC08 find_HUC10 ( HUC10_Id ) Finds a HUC10 watershed based on a given HUC08 ID Parameters: Name Type Description Default HUC10_Id str The HUC10 ID. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def find_HUC10 ( HUC10_Id ): \"\"\"Finds a HUC10 watershed based on a given HUC08 ID Args: HUC10_Id (str): The HUC10 ID. Returns: object: ee.FeatureCollection \"\"\" USGS_HUC10 = ee . FeatureCollection ( 'USGS/WBD/2017/HUC10' ) # Watersheds HUC10 = USGS_HUC10 . filter ( ee . Filter . eq ( 'huc10' , HUC10_Id )) return HUC10 find_landsat_by_path_row ( landsat_col , path_num , row_num ) Finds Landsat images by WRS path number and row number. Parameters: Name Type Description Default landsat_col str The image collection id of Landsat. required path_num int The WRS path number. required row_num int the WRS row number. required Returns: Type Description object ee.ImageCollection Source code in geemap/utils.py def find_landsat_by_path_row ( landsat_col , path_num , row_num ): \"\"\"Finds Landsat images by WRS path number and row number. Args: landsat_col (str): The image collection id of Landsat. path_num (int): The WRS path number. row_num (int): the WRS row number. Returns: object: ee.ImageCollection \"\"\" try : if isinstance ( landsat_col , str ): landsat_col = ee . ImageCollection ( landsat_col ) collection = landsat_col . filter ( ee . Filter . eq ( 'WRS_PATH' , path_num )) \\ . filter ( ee . Filter . eq ( 'WRS_ROW' , row_num )) return collection except Exception as e : print ( e ) find_NAIP ( region , add_NDVI = True , add_NDWI = True ) Create annual NAIP mosaic for a given region. Parameters: Name Type Description Default region object ee.Geometry required add_NDVI bool Whether to add the NDVI band. Defaults to True. True add_NDWI bool Whether to add the NDWI band. Defaults to True. True Returns: Type Description object ee.ImageCollection Source code in geemap/utils.py def find_NAIP ( region , add_NDVI = True , add_NDWI = True ): \"\"\"Create annual NAIP mosaic for a given region. Args: region (object): ee.Geometry add_NDVI (bool, optional): Whether to add the NDVI band. Defaults to True. add_NDWI (bool, optional): Whether to add the NDWI band. Defaults to True. Returns: object: ee.ImageCollection \"\"\" init_collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) \\ . filterBounds ( region ) \\ . filterDate ( '2009-01-01' , '2019-12-31' ) \\ . filter ( ee . Filter . listContains ( \"system:band_names\" , \"N\" )) yearList = ee . List ( init_collection . distinct ( [ 'system:time_start' ]) . aggregate_array ( 'system:time_start' )) init_years = yearList . map ( lambda y : ee . Date ( y ) . get ( 'year' )) # remove duplicates init_years = ee . Dictionary ( init_years . reduce ( ee . Reducer . frequencyHistogram ())) . keys () years = init_years . map ( lambda x : ee . Number . parse ( x )) # years = init_years.map(lambda x: x) # Available NAIP years with NIR band def NAIPAnnual ( year ): start_date = ee . Date . fromYMD ( year , 1 , 1 ) end_date = ee . Date . fromYMD ( year , 12 , 31 ) collection = init_collection . filterDate ( start_date , end_date ) # .filterBounds(geometry) # .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) time_start = ee . Date ( ee . List ( collection . aggregate_array ( 'system:time_start' )) . sort () . get ( 0 )) . format ( 'YYYY-MM-dd' ) time_end = ee . Date ( ee . List ( collection . aggregate_array ( 'system:time_end' )) . sort () . get ( - 1 )) . format ( 'YYYY-MM-dd' ) col_size = collection . size () image = ee . Image ( collection . mosaic () . clip ( region )) if add_NDVI : NDVI = ee . Image ( image ) . normalizedDifference ( [ 'N' , 'R' ]) . select ([ 'nd' ], [ 'ndvi' ]) image = image . addBands ( NDVI ) if add_NDWI : NDWI = ee . Image ( image ) . normalizedDifference ( [ 'G' , 'N' ]) . select ([ 'nd' ], [ 'ndwi' ]) image = image . addBands ( NDWI ) return image . set ({ 'system:time_start' : time_start , 'system:time_end' : time_end , 'tiles' : col_size }) # remove years with incomplete coverage naip = ee . ImageCollection ( years . map ( NAIPAnnual )) mean_size = ee . Number ( naip . aggregate_mean ( 'tiles' )) total_sd = ee . Number ( naip . aggregate_total_sd ( 'tiles' )) threshold = mean_size . subtract ( total_sd . multiply ( 1 )) naip = naip . filter ( ee . Filter . Or ( ee . Filter . gte ( 'tiles' , threshold ), ee . Filter . gte ( 'tiles' , 15 ))) naip = naip . filter ( ee . Filter . gte ( 'tiles' , 7 )) naip_count = naip . size () naip_seq = ee . List . sequence ( 0 , naip_count . subtract ( 1 )) def set_index ( index ): img = ee . Image ( naip . toList ( naip_count ) . get ( index )) return img . set ({ 'system:uid' : ee . Number ( index ) . toUint8 ()}) naip = naip_seq . map ( set_index ) return ee . ImageCollection ( naip ) find_NWI ( HUC08_Id , exclude_riverine = True ) Finds NWI dataset for a given HUC08 watershed. Parameters: Name Type Description Default HUC08_Id str The HUC08 watershed ID. required exclude_riverine bool Whether to exclude riverine wetlands. Defaults to True. True Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def find_NWI ( HUC08_Id , exclude_riverine = True ): \"\"\"Finds NWI dataset for a given HUC08 watershed. Args: HUC08_Id (str): The HUC08 watershed ID. exclude_riverine (bool, optional): Whether to exclude riverine wetlands. Defaults to True. Returns: object: ee.FeatureCollection \"\"\" nwi_asset_prefix = 'users/wqs/NWI-HU8/HU8_' nwi_asset_suffix = '_Wetlands' nwi_asset_path = nwi_asset_prefix + HUC08_Id + nwi_asset_suffix nwi_huc = ee . FeatureCollection ( nwi_asset_path ) if exclude_riverine : nwi_huc = nwi_huc . filter ( ee . Filter . notEquals ( ** { 'leftField' : 'WETLAND_TY' , 'rightValue' : 'Riverine' })) return nwi_huc get_all_NAIP ( start_year = 2009 , end_year = 2019 ) Creates annual NAIP imagery mosaic. Parameters: Name Type Description Default start_year int The starting year. Defaults to 2009. 2009 end_year int The ending year. Defaults to 2019. 2019 Returns: Type Description object ee.ImageCollection Source code in geemap/utils.py def get_all_NAIP ( start_year = 2009 , end_year = 2019 ): \"\"\"Creates annual NAIP imagery mosaic. Args: start_year (int, optional): The starting year. Defaults to 2009. end_year (int, optional): The ending year. Defaults to 2019. Returns: object: ee.ImageCollection \"\"\" try : def get_annual_NAIP ( year ): try : collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) start_date = ee . Date . fromYMD ( year , 1 , 1 ) end_date = ee . Date . fromYMD ( year , 12 , 31 ) naip = collection . filterDate ( start_date , end_date ) \\ . filter ( ee . Filter . listContains ( \"system:band_names\" , \"N\" )) return ee . ImageCollection ( naip ) except Exception as e : print ( e ) years = ee . List . sequence ( start_year , end_year ) collection = years . map ( get_annual_NAIP ) return collection except Exception as e : print ( e ) get_annual_NAIP ( year , RGBN = True ) Filters NAIP ImageCollection by year. Parameters: Name Type Description Default year int The year to filter the NAIP ImageCollection. required RGBN bool Whether to retrieve 4-band NAIP imagery only. Defaults to True. True Returns: Type Description object ee.ImageCollection Source code in geemap/utils.py def get_annual_NAIP ( year , RGBN = True ): \"\"\"Filters NAIP ImageCollection by year. Args: year (int): The year to filter the NAIP ImageCollection. RGBN (bool, optional): Whether to retrieve 4-band NAIP imagery only. Defaults to True. Returns: object: ee.ImageCollection \"\"\" try : collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) start_date = str ( year ) + '-01-01' end_date = str ( year ) + '-12-31' naip = collection . filterDate ( start_date , end_date ) if RGBN : naip = naip . filter ( ee . Filter . listContains ( \"system:band_names\" , \"N\" )) return naip except Exception as e : print ( e ) image_area ( img , region = None , scale = None , denominator = 1.0 ) Calculates the the area of an image. Parameters: Name Type Description Default img object ee.Image required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None denominator float The denominator to use for converting size from square meters to other units. Defaults to 1.0. 1.0 Returns: Type Description object ee.Dictionary Source code in geemap/utils.py def image_area ( img , region = None , scale = None , denominator = 1.0 ): \"\"\"Calculates the the area of an image. Args: img (object): ee.Image region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. denominator (float, optional): The denominator to use for converting size from square meters to other units. Defaults to 1.0. Returns: object: ee.Dictionary \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) pixel_area = img . unmask () . neq ( ee . Image ( 0 )) . multiply ( ee . Image . pixelArea ()) . divide ( denominator ) img_area = pixel_area . reduceRegion ( ** { 'geometry' : region , 'reducer' : ee . Reducer . sum (), 'scale' : scale , 'maxPixels' : 1e12 }) return img_area image_band_names ( img ) Gets image band names. Parameters: Name Type Description Default img ee.Image The input image. required Returns: Type Description ee.List The returned list of image band names. Source code in geemap/utils.py def image_band_names ( img ): \"\"\"Gets image band names. Args: img (ee.Image): The input image. Returns: ee.List: The returned list of image band names. \"\"\" return img . bandNames () image_cell_size ( img ) Retrieves the image cell size (e.g., spatial resolution) Parameters: Name Type Description Default img object ee.Image required Returns: Type Description float The nominal scale in meters. Source code in geemap/utils.py def image_cell_size ( img ): \"\"\"Retrieves the image cell size (e.g., spatial resolution) Args: img (object): ee.Image Returns: float: The nominal scale in meters. \"\"\" bands = img . bandNames () scales = bands . map ( lambda b : img . select ([ b ]) . projection () . nominalScale ()) scale = ee . Algorithms . If ( scales . distinct () . size () . gt ( 1 ), ee . Dictionary . fromLists ( bands . getInfo (), scales ), scales . get ( 0 )) return scale image_date ( img , date_format = 'YYYY-MM-dd' ) Retrieves the image acquisition date. Parameters: Name Type Description Default img object ee.Image required date_format str The date format to use. Defaults to 'YYYY-MM-dd'. 'YYYY-MM-dd' Returns: Type Description str A string representing the acquisition of the image. Source code in geemap/utils.py def image_date ( img , date_format = 'YYYY-MM-dd' ): \"\"\"Retrieves the image acquisition date. Args: img (object): ee.Image date_format (str, optional): The date format to use. Defaults to 'YYYY-MM-dd'. Returns: str: A string representing the acquisition of the image. \"\"\" return ee . Date ( img . get ( 'system:time_start' )) . format ( date_format ) image_max_value ( img , region = None , scale = None ) Retrieves the maximum value of an image. Parameters: Name Type Description Default img object The image to calculate the maximum value. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description object ee.Number Source code in geemap/utils.py def image_max_value ( img , region = None , scale = None ): \"\"\"Retrieves the maximum value of an image. Args: img (object): The image to calculate the maximum value. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: object: ee.Number \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) max_value = img . reduceRegion ( ** { 'reducer' : ee . Reducer . max (), 'geometry' : region , 'scale' : scale , 'maxPixels' : 1e12 }) return max_value image_mean_value ( img , region = None , scale = None ) Retrieves the mean value of an image. Parameters: Name Type Description Default img object The image to calculate the mean value. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description object ee.Number Source code in geemap/utils.py def image_mean_value ( img , region = None , scale = None ): \"\"\"Retrieves the mean value of an image. Args: img (object): The image to calculate the mean value. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: object: ee.Number \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) mean_value = img . reduceRegion ( ** { 'reducer' : ee . Reducer . mean (), 'geometry' : region , 'scale' : scale , 'maxPixels' : 1e12 }) return mean_value image_min_value ( img , region = None , scale = None ) Retrieves the minimum value of an image. Parameters: Name Type Description Default img object The image to calculate the minimum value. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description object ee.Number Source code in geemap/utils.py def image_min_value ( img , region = None , scale = None ): \"\"\"Retrieves the minimum value of an image. Args: img (object): The image to calculate the minimum value. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: object: ee.Number \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) min_value = img . reduceRegion ( ** { 'reducer' : ee . Reducer . min (), 'geometry' : region , 'scale' : scale , 'maxPixels' : 1e12 }) return min_value image_reclassify ( img , in_list , out_list ) Reclassify an image. Parameters: Name Type Description Default img object The image to which the remapping is applied. required in_list list The source values (numbers or EEArrays). All values in this list will be mapped to the corresponding value in 'out_list'. required out_list list The destination values (numbers or EEArrays). These are used to replace the corresponding values in 'from'. Must have the same number of values as 'in_list'. required Returns: Type Description object ee.Image Source code in geemap/utils.py def image_reclassify ( img , in_list , out_list ): \"\"\"Reclassify an image. Args: img (object): The image to which the remapping is applied. in_list (list): The source values (numbers or EEArrays). All values in this list will be mapped to the corresponding value in 'out_list'. out_list (list): The destination values (numbers or EEArrays). These are used to replace the corresponding values in 'from'. Must have the same number of values as 'in_list'. Returns: object: ee.Image \"\"\" image = img . remap ( in_list , out_list ) return image image_scale ( img ) Retrieves the image cell size (e.g., spatial resolution) Parameters: Name Type Description Default img object ee.Image required Returns: Type Description float The nominal scale in meters. Source code in geemap/utils.py def image_scale ( img ): \"\"\"Retrieves the image cell size (e.g., spatial resolution) Args: img (object): ee.Image Returns: float: The nominal scale in meters. \"\"\" # bands = img.bandNames() # scales = bands.map(lambda b: img.select([b]).projection().nominalScale()) # scale = ee.Algorithms.If(scales.distinct().size().gt(1), ee.Dictionary.fromLists(bands.getInfo(), scales), scales.get(0)) return img . select ( 0 ) . projection () . nominalScale () image_smoothing ( img , reducer , kernel ) Smooths an image. Parameters: Name Type Description Default img object The image to be smoothed. required reducer object ee.Reducer required kernel object ee.Kernel required Returns: Type Description object ee.Image Source code in geemap/utils.py def image_smoothing ( img , reducer , kernel ): \"\"\"Smooths an image. Args: img (object): The image to be smoothed. reducer (object): ee.Reducer kernel (object): ee.Kernel Returns: object: ee.Image \"\"\" image = img . reduceNeighborhood ( ** { 'reducer' : reducer , 'kernel' : kernel , }) return image image_std_value ( img , region = None , scale = None ) Retrieves the standard deviation of an image. Parameters: Name Type Description Default img object The image to calculate the standard deviation. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description object ee.Number Source code in geemap/utils.py def image_std_value ( img , region = None , scale = None ): \"\"\"Retrieves the standard deviation of an image. Args: img (object): The image to calculate the standard deviation. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: object: ee.Number \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) std_value = img . reduceRegion ( ** { 'reducer' : ee . Reducer . stdDev (), 'geometry' : region , 'scale' : scale , 'maxPixels' : 1e12 }) return std_value image_sum_value ( img , region = None , scale = None ) Retrieves the sum of an image. Parameters: Name Type Description Default img object The image to calculate the standard deviation. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description object ee.Number Source code in geemap/utils.py def image_sum_value ( img , region = None , scale = None ): \"\"\"Retrieves the sum of an image. Args: img (object): The image to calculate the standard deviation. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: object: ee.Number \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) sum_value = img . reduceRegion ( ** { 'reducer' : ee . Reducer . sum (), 'geometry' : region , 'scale' : scale , 'maxPixels' : 1e12 }) return sum_value num_round ( num , decimal = 2 ) Rounds a number to a specified number of decimal places. Parameters: Name Type Description Default num float The number to round. required decimal int The number of decimal places to round. Defaults to 2. 2 Returns: Type Description float The number with the specified decimal places rounded. Source code in geemap/utils.py def num_round ( num , decimal = 2 ): \"\"\"Rounds a number to a specified number of decimal places. Args: num (float): The number to round. decimal (int, optional): The number of decimal places to round. Defaults to 2. Returns: float: The number with the specified decimal places rounded. \"\"\" return round ( num , decimal ) nwi_add_color ( fc ) Converts NWI vector dataset to image and add color to it. Parameters: Name Type Description Default fc object ee.FeatureCollection required Returns: Type Description object ee.Image Source code in geemap/utils.py def nwi_add_color ( fc ): \"\"\"Converts NWI vector dataset to image and add color to it. Args: fc (object): ee.FeatureCollection Returns: object: ee.Image \"\"\" emergent = ee . FeatureCollection ( fc . filter ( ee . Filter . eq ( 'WETLAND_TY' , 'Freshwater Emergent Wetland' ))) emergent = emergent . map ( lambda f : f . set ( 'R' , 127 ) . set ( 'G' , 195 ) . set ( 'B' , 28 )) # print(emergent.first()) forested = fc . filter ( ee . Filter . eq ( 'WETLAND_TY' , 'Freshwater Forested/Shrub Wetland' )) forested = forested . map ( lambda f : f . set ( 'R' , 0 ) . set ( 'G' , 136 ) . set ( 'B' , 55 )) pond = fc . filter ( ee . Filter . eq ( 'WETLAND_TY' , 'Freshwater Pond' )) pond = pond . map ( lambda f : f . set ( 'R' , 104 ) . set ( 'G' , 140 ) . set ( 'B' , 192 )) lake = fc . filter ( ee . Filter . eq ( 'WETLAND_TY' , 'Lake' )) lake = lake . map ( lambda f : f . set ( 'R' , 19 ) . set ( 'G' , 0 ) . set ( 'B' , 124 )) riverine = fc . filter ( ee . Filter . eq ( 'WETLAND_TY' , 'Riverine' )) riverine = riverine . map ( lambda f : f . set ( 'R' , 1 ) . set ( 'G' , 144 ) . set ( 'B' , 191 )) fc = ee . FeatureCollection ( emergent . merge ( forested ) . merge ( pond ) . merge ( lake ) . merge ( riverine )) # base = ee.Image(0).mask(0).toInt8() base = ee . Image () . byte () img = base . paint ( fc , 'R' ) \\ . addBands ( base . paint ( fc , 'G' ) . addBands ( base . paint ( fc , 'B' ))) return img remove_geometry ( fc ) Remove .geo coordinate field from a FeatureCollection Parameters: Name Type Description Default fc object The input FeatureCollection. required Returns: Type Description object The output FeatureCollection without the geometry field. Source code in geemap/utils.py def remove_geometry ( fc ): \"\"\"Remove .geo coordinate field from a FeatureCollection Args: fc (object): The input FeatureCollection. Returns: object: The output FeatureCollection without the geometry field. \"\"\" return fc . select ([ \".*\" ], None , False ) rename_bands ( img , in_band_names , out_band_names ) Renames image bands. Parameters: Name Type Description Default img object The image to be renamed. required in_band_names list The list of of input band names. required out_band_names list The list of output band names. required Returns: Type Description object The output image with the renamed bands. Source code in geemap/utils.py def rename_bands ( img , in_band_names , out_band_names ): \"\"\"Renames image bands. Args: img (object): The image to be renamed. in_band_names (list): The list of of input band names. out_band_names (list): The list of output band names. Returns: object: The output image with the renamed bands. \"\"\" return img . select ( in_band_names , out_band_names ) str_to_num ( in_str ) Converts a string to an ee.Number. Parameters: Name Type Description Default in_str str The string to convert to a number. required Returns: Type Description object ee.Number Source code in geemap/utils.py def str_to_num ( in_str ): \"\"\"Converts a string to an ee.Number. Args: in_str (str): The string to convert to a number. Returns: object: ee.Number \"\"\" return ee . Number . parse ( str ) summarize_by_group ( collection , column , group , group_name , stats_type , return_dict = True ) Calculates summary statistics by group. Parameters: Name Type Description Default collection object The input feature collection required column str The value column to calculate summary statistics. required group str The name of the group column. required group_name str The new group name to use. required stats_type str The type of summary statistics. required return_dict bool Whether to return the result as a dictionary. True Returns: Type Description object ee.Dictionary or ee.List Source code in geemap/utils.py def summarize_by_group ( collection , column , group , group_name , stats_type , return_dict = True ): \"\"\"Calculates summary statistics by group. Args: collection (object): The input feature collection column (str): The value column to calculate summary statistics. group (str): The name of the group column. group_name (str): The new group name to use. stats_type (str): The type of summary statistics. return_dict (bool): Whether to return the result as a dictionary. Returns: object: ee.Dictionary or ee.List \"\"\" stats_type = stats_type . lower () allowed_stats = [ 'min' , 'max' , 'mean' , 'median' , 'sum' , 'stdDev' , 'variance' ] if stats_type not in allowed_stats : print ( 'The stats type must be one of the following: {} ' . format ( ',' . join ( allowed_stats ))) return stats_dict = { 'min' : ee . Reducer . min (), 'max' : ee . Reducer . max (), 'mean' : ee . Reducer . mean (), 'median' : ee . Reducer . median (), 'sum' : ee . Reducer . sum (), 'stdDev' : ee . Reducer . stdDev (), 'variance' : ee . Reducer . variance () } selectors = [ column , group ] stats = collection . reduceColumns ( ** { 'selectors' : selectors , 'reducer' : stats_dict [ stats_type ] . group ( ** { 'groupField' : 1 , 'groupName' : group_name }) }) results = ee . List ( ee . Dictionary ( stats ) . get ( 'groups' )) if return_dict : keys = results . map ( lambda k : ee . Dictionary ( k ) . get ( group_name )) values = results . map ( lambda v : ee . Dictionary ( v ) . get ( stats_type )) results = ee . Dictionary . fromLists ( keys , values ) return results summary_stats ( collection , column ) Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean, sample standard deviation, sample variance, total standard deviation and total variance of the selected property. Parameters: Name Type Description Default collection FeatureCollection The input feature collection to calculate summary statistics. required column str The name of the column to calculate summary statistics. required Returns: Type Description dict The dictionary containing information about the summary statistics. Source code in geemap/utils.py def summary_stats ( collection , column ): \"\"\"Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean, sample standard deviation, sample variance, total standard deviation and total variance of the selected property. Args: collection (FeatureCollection): The input feature collection to calculate summary statistics. column (str): The name of the column to calculate summary statistics. Returns: dict: The dictionary containing information about the summary statistics. \"\"\" stats = collection . aggregate_stats ( column ) . getInfo () return eval ( str ( stats )) . get ( 'values' ) vec_area ( fc ) Calculate the area (m2) of each each feature in a feature collection. Parameters: Name Type Description Default fc object The feature collection to compute the area. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def vec_area ( fc ): \"\"\"Calculate the area (m2) of each each feature in a feature collection. Args: fc (object): The feature collection to compute the area. Returns: object: ee.FeatureCollection \"\"\" return fc . map ( lambda f : f . set ({ 'area_m2' : f . area ( 1 ) . round ()})) vec_area_ha ( fc ) Calculate the area (hectare) of each each feature in a feature collection. Parameters: Name Type Description Default fc object The feature collection to compute the area. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def vec_area_ha ( fc ): \"\"\"Calculate the area (hectare) of each each feature in a feature collection. Args: fc (object): The feature collection to compute the area. Returns: object: ee.FeatureCollection \"\"\" return fc . map ( lambda f : f . set ({ 'area_ha' : f . area ( 1 ) . divide ( 1e4 ) . round ()})) vec_area_km2 ( fc ) Calculate the area (km2) of each each feature in a feature collection. Parameters: Name Type Description Default fc object The feature collection to compute the area. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def vec_area_km2 ( fc ): \"\"\"Calculate the area (km2) of each each feature in a feature collection. Args: fc (object): The feature collection to compute the area. Returns: object: ee.FeatureCollection \"\"\" return fc . map ( lambda f : f . set ({ 'area_km2' : f . area ( 1 ) . divide ( 1e6 ) . round ()})) vec_area_mi2 ( fc ) Calculate the area (square mile) of each each feature in a feature collection. Parameters: Name Type Description Default fc object The feature collection to compute the area. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def vec_area_mi2 ( fc ): \"\"\"Calculate the area (square mile) of each each feature in a feature collection. Args: fc (object): The feature collection to compute the area. Returns: object: ee.FeatureCollection \"\"\" return fc . map ( lambda f : f . set ({ 'area_mi2' : f . area ( 1 ) . divide ( 2.59e6 ) . round ()}))","title":"utils module"},{"location":"utils/#utilities-module","text":"","title":"utilities module"},{"location":"utils/#geemap.utils","text":"Module of various Earth Engine utility functions.","title":"geemap.utils"},{"location":"utils/#geemap.utils.annual_NAIP","text":"Create an NAIP mosaic of a specified year for a specified region. Parameters: Name Type Description Default year int The specified year to create the mosaic for. required region object ee.Geometry required Returns: Type Description object ee.Image Source code in geemap/utils.py def annual_NAIP ( year , region ): \"\"\"Create an NAIP mosaic of a specified year for a specified region. Args: year (int): The specified year to create the mosaic for. region (object): ee.Geometry Returns: object: ee.Image \"\"\" start_date = ee . Date . fromYMD ( year , 1 , 1 ) end_date = ee . Date . fromYMD ( year , 12 , 31 ) collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) \\ . filterDate ( start_date , end_date ) \\ . filterBounds ( region ) time_start = ee . Date ( ee . List ( collection . aggregate_array ( 'system:time_start' )) . sort () . get ( 0 )) time_end = ee . Date ( ee . List ( collection . aggregate_array ( 'system:time_end' )) . sort () . get ( - 1 )) image = ee . Image ( collection . mosaic () . clip ( region )) NDWI = ee . Image ( image ) . normalizedDifference ( [ 'G' , 'N' ]) . select ([ 'nd' ], [ 'ndwi' ]) NDVI = ee . Image ( image ) . normalizedDifference ( [ 'N' , 'R' ]) . select ([ 'nd' ], [ 'ndvi' ]) image = image . addBands ( NDWI ) image = image . addBands ( NDVI ) return image . set ({ 'system:time_start' : time_start , 'system:time_end' : time_end })","title":"annual_NAIP()"},{"location":"utils/#geemap.utils.array_mean","text":"Calculates the mean of an array along the given axis. Parameters: Name Type Description Default arr object Array to calculate mean. required Returns: Type Description object ee.Number Source code in geemap/utils.py def array_mean ( arr ): \"\"\"Calculates the mean of an array along the given axis. Args: arr (object): Array to calculate mean. Returns: object: ee.Number \"\"\" total = ee . Array ( arr ) . accum ( 0 ) . get ([ - 1 ]) size = arr . length () return ee . Number ( total . divide ( size ))","title":"array_mean()"},{"location":"utils/#geemap.utils.array_sum","text":"Accumulates elements of an array along the given axis. Parameters: Name Type Description Default arr object Array to accumulate. required Returns: Type Description object ee.Number Source code in geemap/utils.py def array_sum ( arr ): \"\"\"Accumulates elements of an array along the given axis. Args: arr (object): Array to accumulate. Returns: object: ee.Number \"\"\" return ee . Array ( arr ) . accum ( 0 ) . get ([ - 1 ])","title":"array_sum()"},{"location":"utils/#geemap.utils.bands_to_image_collection","text":"Converts all bands in an image to an image collection. Parameters: Name Type Description Default img object The image to convert. required Returns: Type Description object ee.ImageCollection Source code in geemap/utils.py def bands_to_image_collection ( img ): \"\"\"Converts all bands in an image to an image collection. Args: img (object): The image to convert. Returns: object: ee.ImageCollection \"\"\" collection = ee . ImageCollection ( img . bandNames () . map ( lambda b : img . select ([ b ]))) return collection","title":"bands_to_image_collection()"},{"location":"utils/#geemap.utils.column_stats","text":"Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean, sample standard deviation, sample variance, total standard deviation and total variance of the selected property. Parameters: Name Type Description Default collection FeatureCollection The input feature collection to calculate statistics. required column str The name of the column to calculate statistics. required stats_type str The type of statistics to calculate. required Returns: Type Description dict The dictionary containing information about the requested statistics. Source code in geemap/utils.py def column_stats ( collection , column , stats_type ): \"\"\"Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean, sample standard deviation, sample variance, total standard deviation and total variance of the selected property. Args: collection (FeatureCollection): The input feature collection to calculate statistics. column (str): The name of the column to calculate statistics. stats_type (str): The type of statistics to calculate. Returns: dict: The dictionary containing information about the requested statistics. \"\"\" stats_type = stats_type . lower () allowed_stats = [ 'min' , 'max' , 'mean' , 'median' , 'sum' , 'stdDev' , 'variance' ] if stats_type not in allowed_stats : print ( 'The stats type must be one of the following: {} ' . format ( ',' . join ( allowed_stats ))) return stats_dict = { 'min' : ee . Reducer . min (), 'max' : ee . Reducer . max (), 'mean' : ee . Reducer . mean (), 'median' : ee . Reducer . median (), 'sum' : ee . Reducer . sum (), 'stdDev' : ee . Reducer . stdDev (), 'variance' : ee . Reducer . variance () } selectors = [ column ] stats = collection . reduceColumns ( ** { 'selectors' : selectors , 'reducer' : stats_dict [ stats_type ] }) return stats","title":"column_stats()"},{"location":"utils/#geemap.utils.dict_to_csv","text":"Downloads an ee.Dictionary as a CSV file. Parameters: Name Type Description Default data_dict ee.Dictionary The input ee.Dictionary. required out_csv str The output file path to the CSV file. required by_row bool Whether to use by row or by column. Defaults to False. False Source code in geemap/utils.py def dict_to_csv ( data_dict , out_csv , by_row = False ): \"\"\"Downloads an ee.Dictionary as a CSV file. Args: data_dict (ee.Dictionary): The input ee.Dictionary. out_csv (str): The output file path to the CSV file. by_row (bool, optional): Whether to use by row or by column. Defaults to False. \"\"\" import geemap out_dir = os . path . dirname ( out_csv ) if not os . path . exists ( out_dir ): os . makedirs ( out_dir ) if not by_row : csv_feature = ee . Feature ( None , data_dict ) csv_feat_col = ee . FeatureCollection ([ csv_feature ]) else : keys = data_dict . keys () data = keys . map ( lambda k : ee . Dictionary ({ 'name' : k , 'value' : data_dict . get ( k )})) csv_feature = data . map ( lambda f : ee . Feature ( None , f )) csv_feat_col = ee . FeatureCollection ( csv_feature ) geemap . ee_export_vector ( csv_feat_col , out_csv )","title":"dict_to_csv()"},{"location":"utils/#geemap.utils.ee_initialize","text":"Authenticates Earth Engine and initialize an Earth Engine session Source code in geemap/utils.py def ee_initialize ( token_name = 'EARTHENGINE_TOKEN' ): \"\"\"Authenticates Earth Engine and initialize an Earth Engine session \"\"\" try : ee_token = os . environ . get ( token_name ) if ee_token is not None : credential = '{\"refresh_token\":\" %s \"}' % ee_token credential_file_path = os . path . expanduser ( \"~/.config/earthengine/\" ) os . makedirs ( credential_file_path , exist_ok = True ) with open ( credential_file_path + 'credentials' , 'w' ) as file : file . write ( credential ) ee . Initialize () except : ee . Authenticate () ee . Initialize ()","title":"ee_initialize()"},{"location":"utils/#geemap.utils.ee_num_round","text":"Rounds a number to a specified number of decimal places. Parameters: Name Type Description Default num ee.Number The number to round. required decimal int The number of decimal places to round. Defaults to 2. 2 Returns: Type Description ee.Number The number with the specified decimal places rounded. Source code in geemap/utils.py def ee_num_round ( num , decimal = 2 ): \"\"\"Rounds a number to a specified number of decimal places. Args: num (ee.Number): The number to round. decimal (int, optional): The number of decimal places to round. Defaults to 2. Returns: ee.Number: The number with the specified decimal places rounded. \"\"\" format_str = '%. {} f' . format ( decimal ) return ee . Number . parse ( ee . Number ( num ) . format ( format_str ))","title":"ee_num_round()"},{"location":"utils/#geemap.utils.extract_values_to_points","text":"Extracts image values to points. Parameters: Name Type Description Default in_points object ee.FeatureCollection required img object ee.Image required label str The column name to keep. required scale float The image resolution to use. Defaults to None. None Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def extract_values_to_points ( in_points , img , label , scale = None ): \"\"\"Extracts image values to points. Args: in_points (object): ee.FeatureCollection img (object): ee.Image label (str): The column name to keep. scale (float, optional): The image resolution to use. Defaults to None. Returns: object: ee.FeatureCollection \"\"\" if scale is None : scale = image_scale ( img ) out_fc = img . sampleRegions ( ** { 'collection' : in_points , 'properties' : [ label ], 'scale' : scale }) return out_fc","title":"extract_values_to_points()"},{"location":"utils/#geemap.utils.filter_HUC08","text":"Filters HUC08 watersheds intersecting a given region. Parameters: Name Type Description Default region object ee.Geometry required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def filter_HUC08 ( region ): \"\"\"Filters HUC08 watersheds intersecting a given region. Args: region (object): ee.Geometry Returns: object: ee.FeatureCollection \"\"\" USGS_HUC08 = ee . FeatureCollection ( 'USGS/WBD/2017/HUC08' ) # Subbasins HUC08 = USGS_HUC08 . filterBounds ( region ) return HUC08","title":"filter_HUC08()"},{"location":"utils/#geemap.utils.filter_HUC10","text":"Filters HUC10 watersheds intersecting a given region. Parameters: Name Type Description Default region object ee.Geometry required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def filter_HUC10 ( region ): \"\"\"Filters HUC10 watersheds intersecting a given region. Args: region (object): ee.Geometry Returns: object: ee.FeatureCollection \"\"\" USGS_HUC10 = ee . FeatureCollection ( 'USGS/WBD/2017/HUC10' ) # Watersheds HUC10 = USGS_HUC10 . filterBounds ( region ) return HUC10","title":"filter_HUC10()"},{"location":"utils/#geemap.utils.filter_NWI","text":"Retrives NWI dataset for a given HUC8 watershed. Parameters: Name Type Description Default HUC08_Id str The HUC8 watershed id. required region object ee.Geometry required exclude_riverine bool Whether to exclude riverine wetlands. Defaults to True. True Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def filter_NWI ( HUC08_Id , region , exclude_riverine = True ): \"\"\"Retrives NWI dataset for a given HUC8 watershed. Args: HUC08_Id (str): The HUC8 watershed id. region (object): ee.Geometry exclude_riverine (bool, optional): Whether to exclude riverine wetlands. Defaults to True. Returns: object: ee.FeatureCollection \"\"\" nwi_asset_prefix = 'users/wqs/NWI-HU8/HU8_' nwi_asset_suffix = '_Wetlands' nwi_asset_path = nwi_asset_prefix + HUC08_Id + nwi_asset_suffix nwi_huc = ee . FeatureCollection ( nwi_asset_path ) . filterBounds ( region ) if exclude_riverine : nwi_huc = nwi_huc . filter ( ee . Filter . notEquals ( ** { 'leftField' : 'WETLAND_TY' , 'rightValue' : 'Riverine' })) return nwi_huc","title":"filter_NWI()"},{"location":"utils/#geemap.utils.find_HUC08","text":"Finds a HUC08 watershed based on a given HUC08 ID Parameters: Name Type Description Default HUC08_Id str The HUC08 ID. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def find_HUC08 ( HUC08_Id ): \"\"\"Finds a HUC08 watershed based on a given HUC08 ID Args: HUC08_Id (str): The HUC08 ID. Returns: object: ee.FeatureCollection \"\"\" USGS_HUC08 = ee . FeatureCollection ( 'USGS/WBD/2017/HUC08' ) # Subbasins HUC08 = USGS_HUC08 . filter ( ee . Filter . eq ( 'huc8' , HUC08_Id )) return HUC08","title":"find_HUC08()"},{"location":"utils/#geemap.utils.find_HUC10","text":"Finds a HUC10 watershed based on a given HUC08 ID Parameters: Name Type Description Default HUC10_Id str The HUC10 ID. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def find_HUC10 ( HUC10_Id ): \"\"\"Finds a HUC10 watershed based on a given HUC08 ID Args: HUC10_Id (str): The HUC10 ID. Returns: object: ee.FeatureCollection \"\"\" USGS_HUC10 = ee . FeatureCollection ( 'USGS/WBD/2017/HUC10' ) # Watersheds HUC10 = USGS_HUC10 . filter ( ee . Filter . eq ( 'huc10' , HUC10_Id )) return HUC10","title":"find_HUC10()"},{"location":"utils/#geemap.utils.find_landsat_by_path_row","text":"Finds Landsat images by WRS path number and row number. Parameters: Name Type Description Default landsat_col str The image collection id of Landsat. required path_num int The WRS path number. required row_num int the WRS row number. required Returns: Type Description object ee.ImageCollection Source code in geemap/utils.py def find_landsat_by_path_row ( landsat_col , path_num , row_num ): \"\"\"Finds Landsat images by WRS path number and row number. Args: landsat_col (str): The image collection id of Landsat. path_num (int): The WRS path number. row_num (int): the WRS row number. Returns: object: ee.ImageCollection \"\"\" try : if isinstance ( landsat_col , str ): landsat_col = ee . ImageCollection ( landsat_col ) collection = landsat_col . filter ( ee . Filter . eq ( 'WRS_PATH' , path_num )) \\ . filter ( ee . Filter . eq ( 'WRS_ROW' , row_num )) return collection except Exception as e : print ( e )","title":"find_landsat_by_path_row()"},{"location":"utils/#geemap.utils.find_NAIP","text":"Create annual NAIP mosaic for a given region. Parameters: Name Type Description Default region object ee.Geometry required add_NDVI bool Whether to add the NDVI band. Defaults to True. True add_NDWI bool Whether to add the NDWI band. Defaults to True. True Returns: Type Description object ee.ImageCollection Source code in geemap/utils.py def find_NAIP ( region , add_NDVI = True , add_NDWI = True ): \"\"\"Create annual NAIP mosaic for a given region. Args: region (object): ee.Geometry add_NDVI (bool, optional): Whether to add the NDVI band. Defaults to True. add_NDWI (bool, optional): Whether to add the NDWI band. Defaults to True. Returns: object: ee.ImageCollection \"\"\" init_collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) \\ . filterBounds ( region ) \\ . filterDate ( '2009-01-01' , '2019-12-31' ) \\ . filter ( ee . Filter . listContains ( \"system:band_names\" , \"N\" )) yearList = ee . List ( init_collection . distinct ( [ 'system:time_start' ]) . aggregate_array ( 'system:time_start' )) init_years = yearList . map ( lambda y : ee . Date ( y ) . get ( 'year' )) # remove duplicates init_years = ee . Dictionary ( init_years . reduce ( ee . Reducer . frequencyHistogram ())) . keys () years = init_years . map ( lambda x : ee . Number . parse ( x )) # years = init_years.map(lambda x: x) # Available NAIP years with NIR band def NAIPAnnual ( year ): start_date = ee . Date . fromYMD ( year , 1 , 1 ) end_date = ee . Date . fromYMD ( year , 12 , 31 ) collection = init_collection . filterDate ( start_date , end_date ) # .filterBounds(geometry) # .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) time_start = ee . Date ( ee . List ( collection . aggregate_array ( 'system:time_start' )) . sort () . get ( 0 )) . format ( 'YYYY-MM-dd' ) time_end = ee . Date ( ee . List ( collection . aggregate_array ( 'system:time_end' )) . sort () . get ( - 1 )) . format ( 'YYYY-MM-dd' ) col_size = collection . size () image = ee . Image ( collection . mosaic () . clip ( region )) if add_NDVI : NDVI = ee . Image ( image ) . normalizedDifference ( [ 'N' , 'R' ]) . select ([ 'nd' ], [ 'ndvi' ]) image = image . addBands ( NDVI ) if add_NDWI : NDWI = ee . Image ( image ) . normalizedDifference ( [ 'G' , 'N' ]) . select ([ 'nd' ], [ 'ndwi' ]) image = image . addBands ( NDWI ) return image . set ({ 'system:time_start' : time_start , 'system:time_end' : time_end , 'tiles' : col_size }) # remove years with incomplete coverage naip = ee . ImageCollection ( years . map ( NAIPAnnual )) mean_size = ee . Number ( naip . aggregate_mean ( 'tiles' )) total_sd = ee . Number ( naip . aggregate_total_sd ( 'tiles' )) threshold = mean_size . subtract ( total_sd . multiply ( 1 )) naip = naip . filter ( ee . Filter . Or ( ee . Filter . gte ( 'tiles' , threshold ), ee . Filter . gte ( 'tiles' , 15 ))) naip = naip . filter ( ee . Filter . gte ( 'tiles' , 7 )) naip_count = naip . size () naip_seq = ee . List . sequence ( 0 , naip_count . subtract ( 1 )) def set_index ( index ): img = ee . Image ( naip . toList ( naip_count ) . get ( index )) return img . set ({ 'system:uid' : ee . Number ( index ) . toUint8 ()}) naip = naip_seq . map ( set_index ) return ee . ImageCollection ( naip )","title":"find_NAIP()"},{"location":"utils/#geemap.utils.find_NWI","text":"Finds NWI dataset for a given HUC08 watershed. Parameters: Name Type Description Default HUC08_Id str The HUC08 watershed ID. required exclude_riverine bool Whether to exclude riverine wetlands. Defaults to True. True Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def find_NWI ( HUC08_Id , exclude_riverine = True ): \"\"\"Finds NWI dataset for a given HUC08 watershed. Args: HUC08_Id (str): The HUC08 watershed ID. exclude_riverine (bool, optional): Whether to exclude riverine wetlands. Defaults to True. Returns: object: ee.FeatureCollection \"\"\" nwi_asset_prefix = 'users/wqs/NWI-HU8/HU8_' nwi_asset_suffix = '_Wetlands' nwi_asset_path = nwi_asset_prefix + HUC08_Id + nwi_asset_suffix nwi_huc = ee . FeatureCollection ( nwi_asset_path ) if exclude_riverine : nwi_huc = nwi_huc . filter ( ee . Filter . notEquals ( ** { 'leftField' : 'WETLAND_TY' , 'rightValue' : 'Riverine' })) return nwi_huc","title":"find_NWI()"},{"location":"utils/#geemap.utils.get_all_NAIP","text":"Creates annual NAIP imagery mosaic. Parameters: Name Type Description Default start_year int The starting year. Defaults to 2009. 2009 end_year int The ending year. Defaults to 2019. 2019 Returns: Type Description object ee.ImageCollection Source code in geemap/utils.py def get_all_NAIP ( start_year = 2009 , end_year = 2019 ): \"\"\"Creates annual NAIP imagery mosaic. Args: start_year (int, optional): The starting year. Defaults to 2009. end_year (int, optional): The ending year. Defaults to 2019. Returns: object: ee.ImageCollection \"\"\" try : def get_annual_NAIP ( year ): try : collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) start_date = ee . Date . fromYMD ( year , 1 , 1 ) end_date = ee . Date . fromYMD ( year , 12 , 31 ) naip = collection . filterDate ( start_date , end_date ) \\ . filter ( ee . Filter . listContains ( \"system:band_names\" , \"N\" )) return ee . ImageCollection ( naip ) except Exception as e : print ( e ) years = ee . List . sequence ( start_year , end_year ) collection = years . map ( get_annual_NAIP ) return collection except Exception as e : print ( e )","title":"get_all_NAIP()"},{"location":"utils/#geemap.utils.get_annual_NAIP","text":"Filters NAIP ImageCollection by year. Parameters: Name Type Description Default year int The year to filter the NAIP ImageCollection. required RGBN bool Whether to retrieve 4-band NAIP imagery only. Defaults to True. True Returns: Type Description object ee.ImageCollection Source code in geemap/utils.py def get_annual_NAIP ( year , RGBN = True ): \"\"\"Filters NAIP ImageCollection by year. Args: year (int): The year to filter the NAIP ImageCollection. RGBN (bool, optional): Whether to retrieve 4-band NAIP imagery only. Defaults to True. Returns: object: ee.ImageCollection \"\"\" try : collection = ee . ImageCollection ( 'USDA/NAIP/DOQQ' ) start_date = str ( year ) + '-01-01' end_date = str ( year ) + '-12-31' naip = collection . filterDate ( start_date , end_date ) if RGBN : naip = naip . filter ( ee . Filter . listContains ( \"system:band_names\" , \"N\" )) return naip except Exception as e : print ( e )","title":"get_annual_NAIP()"},{"location":"utils/#geemap.utils.image_area","text":"Calculates the the area of an image. Parameters: Name Type Description Default img object ee.Image required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None denominator float The denominator to use for converting size from square meters to other units. Defaults to 1.0. 1.0 Returns: Type Description object ee.Dictionary Source code in geemap/utils.py def image_area ( img , region = None , scale = None , denominator = 1.0 ): \"\"\"Calculates the the area of an image. Args: img (object): ee.Image region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. denominator (float, optional): The denominator to use for converting size from square meters to other units. Defaults to 1.0. Returns: object: ee.Dictionary \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) pixel_area = img . unmask () . neq ( ee . Image ( 0 )) . multiply ( ee . Image . pixelArea ()) . divide ( denominator ) img_area = pixel_area . reduceRegion ( ** { 'geometry' : region , 'reducer' : ee . Reducer . sum (), 'scale' : scale , 'maxPixels' : 1e12 }) return img_area","title":"image_area()"},{"location":"utils/#geemap.utils.image_band_names","text":"Gets image band names. Parameters: Name Type Description Default img ee.Image The input image. required Returns: Type Description ee.List The returned list of image band names. Source code in geemap/utils.py def image_band_names ( img ): \"\"\"Gets image band names. Args: img (ee.Image): The input image. Returns: ee.List: The returned list of image band names. \"\"\" return img . bandNames ()","title":"image_band_names()"},{"location":"utils/#geemap.utils.image_cell_size","text":"Retrieves the image cell size (e.g., spatial resolution) Parameters: Name Type Description Default img object ee.Image required Returns: Type Description float The nominal scale in meters. Source code in geemap/utils.py def image_cell_size ( img ): \"\"\"Retrieves the image cell size (e.g., spatial resolution) Args: img (object): ee.Image Returns: float: The nominal scale in meters. \"\"\" bands = img . bandNames () scales = bands . map ( lambda b : img . select ([ b ]) . projection () . nominalScale ()) scale = ee . Algorithms . If ( scales . distinct () . size () . gt ( 1 ), ee . Dictionary . fromLists ( bands . getInfo (), scales ), scales . get ( 0 )) return scale","title":"image_cell_size()"},{"location":"utils/#geemap.utils.image_date","text":"Retrieves the image acquisition date. Parameters: Name Type Description Default img object ee.Image required date_format str The date format to use. Defaults to 'YYYY-MM-dd'. 'YYYY-MM-dd' Returns: Type Description str A string representing the acquisition of the image. Source code in geemap/utils.py def image_date ( img , date_format = 'YYYY-MM-dd' ): \"\"\"Retrieves the image acquisition date. Args: img (object): ee.Image date_format (str, optional): The date format to use. Defaults to 'YYYY-MM-dd'. Returns: str: A string representing the acquisition of the image. \"\"\" return ee . Date ( img . get ( 'system:time_start' )) . format ( date_format )","title":"image_date()"},{"location":"utils/#geemap.utils.image_max_value","text":"Retrieves the maximum value of an image. Parameters: Name Type Description Default img object The image to calculate the maximum value. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description object ee.Number Source code in geemap/utils.py def image_max_value ( img , region = None , scale = None ): \"\"\"Retrieves the maximum value of an image. Args: img (object): The image to calculate the maximum value. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: object: ee.Number \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) max_value = img . reduceRegion ( ** { 'reducer' : ee . Reducer . max (), 'geometry' : region , 'scale' : scale , 'maxPixels' : 1e12 }) return max_value","title":"image_max_value()"},{"location":"utils/#geemap.utils.image_mean_value","text":"Retrieves the mean value of an image. Parameters: Name Type Description Default img object The image to calculate the mean value. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description object ee.Number Source code in geemap/utils.py def image_mean_value ( img , region = None , scale = None ): \"\"\"Retrieves the mean value of an image. Args: img (object): The image to calculate the mean value. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: object: ee.Number \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) mean_value = img . reduceRegion ( ** { 'reducer' : ee . Reducer . mean (), 'geometry' : region , 'scale' : scale , 'maxPixels' : 1e12 }) return mean_value","title":"image_mean_value()"},{"location":"utils/#geemap.utils.image_min_value","text":"Retrieves the minimum value of an image. Parameters: Name Type Description Default img object The image to calculate the minimum value. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description object ee.Number Source code in geemap/utils.py def image_min_value ( img , region = None , scale = None ): \"\"\"Retrieves the minimum value of an image. Args: img (object): The image to calculate the minimum value. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: object: ee.Number \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) min_value = img . reduceRegion ( ** { 'reducer' : ee . Reducer . min (), 'geometry' : region , 'scale' : scale , 'maxPixels' : 1e12 }) return min_value","title":"image_min_value()"},{"location":"utils/#geemap.utils.image_reclassify","text":"Reclassify an image. Parameters: Name Type Description Default img object The image to which the remapping is applied. required in_list list The source values (numbers or EEArrays). All values in this list will be mapped to the corresponding value in 'out_list'. required out_list list The destination values (numbers or EEArrays). These are used to replace the corresponding values in 'from'. Must have the same number of values as 'in_list'. required Returns: Type Description object ee.Image Source code in geemap/utils.py def image_reclassify ( img , in_list , out_list ): \"\"\"Reclassify an image. Args: img (object): The image to which the remapping is applied. in_list (list): The source values (numbers or EEArrays). All values in this list will be mapped to the corresponding value in 'out_list'. out_list (list): The destination values (numbers or EEArrays). These are used to replace the corresponding values in 'from'. Must have the same number of values as 'in_list'. Returns: object: ee.Image \"\"\" image = img . remap ( in_list , out_list ) return image","title":"image_reclassify()"},{"location":"utils/#geemap.utils.image_scale","text":"Retrieves the image cell size (e.g., spatial resolution) Parameters: Name Type Description Default img object ee.Image required Returns: Type Description float The nominal scale in meters. Source code in geemap/utils.py def image_scale ( img ): \"\"\"Retrieves the image cell size (e.g., spatial resolution) Args: img (object): ee.Image Returns: float: The nominal scale in meters. \"\"\" # bands = img.bandNames() # scales = bands.map(lambda b: img.select([b]).projection().nominalScale()) # scale = ee.Algorithms.If(scales.distinct().size().gt(1), ee.Dictionary.fromLists(bands.getInfo(), scales), scales.get(0)) return img . select ( 0 ) . projection () . nominalScale ()","title":"image_scale()"},{"location":"utils/#geemap.utils.image_smoothing","text":"Smooths an image. Parameters: Name Type Description Default img object The image to be smoothed. required reducer object ee.Reducer required kernel object ee.Kernel required Returns: Type Description object ee.Image Source code in geemap/utils.py def image_smoothing ( img , reducer , kernel ): \"\"\"Smooths an image. Args: img (object): The image to be smoothed. reducer (object): ee.Reducer kernel (object): ee.Kernel Returns: object: ee.Image \"\"\" image = img . reduceNeighborhood ( ** { 'reducer' : reducer , 'kernel' : kernel , }) return image","title":"image_smoothing()"},{"location":"utils/#geemap.utils.image_std_value","text":"Retrieves the standard deviation of an image. Parameters: Name Type Description Default img object The image to calculate the standard deviation. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description object ee.Number Source code in geemap/utils.py def image_std_value ( img , region = None , scale = None ): \"\"\"Retrieves the standard deviation of an image. Args: img (object): The image to calculate the standard deviation. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: object: ee.Number \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) std_value = img . reduceRegion ( ** { 'reducer' : ee . Reducer . stdDev (), 'geometry' : region , 'scale' : scale , 'maxPixels' : 1e12 }) return std_value","title":"image_std_value()"},{"location":"utils/#geemap.utils.image_sum_value","text":"Retrieves the sum of an image. Parameters: Name Type Description Default img object The image to calculate the standard deviation. required region object The region over which to reduce data. Defaults to the footprint of the image's first band. None scale float A nominal scale in meters of the projection to work in. Defaults to None. None Returns: Type Description object ee.Number Source code in geemap/utils.py def image_sum_value ( img , region = None , scale = None ): \"\"\"Retrieves the sum of an image. Args: img (object): The image to calculate the standard deviation. region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band. scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None. Returns: object: ee.Number \"\"\" if region is None : region = img . geometry () if scale is None : scale = image_scale ( img ) sum_value = img . reduceRegion ( ** { 'reducer' : ee . Reducer . sum (), 'geometry' : region , 'scale' : scale , 'maxPixels' : 1e12 }) return sum_value","title":"image_sum_value()"},{"location":"utils/#geemap.utils.num_round","text":"Rounds a number to a specified number of decimal places. Parameters: Name Type Description Default num float The number to round. required decimal int The number of decimal places to round. Defaults to 2. 2 Returns: Type Description float The number with the specified decimal places rounded. Source code in geemap/utils.py def num_round ( num , decimal = 2 ): \"\"\"Rounds a number to a specified number of decimal places. Args: num (float): The number to round. decimal (int, optional): The number of decimal places to round. Defaults to 2. Returns: float: The number with the specified decimal places rounded. \"\"\" return round ( num , decimal )","title":"num_round()"},{"location":"utils/#geemap.utils.nwi_add_color","text":"Converts NWI vector dataset to image and add color to it. Parameters: Name Type Description Default fc object ee.FeatureCollection required Returns: Type Description object ee.Image Source code in geemap/utils.py def nwi_add_color ( fc ): \"\"\"Converts NWI vector dataset to image and add color to it. Args: fc (object): ee.FeatureCollection Returns: object: ee.Image \"\"\" emergent = ee . FeatureCollection ( fc . filter ( ee . Filter . eq ( 'WETLAND_TY' , 'Freshwater Emergent Wetland' ))) emergent = emergent . map ( lambda f : f . set ( 'R' , 127 ) . set ( 'G' , 195 ) . set ( 'B' , 28 )) # print(emergent.first()) forested = fc . filter ( ee . Filter . eq ( 'WETLAND_TY' , 'Freshwater Forested/Shrub Wetland' )) forested = forested . map ( lambda f : f . set ( 'R' , 0 ) . set ( 'G' , 136 ) . set ( 'B' , 55 )) pond = fc . filter ( ee . Filter . eq ( 'WETLAND_TY' , 'Freshwater Pond' )) pond = pond . map ( lambda f : f . set ( 'R' , 104 ) . set ( 'G' , 140 ) . set ( 'B' , 192 )) lake = fc . filter ( ee . Filter . eq ( 'WETLAND_TY' , 'Lake' )) lake = lake . map ( lambda f : f . set ( 'R' , 19 ) . set ( 'G' , 0 ) . set ( 'B' , 124 )) riverine = fc . filter ( ee . Filter . eq ( 'WETLAND_TY' , 'Riverine' )) riverine = riverine . map ( lambda f : f . set ( 'R' , 1 ) . set ( 'G' , 144 ) . set ( 'B' , 191 )) fc = ee . FeatureCollection ( emergent . merge ( forested ) . merge ( pond ) . merge ( lake ) . merge ( riverine )) # base = ee.Image(0).mask(0).toInt8() base = ee . Image () . byte () img = base . paint ( fc , 'R' ) \\ . addBands ( base . paint ( fc , 'G' ) . addBands ( base . paint ( fc , 'B' ))) return img","title":"nwi_add_color()"},{"location":"utils/#geemap.utils.remove_geometry","text":"Remove .geo coordinate field from a FeatureCollection Parameters: Name Type Description Default fc object The input FeatureCollection. required Returns: Type Description object The output FeatureCollection without the geometry field. Source code in geemap/utils.py def remove_geometry ( fc ): \"\"\"Remove .geo coordinate field from a FeatureCollection Args: fc (object): The input FeatureCollection. Returns: object: The output FeatureCollection without the geometry field. \"\"\" return fc . select ([ \".*\" ], None , False )","title":"remove_geometry()"},{"location":"utils/#geemap.utils.rename_bands","text":"Renames image bands. Parameters: Name Type Description Default img object The image to be renamed. required in_band_names list The list of of input band names. required out_band_names list The list of output band names. required Returns: Type Description object The output image with the renamed bands. Source code in geemap/utils.py def rename_bands ( img , in_band_names , out_band_names ): \"\"\"Renames image bands. Args: img (object): The image to be renamed. in_band_names (list): The list of of input band names. out_band_names (list): The list of output band names. Returns: object: The output image with the renamed bands. \"\"\" return img . select ( in_band_names , out_band_names )","title":"rename_bands()"},{"location":"utils/#geemap.utils.str_to_num","text":"Converts a string to an ee.Number. Parameters: Name Type Description Default in_str str The string to convert to a number. required Returns: Type Description object ee.Number Source code in geemap/utils.py def str_to_num ( in_str ): \"\"\"Converts a string to an ee.Number. Args: in_str (str): The string to convert to a number. Returns: object: ee.Number \"\"\" return ee . Number . parse ( str )","title":"str_to_num()"},{"location":"utils/#geemap.utils.summarize_by_group","text":"Calculates summary statistics by group. Parameters: Name Type Description Default collection object The input feature collection required column str The value column to calculate summary statistics. required group str The name of the group column. required group_name str The new group name to use. required stats_type str The type of summary statistics. required return_dict bool Whether to return the result as a dictionary. True Returns: Type Description object ee.Dictionary or ee.List Source code in geemap/utils.py def summarize_by_group ( collection , column , group , group_name , stats_type , return_dict = True ): \"\"\"Calculates summary statistics by group. Args: collection (object): The input feature collection column (str): The value column to calculate summary statistics. group (str): The name of the group column. group_name (str): The new group name to use. stats_type (str): The type of summary statistics. return_dict (bool): Whether to return the result as a dictionary. Returns: object: ee.Dictionary or ee.List \"\"\" stats_type = stats_type . lower () allowed_stats = [ 'min' , 'max' , 'mean' , 'median' , 'sum' , 'stdDev' , 'variance' ] if stats_type not in allowed_stats : print ( 'The stats type must be one of the following: {} ' . format ( ',' . join ( allowed_stats ))) return stats_dict = { 'min' : ee . Reducer . min (), 'max' : ee . Reducer . max (), 'mean' : ee . Reducer . mean (), 'median' : ee . Reducer . median (), 'sum' : ee . Reducer . sum (), 'stdDev' : ee . Reducer . stdDev (), 'variance' : ee . Reducer . variance () } selectors = [ column , group ] stats = collection . reduceColumns ( ** { 'selectors' : selectors , 'reducer' : stats_dict [ stats_type ] . group ( ** { 'groupField' : 1 , 'groupName' : group_name }) }) results = ee . List ( ee . Dictionary ( stats ) . get ( 'groups' )) if return_dict : keys = results . map ( lambda k : ee . Dictionary ( k ) . get ( group_name )) values = results . map ( lambda v : ee . Dictionary ( v ) . get ( stats_type )) results = ee . Dictionary . fromLists ( keys , values ) return results","title":"summarize_by_group()"},{"location":"utils/#geemap.utils.summary_stats","text":"Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean, sample standard deviation, sample variance, total standard deviation and total variance of the selected property. Parameters: Name Type Description Default collection FeatureCollection The input feature collection to calculate summary statistics. required column str The name of the column to calculate summary statistics. required Returns: Type Description dict The dictionary containing information about the summary statistics. Source code in geemap/utils.py def summary_stats ( collection , column ): \"\"\"Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean, sample standard deviation, sample variance, total standard deviation and total variance of the selected property. Args: collection (FeatureCollection): The input feature collection to calculate summary statistics. column (str): The name of the column to calculate summary statistics. Returns: dict: The dictionary containing information about the summary statistics. \"\"\" stats = collection . aggregate_stats ( column ) . getInfo () return eval ( str ( stats )) . get ( 'values' )","title":"summary_stats()"},{"location":"utils/#geemap.utils.vec_area","text":"Calculate the area (m2) of each each feature in a feature collection. Parameters: Name Type Description Default fc object The feature collection to compute the area. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def vec_area ( fc ): \"\"\"Calculate the area (m2) of each each feature in a feature collection. Args: fc (object): The feature collection to compute the area. Returns: object: ee.FeatureCollection \"\"\" return fc . map ( lambda f : f . set ({ 'area_m2' : f . area ( 1 ) . round ()}))","title":"vec_area()"},{"location":"utils/#geemap.utils.vec_area_ha","text":"Calculate the area (hectare) of each each feature in a feature collection. Parameters: Name Type Description Default fc object The feature collection to compute the area. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def vec_area_ha ( fc ): \"\"\"Calculate the area (hectare) of each each feature in a feature collection. Args: fc (object): The feature collection to compute the area. Returns: object: ee.FeatureCollection \"\"\" return fc . map ( lambda f : f . set ({ 'area_ha' : f . area ( 1 ) . divide ( 1e4 ) . round ()}))","title":"vec_area_ha()"},{"location":"utils/#geemap.utils.vec_area_km2","text":"Calculate the area (km2) of each each feature in a feature collection. Parameters: Name Type Description Default fc object The feature collection to compute the area. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def vec_area_km2 ( fc ): \"\"\"Calculate the area (km2) of each each feature in a feature collection. Args: fc (object): The feature collection to compute the area. Returns: object: ee.FeatureCollection \"\"\" return fc . map ( lambda f : f . set ({ 'area_km2' : f . area ( 1 ) . divide ( 1e6 ) . round ()}))","title":"vec_area_km2()"},{"location":"utils/#geemap.utils.vec_area_mi2","text":"Calculate the area (square mile) of each each feature in a feature collection. Parameters: Name Type Description Default fc object The feature collection to compute the area. required Returns: Type Description object ee.FeatureCollection Source code in geemap/utils.py def vec_area_mi2 ( fc ): \"\"\"Calculate the area (square mile) of each each feature in a feature collection. Args: fc (object): The feature collection to compute the area. Returns: object: ee.FeatureCollection \"\"\" return fc . map ( lambda f : f . set ({ 'area_mi2' : f . area ( 1 ) . divide ( 2.59e6 ) . round ()}))","title":"vec_area_mi2()"}]}